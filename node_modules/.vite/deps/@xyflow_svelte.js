import "./chunk-BTXWKV3U.js";
import "./chunk-MZVN5SDE.js";
import {
  MediaQuery
} from "./chunk-GCII4M73.js";
import "./chunk-2J42W6L2.js";
import "./chunk-7RQDXF5S.js";
import {
  CLASS,
  STYLE,
  action,
  add_locations,
  append_styles,
  attribute_effect,
  bind_element_size,
  bind_this,
  check_target,
  cleanup_styles,
  clsx,
  component,
  create_ownership_validator,
  css_props,
  hmr,
  if_block,
  init,
  legacy_api,
  log_if_contains_state,
  onDestroy,
  onMount,
  prop,
  rest_props,
  set_attribute,
  set_class,
  set_style,
  snippet,
  spread_props,
  validate_binding,
  validate_each_keys,
  wrap_snippet
} from "./chunk-JCODUZ3G.js";
import "./chunk-U7P2NEEE.js";
import {
  append,
  comment,
  from_html,
  from_svg,
  set_text,
  text
} from "./chunk-XE7QBTOV.js";
import {
  $window,
  FILENAME,
  HMR,
  add_svelte_meta,
  apply,
  child,
  delegate,
  each,
  effect_root,
  effect_tracking,
  event,
  exclude_from_object,
  fallback,
  first_child,
  get,
  getContext,
  next,
  noop,
  on,
  pop,
  proxy,
  push,
  reset,
  set,
  setContext,
  sibling,
  snapshot,
  state,
  strict_equals,
  tag,
  tag_proxy,
  template_effect,
  to_array,
  track_reactivity_loss,
  untrack,
  user_derived,
  user_effect,
  user_pre_effect
} from "./chunk-L663KA6Z.js";
import "./chunk-ICXW7654.js";
import "./chunk-OHYQYV5R.js";
import "./chunk-V4OQ3NZ2.js";

// node_modules/d3-dispatch/src/dispatch.js
var noop2 = { value: () => {
} };
function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}
function Dispatch(_) {
  this._ = _;
}
function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return { type: t, name };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._, T = parseTypenames(typename + "", _), t, i = -1, n = T.length;
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get2(_[t], typename.name))) return t;
      return;
    }
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set2(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set2(_[t], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};
function get2(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}
function set2(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop2, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({ name, value: callback });
  return type;
}
var dispatch_default = dispatch;

// node_modules/d3-selection/src/namespaces.js
var xhtml = "http://www.w3.org/1999/xhtml";
var namespaces_default = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

// node_modules/d3-selection/src/namespace.js
function namespace_default(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return namespaces_default.hasOwnProperty(prefix) ? { space: namespaces_default[prefix], local: name } : name;
}

// node_modules/d3-selection/src/creator.js
function creatorInherit(name) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator_default(name) {
  var fullname = namespace_default(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}

// node_modules/d3-selection/src/selector.js
function none() {
}
function selector_default(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

// node_modules/d3-selection/src/selection/select.js
function select_default(select) {
  if (typeof select !== "function") select = selector_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/array.js
function array(x) {
  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
}

// node_modules/d3-selection/src/selectorAll.js
function empty() {
  return [];
}
function selectorAll_default(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}

// node_modules/d3-selection/src/selection/selectAll.js
function arrayAll(select) {
  return function() {
    return array(select.apply(this, arguments));
  };
}
function selectAll_default(select) {
  if (typeof select === "function") select = arrayAll(select);
  else select = selectorAll_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }
  return new Selection(subgroups, parents);
}

// node_modules/d3-selection/src/matcher.js
function matcher_default(selector) {
  return function() {
    return this.matches(selector);
  };
}
function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}

// node_modules/d3-selection/src/selection/selectChild.js
var find = Array.prototype.find;
function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selectChild_default(match) {
  return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
}

// node_modules/d3-selection/src/selection/selectChildren.js
var filter = Array.prototype.filter;
function children() {
  return Array.from(this.children);
}
function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}
function selectChildren_default(match) {
  return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
}

// node_modules/d3-selection/src/selection/filter.js
function filter_default(match) {
  if (typeof match !== "function") match = matcher_default(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/selection/sparse.js
function sparse_default(update) {
  return new Array(update.length);
}

// node_modules/d3-selection/src/selection/enter.js
function enter_default() {
  return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
}
function EnterNode(parent, datum2) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum2;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child2) {
    return this._parent.insertBefore(child2, this._next);
  },
  insertBefore: function(child2, next2) {
    return this._parent.insertBefore(child2, next2);
  },
  querySelector: function(selector) {
    return this._parent.querySelector(selector);
  },
  querySelectorAll: function(selector) {
    return this._parent.querySelectorAll(selector);
  }
};

// node_modules/d3-selection/src/constant.js
function constant_default(x) {
  return function() {
    return x;
  };
}

// node_modules/d3-selection/src/selection/data.js
function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0, node, groupLength = group.length, dataLength = data.length;
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}
function bindKey(parent, group, enter, update, exit, data, key2) {
  var i, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key2.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }
  for (i = 0; i < dataLength; ++i) {
    keyValue = key2.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
      exit[i] = node;
    }
  }
}
function datum(node) {
  return node.__data__;
}
function data_default(value, key2) {
  if (!arguments.length) return Array.from(this, datum);
  var bind = key2 ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
  if (typeof value !== "function") value = constant_default(value);
  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j], group = groups[j], groupLength = group.length, data = arraylike(value.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key2);
    for (var i0 = 0, i1 = 0, previous, next2; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next2 = updateGroup[i1]) && ++i1 < dataLength) ;
        previous._next = next2 || null;
      }
    }
  }
  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}
function arraylike(data) {
  return typeof data === "object" && "length" in data ? data : Array.from(data);
}

// node_modules/d3-selection/src/selection/exit.js
function exit_default() {
  return new Selection(this._exit || this._groups.map(sparse_default), this._parents);
}

// node_modules/d3-selection/src/selection/join.js
function join_default(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter) enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update) update = update.selection();
  }
  if (onexit == null) exit.remove();
  else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}

// node_modules/d3-selection/src/selection/merge.js
function merge_default(context) {
  var selection2 = context.selection ? context.selection() : context;
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Selection(merges, this._parents);
}

// node_modules/d3-selection/src/selection/order.js
function order_default() {
  for (var groups = this._groups, j = -1, m = groups.length; ++j < m; ) {
    for (var group = groups[j], i = group.length - 1, next2 = group[i], node; --i >= 0; ) {
      if (node = group[i]) {
        if (next2 && node.compareDocumentPosition(next2) ^ 4) next2.parentNode.insertBefore(node, next2);
        next2 = node;
      }
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/sort.js
function sort_default(compare) {
  if (!compare) compare = ascending;
  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }
  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection(sortgroups, this._parents).order();
}
function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

// node_modules/d3-selection/src/selection/call.js
function call_default() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

// node_modules/d3-selection/src/selection/nodes.js
function nodes_default() {
  return Array.from(this);
}

// node_modules/d3-selection/src/selection/node.js
function node_default() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }
  return null;
}

// node_modules/d3-selection/src/selection/size.js
function size_default() {
  let size = 0;
  for (const node of this) ++size;
  return size;
}

// node_modules/d3-selection/src/selection/empty.js
function empty_default() {
  return !this.node();
}

// node_modules/d3-selection/src/selection/each.js
function each_default(callback) {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/attr.js
function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}
function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}
function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}
function attr_default(name, value) {
  var fullname = namespace_default(name);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
}

// node_modules/d3-selection/src/window.js
function window_default(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
}

// node_modules/d3-selection/src/selection/style.js
function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}
function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}
function style_default(name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
}
function styleValue(node, name) {
  return node.style.getPropertyValue(name) || window_default(node).getComputedStyle(node, null).getPropertyValue(name);
}

// node_modules/d3-selection/src/selection/property.js
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}
function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}
function property_default(name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
}

// node_modules/d3-selection/src/selection/classed.js
function classArray(string) {
  return string.trim().split(/^|\s+/);
}
function classList(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};
function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}
function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function classed_default(name, value) {
  var names = classArray(name + "");
  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }
  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
}

// node_modules/d3-selection/src/selection/text.js
function textRemove() {
  this.textContent = "";
}
function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}
function text_default(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
}

// node_modules/d3-selection/src/selection/html.js
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}
function html_default(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}

// node_modules/d3-selection/src/selection/raise.js
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}
function raise_default() {
  return this.each(raise);
}

// node_modules/d3-selection/src/selection/lower.js
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function lower_default() {
  return this.each(lower);
}

// node_modules/d3-selection/src/selection/append.js
function append_default(name) {
  var create2 = typeof name === "function" ? name : creator_default(name);
  return this.select(function() {
    return this.appendChild(create2.apply(this, arguments));
  });
}

// node_modules/d3-selection/src/selection/insert.js
function constantNull() {
  return null;
}
function insert_default(name, before) {
  var create2 = typeof name === "function" ? name : creator_default(name), select = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
  return this.select(function() {
    return this.insertBefore(create2.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

// node_modules/d3-selection/src/selection/remove.js
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}
function remove_default() {
  return this.each(remove);
}

// node_modules/d3-selection/src/selection/clone.js
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function clone_default(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

// node_modules/d3-selection/src/selection/datum.js
function datum_default(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}

// node_modules/d3-selection/src/selection/on.js
function contextListener(listener) {
  return function(event2) {
    listener.call(this, event2, this.__data__);
  };
}
function parseTypenames2(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return { type: t, name };
  });
}
function onRemove(typename) {
  return function() {
    var on2 = this.__on;
    if (!on2) return;
    for (var j = 0, i = -1, m = on2.length, o; j < m; ++j) {
      if (o = on2[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on2[++i] = o;
      }
    }
    if (++i) on2.length = i;
    else delete this.__on;
  };
}
function onAdd(typename, value, options) {
  return function() {
    var on2 = this.__on, o, listener = contextListener(value);
    if (on2) for (var j = 0, m = on2.length; j < m; ++j) {
      if ((o = on2[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
        this.addEventListener(o.type, o.listener = listener, o.options = options);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, options);
    o = { type: typename.type, name: typename.name, value, listener, options };
    if (!on2) this.__on = [o];
    else on2.push(o);
  };
}
function on_default(typename, value, options) {
  var typenames = parseTypenames2(typename + ""), i, n = typenames.length, t;
  if (arguments.length < 2) {
    var on2 = this.node().__on;
    if (on2) for (var j = 0, m = on2.length, o; j < m; ++j) {
      for (i = 0, o = on2[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }
  on2 = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i) this.each(on2(typenames[i], value, options));
  return this;
}

// node_modules/d3-selection/src/selection/dispatch.js
function dispatchEvent(node, type, params) {
  var window2 = window_default(node), event2 = window2.CustomEvent;
  if (typeof event2 === "function") {
    event2 = new event2(type, params);
  } else {
    event2 = window2.document.createEvent("Event");
    if (params) event2.initEvent(type, params.bubbles, params.cancelable), event2.detail = params.detail;
    else event2.initEvent(type, false, false);
  }
  node.dispatchEvent(event2);
}
function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}
function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}
function dispatch_default2(type, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));
}

// node_modules/d3-selection/src/selection/iterator.js
function* iterator_default() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) yield node;
    }
  }
}

// node_modules/d3-selection/src/selection/index.js
var root = [null];
function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}
function selection() {
  return new Selection([[document.documentElement]], root);
}
function selection_selection() {
  return this;
}
Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: select_default,
  selectAll: selectAll_default,
  selectChild: selectChild_default,
  selectChildren: selectChildren_default,
  filter: filter_default,
  data: data_default,
  enter: enter_default,
  exit: exit_default,
  join: join_default,
  merge: merge_default,
  selection: selection_selection,
  order: order_default,
  sort: sort_default,
  call: call_default,
  nodes: nodes_default,
  node: node_default,
  size: size_default,
  empty: empty_default,
  each: each_default,
  attr: attr_default,
  style: style_default,
  property: property_default,
  classed: classed_default,
  text: text_default,
  html: html_default,
  raise: raise_default,
  lower: lower_default,
  append: append_default,
  insert: insert_default,
  remove: remove_default,
  clone: clone_default,
  datum: datum_default,
  on: on_default,
  dispatch: dispatch_default2,
  [Symbol.iterator]: iterator_default
};
var selection_default = selection;

// node_modules/d3-selection/src/select.js
function select_default2(selector) {
  return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);
}

// node_modules/d3-selection/src/local.js
var nextId = 0;
function local() {
  return new Local();
}
function Local() {
  this._ = "@" + (++nextId).toString(36);
}
Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node) {
    var id2 = this._;
    while (!(id2 in node)) if (!(node = node.parentNode)) return;
    return node[id2];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};

// node_modules/d3-selection/src/sourceEvent.js
function sourceEvent_default(event2) {
  let sourceEvent;
  while (sourceEvent = event2.sourceEvent) event2 = sourceEvent;
  return event2;
}

// node_modules/d3-selection/src/pointer.js
function pointer_default(event2, node) {
  event2 = sourceEvent_default(event2);
  if (node === void 0) node = event2.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event2.clientX, point.y = event2.clientY;
      point = point.matrixTransform(node.getScreenCTM().inverse());
      return [point.x, point.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event2.clientX - rect.left - node.clientLeft, event2.clientY - rect.top - node.clientTop];
    }
  }
  return [event2.pageX, event2.pageY];
}

// node_modules/d3-drag/src/noevent.js
var nonpassive = { passive: false };
var nonpassivecapture = { capture: true, passive: false };
function nopropagation(event2) {
  event2.stopImmediatePropagation();
}
function noevent_default(event2) {
  event2.preventDefault();
  event2.stopImmediatePropagation();
}

// node_modules/d3-drag/src/nodrag.js
function nodrag_default(view) {
  var root30 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", noevent_default, nonpassivecapture);
  if ("onselectstart" in root30) {
    selection2.on("selectstart.drag", noevent_default, nonpassivecapture);
  } else {
    root30.__noselect = root30.style.MozUserSelect;
    root30.style.MozUserSelect = "none";
  }
}
function yesdrag(view, noclick) {
  var root30 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", null);
  if (noclick) {
    selection2.on("click.drag", noevent_default, nonpassivecapture);
    setTimeout(function() {
      selection2.on("click.drag", null);
    }, 0);
  }
  if ("onselectstart" in root30) {
    selection2.on("selectstart.drag", null);
  } else {
    root30.style.MozUserSelect = root30.__noselect;
    delete root30.__noselect;
  }
}

// node_modules/d3-drag/src/constant.js
var constant_default2 = (x) => () => x;

// node_modules/d3-drag/src/event.js
function DragEvent(type, {
  sourceEvent,
  subject,
  target,
  identifier,
  active,
  x,
  y,
  dx,
  dy,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
    subject: { value: subject, enumerable: true, configurable: true },
    target: { value: target, enumerable: true, configurable: true },
    identifier: { value: identifier, enumerable: true, configurable: true },
    active: { value: active, enumerable: true, configurable: true },
    x: { value: x, enumerable: true, configurable: true },
    y: { value: y, enumerable: true, configurable: true },
    dx: { value: dx, enumerable: true, configurable: true },
    dy: { value: dy, enumerable: true, configurable: true },
    _: { value: dispatch2 }
  });
}
DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};

// node_modules/d3-drag/src/drag.js
function defaultFilter(event2) {
  return !event2.ctrlKey && !event2.button;
}
function defaultContainer() {
  return this.parentNode;
}
function defaultSubject(event2, d) {
  return d == null ? { x: event2.x, y: event2.y } : d;
}
function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function drag_default() {
  var filter2 = defaultFilter, container = defaultContainer, subject = defaultSubject, touchable = defaultTouchable, gestures = {}, listeners = dispatch_default("start", "drag", "end"), active = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;
  function drag2(selection2) {
    selection2.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved, nonpassive).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function mousedowned(event2, d) {
    if (touchending || !filter2.call(this, event2, d)) return;
    var gesture = beforestart(this, container.call(this, event2, d), event2, d, "mouse");
    if (!gesture) return;
    select_default2(event2.view).on("mousemove.drag", mousemoved, nonpassivecapture).on("mouseup.drag", mouseupped, nonpassivecapture);
    nodrag_default(event2.view);
    nopropagation(event2);
    mousemoving = false;
    mousedownx = event2.clientX;
    mousedowny = event2.clientY;
    gesture("start", event2);
  }
  function mousemoved(event2) {
    noevent_default(event2);
    if (!mousemoving) {
      var dx = event2.clientX - mousedownx, dy = event2.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag", event2);
  }
  function mouseupped(event2) {
    select_default2(event2.view).on("mousemove.drag mouseup.drag", null);
    yesdrag(event2.view, mousemoving);
    noevent_default(event2);
    gestures.mouse("end", event2);
  }
  function touchstarted(event2, d) {
    if (!filter2.call(this, event2, d)) return;
    var touches = event2.changedTouches, c = container.call(this, event2, d), n = touches.length, i, gesture;
    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(this, c, event2, d, touches[i].identifier, touches[i])) {
        nopropagation(event2);
        gesture("start", event2, touches[i]);
      }
    }
  }
  function touchmoved(event2) {
    var touches = event2.changedTouches, n = touches.length, i, gesture;
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        noevent_default(event2);
        gesture("drag", event2, touches[i]);
      }
    }
  }
  function touchended(event2) {
    var touches = event2.changedTouches, n = touches.length, i, gesture;
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, 500);
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        nopropagation(event2);
        gesture("end", event2, touches[i]);
      }
    }
  }
  function beforestart(that, container2, event2, d, identifier, touch) {
    var dispatch2 = listeners.copy(), p = pointer_default(touch || event2, container2), dx, dy, s;
    if ((s = subject.call(that, new DragEvent("beforestart", {
      sourceEvent: event2,
      target: drag2,
      identifier,
      active,
      x: p[0],
      y: p[1],
      dx: 0,
      dy: 0,
      dispatch: dispatch2
    }), d)) == null) return;
    dx = s.x - p[0] || 0;
    dy = s.y - p[1] || 0;
    return function gesture(type, event3, touch2) {
      var p0 = p, n;
      switch (type) {
        case "start":
          gestures[identifier] = gesture, n = active++;
          break;
        case "end":
          delete gestures[identifier], --active;
        // falls through
        case "drag":
          p = pointer_default(touch2 || event3, container2), n = active;
          break;
      }
      dispatch2.call(
        type,
        that,
        new DragEvent(type, {
          sourceEvent: event3,
          subject: s,
          target: drag2,
          identifier,
          active: n,
          x: p[0] + dx,
          y: p[1] + dy,
          dx: p[0] - p0[0],
          dy: p[1] - p0[1],
          dispatch: dispatch2
        }),
        d
      );
    };
  }
  drag2.filter = function(_) {
    return arguments.length ? (filter2 = typeof _ === "function" ? _ : constant_default2(!!_), drag2) : filter2;
  };
  drag2.container = function(_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : constant_default2(_), drag2) : container;
  };
  drag2.subject = function(_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : constant_default2(_), drag2) : subject;
  };
  drag2.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant_default2(!!_), drag2) : touchable;
  };
  drag2.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag2 : value;
  };
  drag2.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag2) : Math.sqrt(clickDistance2);
  };
  return drag2;
}

// node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key2 in definition) prototype[key2] = definition[key2];
  return prototype;
}

// node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format) ? rgbn(named[format]) : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}
function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Rgb, rgb, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}
function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl();
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), h = NaN, s = max - min, l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}
function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Hsl, hsl, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

// node_modules/d3-color/src/math.js
var radians = Math.PI / 180;
var degrees = 180 / Math.PI;

// node_modules/d3-color/src/lab.js
var K = 18;
var Xn = 0.96422;
var Yn = 1;
var Zn = 0.82521;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t2 = 3 * t1 * t1;
var t3 = t1 * t1 * t1;
function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y;
  else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}
function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}
function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Lab, lab, extend(Color, {
  brighter(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb() {
    var y = (this.l + 16) / 116, x = isNaN(this.a) ? y : y + this.a / 500, z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb(3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.033454 * z),
      lrgb2rgb(0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));
function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}
function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}
function lrgb2rgb(x) {
  return 255 * (x <= 31308e-7 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}
function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * degrees;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}
function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}
function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * radians;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}
define_default(Hcl, hcl, extend(Color, {
  brighter(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb() {
    return hcl2lab(this).rgb();
  }
}));

// node_modules/d3-color/src/cubehelix.js
var A = -0.14861;
var B = 1.78277;
var C = -0.29227;
var D = -0.90649;
var E = 1.97294;
var ED = E * D;
var EB = E * B;
var BC_DA = B * C - D * A;
function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l, k = (E * (g - l) - C * bl) / D, s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), h = s ? Math.atan2(k, bl) * degrees - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}
function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}
function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Cubehelix, cubehelix, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * radians, l = +this.l, a = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh2 = Math.cos(h), sinh2 = Math.sin(h);
    return new Rgb(
      255 * (l + a * (A * cosh2 + B * sinh2)),
      255 * (l + a * (C * cosh2 + D * sinh2)),
      255 * (l + a * (E * cosh2)),
      this.opacity
    );
  }
}));

// node_modules/d3-interpolate/src/basis.js
function basis(t12, v0, v1, v2, v3) {
  var t22 = t12 * t12, t32 = t22 * t12;
  return ((1 - 3 * t12 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t12 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;
}
function basis_default(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/constant.js
var constant_default3 = (x) => () => x;

// node_modules/d3-interpolate/src/color.js
function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}
function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}
function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant_default3(isNaN(a) ? b : a);
}
function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant_default3(isNaN(a) ? b : a);
  };
}
function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant_default3(isNaN(a) ? b : a);
}

// node_modules/d3-interpolate/src/rgb.js
var rgb_default = (function rgbGamma(y) {
  var color2 = gamma(y);
  function rgb2(start2, end) {
    var r = color2((start2 = rgb(start2)).r, (end = rgb(end)).r), g = color2(start2.g, end.g), b = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
    return function(t) {
      start2.r = r(t);
      start2.g = g(t);
      start2.b = b(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
})(1);
function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color2;
    for (i = 0; i < n; ++i) {
      color2 = rgb(colors[i]);
      r[i] = color2.r || 0;
      g[i] = color2.g || 0;
      b[i] = color2.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color2.opacity = 1;
    return function(t) {
      color2.r = r(t);
      color2.g = g(t);
      color2.b = b(t);
      return color2 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default);
var rgbBasisClosed = rgbSpline(basisClosed_default);

// node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a, b) {
  if (!b) b = [];
  var n = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
  return function(t) {
    for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
}
function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}

// node_modules/d3-interpolate/src/array.js
function genericArray(a, b) {
  var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c = new Array(nb), i;
  for (i = 0; i < na; ++i) x[i] = value_default(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];
  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}

// node_modules/d3-interpolate/src/date.js
function date_default(a, b) {
  var d = /* @__PURE__ */ new Date();
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}

// node_modules/d3-interpolate/src/number.js
function number_default(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}

// node_modules/d3-interpolate/src/object.js
function object_default(a, b) {
  var i = {}, c = {}, k;
  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};
  for (k in b) {
    if (k in a) {
      i[k] = value_default(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }
  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
}

// node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function string_default(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
  a = a + "", b = b + "";
  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs;
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s[i]) s[i] += bm;
      else s[++i] = bm;
    } else {
      s[++i] = null;
      q.push({ i, x: number_default(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs;
    else s[++i] = bs;
  }
  return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2) s[(o = q[i2]).i] = o.x(t);
    return s.join("");
  });
}

// node_modules/d3-interpolate/src/value.js
function value_default(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant_default3(b) : (t === "number" ? number_default : t === "string" ? (c = color(b)) ? (b = c, rgb_default) : string_default : b instanceof color ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default)(a, b);
}

// node_modules/d3-interpolate/src/transform/decompose.js
var degrees2 = 180 / Math.PI;
var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees2,
    skewX: Math.atan(skewX) * degrees2,
    scaleX,
    scaleY
  };
}

// node_modules/d3-interpolate/src/transform/parse.js
var svgNode;
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? identity : decompose_default(m.a, m.b, m.c, m.d, m.e, m.f);
}
function parseSvg(value) {
  if (value == null) return identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity;
  value = value.matrix;
  return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
}

// node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse, pxComma, pxParen, degParen) {
  function pop2(s) {
    return s.length ? s.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360;
      else if (b - a > 180) a += 360;
      q.push({ i: s.push(pop2(s) + "rotate(", null, degParen) - 2, x: number_default(a, b) });
    } else if (b) {
      s.push(pop2(s) + "rotate(" + b + degParen);
    }
  }
  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({ i: s.push(pop2(s) + "skewX(", null, degParen) - 2, x: number_default(a, b) });
    } else if (b) {
      s.push(pop2(s) + "skewX(" + b + degParen);
    }
  }
  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop2(s) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop2(s) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a, b) {
    var s = [], q = [];
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/d3-interpolate/src/zoom.js
var epsilon2 = 1e-12;
function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}
function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}
function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}
var zoom_default = (function zoomRho(rho, rho2, rho4) {
  function zoom2(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      };
    } else {
      var d1 = Math.sqrt(d2), b02 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b12 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b02 * b02 + 1) - b02), r1 = Math.log(Math.sqrt(b12 * b12 + 1) - b12);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s = t * S, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s + r0)
        ];
      };
    }
    i.duration = S * 1e3 * rho / Math.SQRT2;
    return i;
  }
  zoom2.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };
  return zoom2;
})(Math.SQRT2, 2, 4);

// node_modules/d3-interpolate/src/hsl.js
function hsl2(hue2) {
  return function(start2, end) {
    var h = hue2((start2 = hsl(start2)).h, (end = hsl(end)).h), s = nogamma(start2.s, end.s), l = nogamma(start2.l, end.l), opacity = nogamma(start2.opacity, end.opacity);
    return function(t) {
      start2.h = h(t);
      start2.s = s(t);
      start2.l = l(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  };
}
var hsl_default = hsl2(hue);
var hslLong = hsl2(nogamma);

// node_modules/d3-interpolate/src/hcl.js
function hcl2(hue2) {
  return function(start2, end) {
    var h = hue2((start2 = hcl(start2)).h, (end = hcl(end)).h), c = nogamma(start2.c, end.c), l = nogamma(start2.l, end.l), opacity = nogamma(start2.opacity, end.opacity);
    return function(t) {
      start2.h = h(t);
      start2.c = c(t);
      start2.l = l(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  };
}
var hcl_default = hcl2(hue);
var hclLong = hcl2(nogamma);

// node_modules/d3-interpolate/src/cubehelix.js
function cubehelix2(hue2) {
  return (function cubehelixGamma(y) {
    y = +y;
    function cubehelix3(start2, end) {
      var h = hue2((start2 = cubehelix(start2)).h, (end = cubehelix(end)).h), s = nogamma(start2.s, end.s), l = nogamma(start2.l, end.l), opacity = nogamma(start2.opacity, end.opacity);
      return function(t) {
        start2.h = h(t);
        start2.s = s(t);
        start2.l = l(Math.pow(t, y));
        start2.opacity = opacity(t);
        return start2 + "";
      };
    }
    cubehelix3.gamma = cubehelixGamma;
    return cubehelix3;
  })(1);
}
var cubehelix_default = cubehelix2(hue);
var cubehelixLong = cubehelix2(nogamma);

// node_modules/d3-timer/src/timer.js
var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1e3;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time) {
  var t = new Timer();
  t.restart(callback, delay, time);
  return t;
}
function timerFlush() {
  now();
  ++frame;
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(void 0, e);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t02, t12 = taskHead, t22, time = Infinity;
  while (t12) {
    if (t12._call) {
      if (time > t12._time) time = t12._time;
      t02 = t12, t12 = t12._next;
    } else {
      t22 = t12._next, t12._next = null;
      t12 = t02 ? t02._next = t22 : taskHead = t22;
    }
  }
  taskTail = t02;
  sleep(time);
}
function sleep(time) {
  if (frame) return;
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow;
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

// node_modules/d3-timer/src/timeout.js
function timeout_default(callback, delay, time) {
  var t = new Timer();
  delay = delay == null ? 0 : +delay;
  t.restart((elapsed) => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}

// node_modules/d3-transition/src/transition/schedule.js
var emptyOn = dispatch_default("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
function schedule_default(node, name, id2, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id2 in schedules) return;
  create(node, id2, {
    name,
    index,
    // For context during callback.
    group,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init2(node, id2) {
  var schedule = get3(node, id2);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}
function set3(node, id2) {
  var schedule = get3(node, id2);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}
function get3(node, id2) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id2])) throw new Error("transition not found");
  return schedule;
}
function create(node, id2, self) {
  var schedules = node.__transition, tween;
  schedules[id2] = self;
  self.timer = timer(schedule, 0, self.time);
  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start2, self.delay, self.time);
    if (self.delay <= elapsed) start2(elapsed - self.delay);
  }
  function start2(elapsed) {
    var i, j, n, o;
    if (self.state !== SCHEDULED) return stop();
    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;
      if (o.state === STARTED) return timeout_default(start2);
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      } else if (+i < id2) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }
    timeout_default(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return;
    self.state = STARTED;
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }
  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1), i = -1, n = tween.length;
    while (++i < n) {
      tween[i].call(node, t);
    }
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }
  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id2];
    for (var i in schedules) return;
    delete node.__transition;
  }
}

// node_modules/d3-transition/src/interrupt.js
function interrupt_default(node, name) {
  var schedules = node.__transition, schedule, active, empty2 = true, i;
  if (!schedules) return;
  name = name == null ? null : name + "";
  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) {
      empty2 = false;
      continue;
    }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }
  if (empty2) delete node.__transition;
}

// node_modules/d3-transition/src/selection/interrupt.js
function interrupt_default2(name) {
  return this.each(function() {
    interrupt_default(this, name);
  });
}

// node_modules/d3-transition/src/transition/tween.js
function tweenRemove(id2, name) {
  var tween0, tween1;
  return function() {
    var schedule = set3(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }
    schedule.tween = tween1;
  };
}
function tweenFunction(id2, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error();
  return function() {
    var schedule = set3(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = { name, value }, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }
    schedule.tween = tween1;
  };
}
function tween_default(name, value) {
  var id2 = this._id;
  name += "";
  if (arguments.length < 2) {
    var tween = get3(this.node(), id2).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }
  return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
}
function tweenValue(transition2, name, value) {
  var id2 = transition2._id;
  transition2.each(function() {
    var schedule = set3(this, id2);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });
  return function(node) {
    return get3(node, id2).value[name];
  };
}

// node_modules/d3-transition/src/transition/interpolate.js
function interpolate_default(a, b) {
  var c;
  return (typeof b === "number" ? number_default : b instanceof color ? rgb_default : (c = color(b)) ? (b = c, rgb_default) : string_default)(a, b);
}

// node_modules/d3-transition/src/transition/attr.js
function attrRemove2(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS2(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant2(name, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrConstantNS2(fullname, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrFunction2(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attrFunctionNS2(fullname, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attr_default2(name, value) {
  var fullname = namespace_default(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate_default;
  return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS2 : attrFunction2)(fullname, i, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname) : (fullname.local ? attrConstantNS2 : attrConstant2)(fullname, i, value));
}

// node_modules/d3-transition/src/transition/attrTween.js
function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}
function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}
function attrTweenNS(fullname, value) {
  var t02, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t02 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t02;
  }
  tween._value = value;
  return tween;
}
function attrTween(name, value) {
  var t02, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t02 = (i0 = i) && attrInterpolate(name, i);
    return t02;
  }
  tween._value = value;
  return tween;
}
function attrTween_default(name, value) {
  var key2 = "attr." + name;
  if (arguments.length < 2) return (key2 = this.tween(key2)) && key2._value;
  if (value == null) return this.tween(key2, null);
  if (typeof value !== "function") throw new Error();
  var fullname = namespace_default(name);
  return this.tween(key2, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}

// node_modules/d3-transition/src/transition/delay.js
function delayFunction(id2, value) {
  return function() {
    init2(this, id2).delay = +value.apply(this, arguments);
  };
}
function delayConstant(id2, value) {
  return value = +value, function() {
    init2(this, id2).delay = value;
  };
}
function delay_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get3(this.node(), id2).delay;
}

// node_modules/d3-transition/src/transition/duration.js
function durationFunction(id2, value) {
  return function() {
    set3(this, id2).duration = +value.apply(this, arguments);
  };
}
function durationConstant(id2, value) {
  return value = +value, function() {
    set3(this, id2).duration = value;
  };
}
function duration_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get3(this.node(), id2).duration;
}

// node_modules/d3-transition/src/transition/ease.js
function easeConstant(id2, value) {
  if (typeof value !== "function") throw new Error();
  return function() {
    set3(this, id2).ease = value;
  };
}
function ease_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant(id2, value)) : get3(this.node(), id2).ease;
}

// node_modules/d3-transition/src/transition/easeVarying.js
function easeVarying(id2, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (typeof v !== "function") throw new Error();
    set3(this, id2).ease = v;
  };
}
function easeVarying_default(value) {
  if (typeof value !== "function") throw new Error();
  return this.each(easeVarying(this._id, value));
}

// node_modules/d3-transition/src/transition/filter.js
function filter_default2(match) {
  if (typeof match !== "function") match = matcher_default(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Transition(subgroups, this._parents, this._name, this._id);
}

// node_modules/d3-transition/src/transition/merge.js
function merge_default2(transition2) {
  if (transition2._id !== this._id) throw new Error();
  for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Transition(merges, this._parents, this._name, this._id);
}

// node_modules/d3-transition/src/transition/on.js
function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}
function onFunction(id2, name, listener) {
  var on0, on1, sit = start(name) ? init2 : set3;
  return function() {
    var schedule = sit(this, id2), on2 = schedule.on;
    if (on2 !== on0) (on1 = (on0 = on2).copy()).on(name, listener);
    schedule.on = on1;
  };
}
function on_default2(name, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get3(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
}

// node_modules/d3-transition/src/transition/remove.js
function removeFunction(id2) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id2) return;
    if (parent) parent.removeChild(this);
  };
}
function remove_default2() {
  return this.on("end.remove", removeFunction(this._id));
}

// node_modules/d3-transition/src/transition/select.js
function select_default3(select) {
  var name = this._name, id2 = this._id;
  if (typeof select !== "function") select = selector_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        schedule_default(subgroup[i], name, id2, i, subgroup, get3(node, id2));
      }
    }
  }
  return new Transition(subgroups, this._parents, name, id2);
}

// node_modules/d3-transition/src/transition/selectAll.js
function selectAll_default3(select) {
  var name = this._name, id2 = this._id;
  if (typeof select !== "function") select = selectorAll_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children2 = select.call(node, node.__data__, i, group), child2, inherit2 = get3(node, id2), k = 0, l = children2.length; k < l; ++k) {
          if (child2 = children2[k]) {
            schedule_default(child2, name, id2, k, children2, inherit2);
          }
        }
        subgroups.push(children2);
        parents.push(node);
      }
    }
  }
  return new Transition(subgroups, parents, name, id2);
}

// node_modules/d3-transition/src/transition/selection.js
var Selection2 = selection_default.prototype.constructor;
function selection_default2() {
  return new Selection2(this._groups, this._parents);
}

// node_modules/d3-transition/src/transition/style.js
function styleNull(name, interpolate) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}
function styleRemove2(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant2(name, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function styleFunction2(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function styleMaybeRemove(id2, name) {
  var on0, on1, listener0, key2 = "style." + name, event2 = "end." + key2, remove2;
  return function() {
    var schedule = set3(this, id2), on2 = schedule.on, listener = schedule.value[key2] == null ? remove2 || (remove2 = styleRemove2(name)) : void 0;
    if (on2 !== on0 || listener0 !== listener) (on1 = (on0 = on2).copy()).on(event2, listener0 = listener);
    schedule.on = on1;
  };
}
function style_default2(name, value, priority) {
  var i = (name += "") === "transform" ? interpolateTransformCss : interpolate_default;
  return value == null ? this.styleTween(name, styleNull(name, i)).on("end.style." + name, styleRemove2(name)) : typeof value === "function" ? this.styleTween(name, styleFunction2(name, i, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant2(name, i, value), priority).on("end.style." + name, null);
}

// node_modules/d3-transition/src/transition/styleTween.js
function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}
function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}
function styleTween_default(name, value, priority) {
  var key2 = "style." + (name += "");
  if (arguments.length < 2) return (key2 = this.tween(key2)) && key2._value;
  if (value == null) return this.tween(key2, null);
  if (typeof value !== "function") throw new Error();
  return this.tween(key2, styleTween(name, value, priority == null ? "" : priority));
}

// node_modules/d3-transition/src/transition/text.js
function textConstant2(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction2(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function text_default2(value) {
  return this.tween("text", typeof value === "function" ? textFunction2(tweenValue(this, "text", value)) : textConstant2(value == null ? "" : value + ""));
}

// node_modules/d3-transition/src/transition/textTween.js
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}
function textTween(value) {
  var t02, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t02 = (i0 = i) && textInterpolate(i);
    return t02;
  }
  tween._value = value;
  return tween;
}
function textTween_default(value) {
  var key2 = "text";
  if (arguments.length < 1) return (key2 = this.tween(key2)) && key2._value;
  if (value == null) return this.tween(key2, null);
  if (typeof value !== "function") throw new Error();
  return this.tween(key2, textTween(value));
}

// node_modules/d3-transition/src/transition/transition.js
function transition_default() {
  var name = this._name, id0 = this._id, id1 = newId();
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit2 = get3(node, id0);
        schedule_default(node, name, id1, i, group, {
          time: inherit2.time + inherit2.delay + inherit2.duration,
          delay: 0,
          duration: inherit2.duration,
          ease: inherit2.ease
        });
      }
    }
  }
  return new Transition(groups, this._parents, name, id1);
}

// node_modules/d3-transition/src/transition/end.js
function end_default() {
  var on0, on1, that = this, id2 = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = { value: reject }, end = { value: function() {
      if (--size === 0) resolve();
    } };
    that.each(function() {
      var schedule = set3(this, id2), on2 = schedule.on;
      if (on2 !== on0) {
        on1 = (on0 = on2).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }
      schedule.on = on1;
    });
    if (size === 0) resolve();
  });
}

// node_modules/d3-transition/src/transition/index.js
var id = 0;
function Transition(groups, parents, name, id2) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id2;
}
function transition(name) {
  return selection_default().transition(name);
}
function newId() {
  return ++id;
}
var selection_prototype = selection_default.prototype;
Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: select_default3,
  selectAll: selectAll_default3,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: filter_default2,
  merge: merge_default2,
  selection: selection_default2,
  transition: transition_default,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: on_default2,
  attr: attr_default2,
  attrTween: attrTween_default,
  style: style_default2,
  styleTween: styleTween_default,
  text: text_default2,
  textTween: textTween_default,
  remove: remove_default2,
  tween: tween_default,
  delay: delay_default,
  duration: duration_default,
  ease: ease_default,
  easeVarying: easeVarying_default,
  end: end_default,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};

// node_modules/d3-ease/src/cubic.js
function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

// node_modules/d3-ease/src/poly.js
var exponent = 3;
var polyIn = (function custom(e) {
  e = +e;
  function polyIn2(t) {
    return Math.pow(t, e);
  }
  polyIn2.exponent = custom;
  return polyIn2;
})(exponent);
var polyOut = (function custom2(e) {
  e = +e;
  function polyOut2(t) {
    return 1 - Math.pow(1 - t, e);
  }
  polyOut2.exponent = custom2;
  return polyOut2;
})(exponent);
var polyInOut = (function custom3(e) {
  e = +e;
  function polyInOut2(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }
  polyInOut2.exponent = custom3;
  return polyInOut2;
})(exponent);

// node_modules/d3-ease/src/sin.js
var pi = Math.PI;
var halfPi = pi / 2;

// node_modules/d3-ease/src/math.js
function tpmt(x) {
  return (Math.pow(2, -10 * x) - 9765625e-10) * 1.0009775171065494;
}

// node_modules/d3-ease/src/bounce.js
var b1 = 4 / 11;
var b2 = 6 / 11;
var b3 = 8 / 11;
var b4 = 3 / 4;
var b5 = 9 / 11;
var b6 = 10 / 11;
var b7 = 15 / 16;
var b8 = 21 / 22;
var b9 = 63 / 64;
var b0 = 1 / b1 / b1;

// node_modules/d3-ease/src/back.js
var overshoot = 1.70158;
var backIn = (function custom4(s) {
  s = +s;
  function backIn2(t) {
    return (t = +t) * t * (s * (t - 1) + t);
  }
  backIn2.overshoot = custom4;
  return backIn2;
})(overshoot);
var backOut = (function custom5(s) {
  s = +s;
  function backOut2(t) {
    return --t * t * ((t + 1) * s + t) + 1;
  }
  backOut2.overshoot = custom5;
  return backOut2;
})(overshoot);
var backInOut = (function custom6(s) {
  s = +s;
  function backInOut2(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }
  backInOut2.overshoot = custom6;
  return backInOut2;
})(overshoot);

// node_modules/d3-ease/src/elastic.js
var tau = 2 * Math.PI;
var amplitude = 1;
var period = 0.3;
var elasticIn = (function custom7(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
  function elasticIn2(t) {
    return a * tpmt(- --t) * Math.sin((s - t) / p);
  }
  elasticIn2.amplitude = function(a2) {
    return custom7(a2, p * tau);
  };
  elasticIn2.period = function(p2) {
    return custom7(a, p2);
  };
  return elasticIn2;
})(amplitude, period);
var elasticOut = (function custom8(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
  function elasticOut2(t) {
    return 1 - a * tpmt(t = +t) * Math.sin((t + s) / p);
  }
  elasticOut2.amplitude = function(a2) {
    return custom8(a2, p * tau);
  };
  elasticOut2.period = function(p2) {
    return custom8(a, p2);
  };
  return elasticOut2;
})(amplitude, period);
var elasticInOut = (function custom9(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
  function elasticInOut2(t) {
    return ((t = t * 2 - 1) < 0 ? a * tpmt(-t) * Math.sin((s - t) / p) : 2 - a * tpmt(t) * Math.sin((s + t) / p)) / 2;
  }
  elasticInOut2.amplitude = function(a2) {
    return custom9(a2, p * tau);
  };
  elasticInOut2.period = function(p2) {
    return custom9(a, p2);
  };
  return elasticInOut2;
})(amplitude, period);

// node_modules/d3-transition/src/selection/transition.js
var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit(node, id2) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id2])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id2} not found`);
    }
  }
  return timing;
}
function transition_default2(name) {
  var id2, timing;
  if (name instanceof Transition) {
    id2 = name._id, name = name._name;
  } else {
    id2 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
  }
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        schedule_default(node, name, id2, i, group, timing || inherit(node, id2));
      }
    }
  }
  return new Transition(groups, this._parents, name, id2);
}

// node_modules/d3-transition/src/selection/index.js
selection_default.prototype.interrupt = interrupt_default2;
selection_default.prototype.transition = transition_default2;

// node_modules/d3-zoom/src/constant.js
var constant_default4 = (x) => () => x;

// node_modules/d3-zoom/src/event.js
function ZoomEvent(type, {
  sourceEvent,
  target,
  transform: transform2,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
    target: { value: target, enumerable: true, configurable: true },
    transform: { value: transform2, enumerable: true, configurable: true },
    _: { value: dispatch2 }
  });
}

// node_modules/d3-zoom/src/transform.js
function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}
Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity2 = new Transform(1, 0, 0);
transform.prototype = Transform.prototype;
function transform(node) {
  while (!node.__zoom) if (!(node = node.parentNode)) return identity2;
  return node.__zoom;
}

// node_modules/d3-zoom/src/noevent.js
function nopropagation2(event2) {
  event2.stopImmediatePropagation();
}
function noevent_default2(event2) {
  event2.preventDefault();
  event2.stopImmediatePropagation();
}

// node_modules/d3-zoom/src/zoom.js
function defaultFilter2(event2) {
  return (!event2.ctrlKey || event2.type === "wheel") && !event2.button;
}
function defaultExtent() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}
function defaultTransform() {
  return this.__zoom || identity2;
}
function defaultWheelDelta(event2) {
  return -event2.deltaY * (event2.deltaMode === 1 ? 0.05 : event2.deltaMode ? 1 : 2e-3) * (event2.ctrlKey ? 10 : 1);
}
function defaultTouchable2() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function defaultConstrain(transform2, extent, translateExtent) {
  var dx0 = transform2.invertX(extent[0][0]) - translateExtent[0][0], dx1 = transform2.invertX(extent[1][0]) - translateExtent[1][0], dy0 = transform2.invertY(extent[0][1]) - translateExtent[0][1], dy1 = transform2.invertY(extent[1][1]) - translateExtent[1][1];
  return transform2.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}
function zoom_default2() {
  var filter2 = defaultFilter2, extent = defaultExtent, constrain = defaultConstrain, wheelDelta2 = defaultWheelDelta, touchable = defaultTouchable2, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration = 250, interpolate = zoom_default, listeners = dispatch_default("start", "zoom", "end"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;
  function zoom2(selection2) {
    selection2.property("__zoom", defaultTransform).on("wheel.zoom", wheeled, { passive: false }).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  zoom2.transform = function(collection, transform2, point, event2) {
    var selection2 = collection.selection ? collection.selection() : collection;
    selection2.property("__zoom", defaultTransform);
    if (collection !== selection2) {
      schedule(collection, transform2, point, event2);
    } else {
      selection2.interrupt().each(function() {
        gesture(this, arguments).event(event2).start().zoom(null, typeof transform2 === "function" ? transform2.apply(this, arguments) : transform2).end();
      });
    }
  };
  zoom2.scaleBy = function(selection2, k, p, event2) {
    zoom2.scaleTo(selection2, function() {
      var k0 = this.__zoom.k, k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p, event2);
  };
  zoom2.scaleTo = function(selection2, k, p, event2) {
    zoom2.transform(selection2, function() {
      var e = extent.apply(this, arguments), t02 = this.__zoom, p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p, p1 = t02.invert(p0), k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t02, k1), p0, p1), e, translateExtent);
    }, p, event2);
  };
  zoom2.translateBy = function(selection2, x, y, event2) {
    zoom2.transform(selection2, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments), translateExtent);
    }, null, event2);
  };
  zoom2.translateTo = function(selection2, x, y, p, event2) {
    zoom2.transform(selection2, function() {
      var e = extent.apply(this, arguments), t = this.__zoom, p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(identity2.translate(p0[0], p0[1]).scale(t.k).translate(
        typeof x === "function" ? -x.apply(this, arguments) : -x,
        typeof y === "function" ? -y.apply(this, arguments) : -y
      ), e, translateExtent);
    }, p, event2);
  };
  function scale(transform2, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform2.k ? transform2 : new Transform(k, transform2.x, transform2.y);
  }
  function translate(transform2, p0, p1) {
    var x = p0[0] - p1[0] * transform2.k, y = p0[1] - p1[1] * transform2.k;
    return x === transform2.x && y === transform2.y ? transform2 : new Transform(transform2.k, x, y);
  }
  function centroid(extent2) {
    return [(+extent2[0][0] + +extent2[1][0]) / 2, (+extent2[0][1] + +extent2[1][1]) / 2];
  }
  function schedule(transition2, transform2, point, event2) {
    transition2.on("start.zoom", function() {
      gesture(this, arguments).event(event2).start();
    }).on("interrupt.zoom end.zoom", function() {
      gesture(this, arguments).event(event2).end();
    }).tween("zoom", function() {
      var that = this, args = arguments, g = gesture(that, args).event(event2), e = extent.apply(that, args), p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point, w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]), a = that.__zoom, b = typeof transform2 === "function" ? transform2.apply(that, args) : transform2, i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
      return function(t) {
        if (t === 1) t = b;
        else {
          var l = i(t), k = w / l[2];
          t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k);
        }
        g.zoom(null, t);
      };
    });
  }
  function gesture(that, args, clean) {
    return !clean && that.__zooming || new Gesture(that, args);
  }
  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.sourceEvent = null;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }
  Gesture.prototype = {
    event: function(event2) {
      if (event2) this.sourceEvent = event2;
      return this;
    },
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key2, transform2) {
      if (this.mouse && key2 !== "mouse") this.mouse[1] = transform2.invert(this.mouse[0]);
      if (this.touch0 && key2 !== "touch") this.touch0[1] = transform2.invert(this.touch0[0]);
      if (this.touch1 && key2 !== "touch") this.touch1[1] = transform2.invert(this.touch1[0]);
      this.that.__zoom = transform2;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      var d = select_default2(this.that).datum();
      listeners.call(
        type,
        this.that,
        new ZoomEvent(type, {
          sourceEvent: this.sourceEvent,
          target: zoom2,
          type,
          transform: this.that.__zoom,
          dispatch: listeners
        }),
        d
      );
    }
  };
  function wheeled(event2, ...args) {
    if (!filter2.apply(this, arguments)) return;
    var g = gesture(this, args).event(event2), t = this.__zoom, k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta2.apply(this, arguments)))), p = pointer_default(event2);
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    } else if (t.k === k) return;
    else {
      g.mouse = [p, t.invert(p)];
      interrupt_default(this);
      g.start();
    }
    noevent_default2(event2);
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));
    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }
  function mousedowned(event2, ...args) {
    if (touchending || !filter2.apply(this, arguments)) return;
    var currentTarget = event2.currentTarget, g = gesture(this, args, true).event(event2), v = select_default2(event2.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p = pointer_default(event2, currentTarget), x0 = event2.clientX, y0 = event2.clientY;
    nodrag_default(event2.view);
    nopropagation2(event2);
    g.mouse = [p, this.__zoom.invert(p)];
    interrupt_default(this);
    g.start();
    function mousemoved(event3) {
      noevent_default2(event3);
      if (!g.moved) {
        var dx = event3.clientX - x0, dy = event3.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.event(event3).zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = pointer_default(event3, currentTarget), g.mouse[1]), g.extent, translateExtent));
    }
    function mouseupped(event3) {
      v.on("mousemove.zoom mouseup.zoom", null);
      yesdrag(event3.view, g.moved);
      noevent_default2(event3);
      g.event(event3).end();
    }
  }
  function dblclicked(event2, ...args) {
    if (!filter2.apply(this, arguments)) return;
    var t02 = this.__zoom, p0 = pointer_default(event2.changedTouches ? event2.changedTouches[0] : event2, this), p1 = t02.invert(p0), k1 = t02.k * (event2.shiftKey ? 0.5 : 2), t12 = constrain(translate(scale(t02, k1), p0, p1), extent.apply(this, args), translateExtent);
    noevent_default2(event2);
    if (duration > 0) select_default2(this).transition().duration(duration).call(schedule, t12, p0, event2);
    else select_default2(this).call(zoom2.transform, t12, p0, event2);
  }
  function touchstarted(event2, ...args) {
    if (!filter2.apply(this, arguments)) return;
    var touches = event2.touches, n = touches.length, g = gesture(this, args, event2.changedTouches.length === n).event(event2), started, i, t, p;
    nopropagation2(event2);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = pointer_default(t, this);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
    }
    if (touchstarting) touchstarting = clearTimeout(touchstarting);
    if (started) {
      if (g.taps < 2) touchfirst = p[0], touchstarting = setTimeout(function() {
        touchstarting = null;
      }, touchDelay);
      interrupt_default(this);
      g.start();
    }
  }
  function touchmoved(event2, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event2), touches = event2.changedTouches, n = touches.length, i, t, p, l;
    noevent_default2(event2);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = pointer_default(t, this);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1], p1 = g.touch1[0], l1 = g.touch1[1], dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    } else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
    else return;
    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }
  function touchended(event2, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event2), touches = event2.changedTouches, n = touches.length, i, t;
    nopropagation2(event2);
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      if (g.taps === 2) {
        t = pointer_default(t, this);
        if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
          var p = select_default2(this).on("dblclick.zoom");
          if (p) p.apply(this, arguments);
        }
      }
    }
  }
  zoom2.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta2 = typeof _ === "function" ? _ : constant_default4(+_), zoom2) : wheelDelta2;
  };
  zoom2.filter = function(_) {
    return arguments.length ? (filter2 = typeof _ === "function" ? _ : constant_default4(!!_), zoom2) : filter2;
  };
  zoom2.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant_default4(!!_), zoom2) : touchable;
  };
  zoom2.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant_default4([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom2) : extent;
  };
  zoom2.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom2) : [scaleExtent[0], scaleExtent[1]];
  };
  zoom2.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom2) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };
  zoom2.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom2) : constrain;
  };
  zoom2.duration = function(_) {
    return arguments.length ? (duration = +_, zoom2) : duration;
  };
  zoom2.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom2) : interpolate;
  };
  zoom2.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom2 : value;
  };
  zoom2.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom2) : Math.sqrt(clickDistance2);
  };
  zoom2.tapDistance = function(_) {
    return arguments.length ? (tapDistance = +_, zoom2) : tapDistance;
  };
  return zoom2;
}

// node_modules/@xyflow/system/dist/esm/index.js
var errorMessages = {
  error001: () => "[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001",
  error002: () => "It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.",
  error003: (nodeType) => `Node type "${nodeType}" not found. Using fallback type "default".`,
  error004: () => "The React Flow parent container needs a width and a height to render the graph.",
  error005: () => "Only child nodes can use a parent extent.",
  error006: () => "Can't create edge. An edge needs a source and a target.",
  error007: (id2) => `The old edge with id=${id2} does not exist.`,
  error009: (type) => `Marker type "${type}" doesn't exist.`,
  error008: (handleType, { id: id2, sourceHandle, targetHandle }) => `Couldn't create edge for ${handleType} handle id: "${handleType === "source" ? sourceHandle : targetHandle}", edge id: ${id2}.`,
  error010: () => "Handle: No node id found. Make sure to only use a Handle inside a custom Node.",
  error011: (edgeType) => `Edge type "${edgeType}" not found. Using fallback type "default".`,
  error012: (id2) => `Node with id "${id2}" does not exist, it may have been removed. This can happen when a node is deleted before the "onNodeClick" handler is called.`,
  error013: (lib = "react") => `It seems that you haven't loaded the styles. Please import '@xyflow/${lib}/dist/style.css' or base.css to make sure everything is working properly.`,
  error014: () => "useNodeConnections: No node ID found. Call useNodeConnections inside a custom Node or provide a node ID.",
  error015: () => "It seems that you are trying to drag a node that is not initialized. Please use onNodesChange as explained in the docs."
};
var infiniteExtent = [
  [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
  [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
];
var elementSelectionKeys = ["Enter", " ", "Escape"];
var defaultAriaLabelConfig = {
  "node.a11yDescription.default": "Press enter or space to select a node. Press delete to remove it and escape to cancel.",
  "node.a11yDescription.keyboardDisabled": "Press enter or space to select a node. You can then use the arrow keys to move the node around. Press delete to remove it and escape to cancel.",
  "node.a11yDescription.ariaLiveMessage": ({ direction, x, y }) => `Moved selected node ${direction}. New position, x: ${x}, y: ${y}`,
  "edge.a11yDescription.default": "Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.",
  // Control elements
  "controls.ariaLabel": "Control Panel",
  "controls.zoomIn.ariaLabel": "Zoom In",
  "controls.zoomOut.ariaLabel": "Zoom Out",
  "controls.fitView.ariaLabel": "Fit View",
  "controls.interactive.ariaLabel": "Toggle Interactivity",
  // Mini map
  "minimap.ariaLabel": "Mini Map",
  // Handle
  "handle.ariaLabel": "Handle"
};
var ConnectionMode;
(function(ConnectionMode2) {
  ConnectionMode2["Strict"] = "strict";
  ConnectionMode2["Loose"] = "loose";
})(ConnectionMode || (ConnectionMode = {}));
var PanOnScrollMode;
(function(PanOnScrollMode2) {
  PanOnScrollMode2["Free"] = "free";
  PanOnScrollMode2["Vertical"] = "vertical";
  PanOnScrollMode2["Horizontal"] = "horizontal";
})(PanOnScrollMode || (PanOnScrollMode = {}));
var SelectionMode;
(function(SelectionMode2) {
  SelectionMode2["Partial"] = "partial";
  SelectionMode2["Full"] = "full";
})(SelectionMode || (SelectionMode = {}));
var initialConnection = {
  inProgress: false,
  isValid: null,
  from: null,
  fromHandle: null,
  fromPosition: null,
  fromNode: null,
  to: null,
  toHandle: null,
  toPosition: null,
  toNode: null,
  pointer: null
};
var ConnectionLineType;
(function(ConnectionLineType2) {
  ConnectionLineType2["Bezier"] = "default";
  ConnectionLineType2["Straight"] = "straight";
  ConnectionLineType2["Step"] = "step";
  ConnectionLineType2["SmoothStep"] = "smoothstep";
  ConnectionLineType2["SimpleBezier"] = "simplebezier";
})(ConnectionLineType || (ConnectionLineType = {}));
var MarkerType;
(function(MarkerType2) {
  MarkerType2["Arrow"] = "arrow";
  MarkerType2["ArrowClosed"] = "arrowclosed";
})(MarkerType || (MarkerType = {}));
var Position;
(function(Position2) {
  Position2["Left"] = "left";
  Position2["Top"] = "top";
  Position2["Right"] = "right";
  Position2["Bottom"] = "bottom";
})(Position || (Position = {}));
var oppositePosition = {
  [Position.Left]: Position.Right,
  [Position.Right]: Position.Left,
  [Position.Top]: Position.Bottom,
  [Position.Bottom]: Position.Top
};
function areConnectionMapsEqual(a, b) {
  if (!a && !b) {
    return true;
  }
  if (!a || !b || a.size !== b.size) {
    return false;
  }
  if (!a.size && !b.size) {
    return true;
  }
  for (const key2 of a.keys()) {
    if (!b.has(key2)) {
      return false;
    }
  }
  return true;
}
function handleConnectionChange(a, b, cb) {
  if (!cb) {
    return;
  }
  const diff = [];
  a.forEach((connection, key2) => {
    if (!b?.has(key2)) {
      diff.push(connection);
    }
  });
  if (diff.length) {
    cb(diff);
  }
}
function getConnectionStatus(isValid) {
  return isValid === null ? null : isValid ? "valid" : "invalid";
}
var isEdgeBase = (element) => "id" in element && "source" in element && "target" in element;
var isNodeBase = (element) => "id" in element && "position" in element && !("source" in element) && !("target" in element);
var isInternalNodeBase = (element) => "id" in element && "internals" in element && !("source" in element) && !("target" in element);
var getOutgoers = (node, nodes, edges) => {
  if (!node.id) {
    return [];
  }
  const outgoerIds = /* @__PURE__ */ new Set();
  edges.forEach((edge) => {
    if (edge.source === node.id) {
      outgoerIds.add(edge.target);
    }
  });
  return nodes.filter((n) => outgoerIds.has(n.id));
};
var getIncomers = (node, nodes, edges) => {
  if (!node.id) {
    return [];
  }
  const incomersIds = /* @__PURE__ */ new Set();
  edges.forEach((edge) => {
    if (edge.target === node.id) {
      incomersIds.add(edge.source);
    }
  });
  return nodes.filter((n) => incomersIds.has(n.id));
};
var getNodePositionWithOrigin = (node, nodeOrigin = [0, 0]) => {
  const { width, height } = getNodeDimensions(node);
  const origin = node.origin ?? nodeOrigin;
  const offsetX = width * origin[0];
  const offsetY = height * origin[1];
  return {
    x: node.position.x - offsetX,
    y: node.position.y - offsetY
  };
};
var getNodesBounds = (nodes, params = { nodeOrigin: [0, 0] }) => {
  if (!params.nodeLookup) {
    console.warn("Please use `getNodesBounds` from `useReactFlow`/`useSvelteFlow` hook to ensure correct values for sub flows. If not possible, you have to provide a nodeLookup to support sub flows.");
  }
  if (nodes.length === 0) {
    return { x: 0, y: 0, width: 0, height: 0 };
  }
  const box = nodes.reduce((currBox, nodeOrId) => {
    const isId = typeof nodeOrId === "string";
    let currentNode = !params.nodeLookup && !isId ? nodeOrId : void 0;
    if (params.nodeLookup) {
      currentNode = isId ? params.nodeLookup.get(nodeOrId) : !isInternalNodeBase(nodeOrId) ? params.nodeLookup.get(nodeOrId.id) : nodeOrId;
    }
    const nodeBox = currentNode ? nodeToBox(currentNode, params.nodeOrigin) : { x: 0, y: 0, x2: 0, y2: 0 };
    return getBoundsOfBoxes(currBox, nodeBox);
  }, { x: Infinity, y: Infinity, x2: -Infinity, y2: -Infinity });
  return boxToRect(box);
};
var getInternalNodesBounds = (nodeLookup, params = {}) => {
  let box = { x: Infinity, y: Infinity, x2: -Infinity, y2: -Infinity };
  let hasVisibleNodes = false;
  nodeLookup.forEach((node) => {
    if (params.filter === void 0 || params.filter(node)) {
      box = getBoundsOfBoxes(box, nodeToBox(node));
      hasVisibleNodes = true;
    }
  });
  return hasVisibleNodes ? boxToRect(box) : { x: 0, y: 0, width: 0, height: 0 };
};
var getNodesInside = (nodes, rect, [tx, ty, tScale] = [0, 0, 1], partially = false, excludeNonSelectableNodes = false) => {
  const paneRect = {
    ...pointToRendererPoint(rect, [tx, ty, tScale]),
    width: rect.width / tScale,
    height: rect.height / tScale
  };
  const visibleNodes = [];
  for (const node of nodes.values()) {
    const { measured, selectable = true, hidden = false } = node;
    if (excludeNonSelectableNodes && !selectable || hidden) {
      continue;
    }
    const width = measured.width ?? node.width ?? node.initialWidth ?? null;
    const height = measured.height ?? node.height ?? node.initialHeight ?? null;
    const overlappingArea = getOverlappingArea(paneRect, nodeToRect(node));
    const area = (width ?? 0) * (height ?? 0);
    const partiallyVisible = partially && overlappingArea > 0;
    const forceInitialRender = !node.internals.handleBounds;
    const isVisible = forceInitialRender || partiallyVisible || overlappingArea >= area;
    if (isVisible || node.dragging) {
      visibleNodes.push(node);
    }
  }
  return visibleNodes;
};
var getConnectedEdges = (nodes, edges) => {
  const nodeIds = /* @__PURE__ */ new Set();
  nodes.forEach((node) => {
    nodeIds.add(node.id);
  });
  return edges.filter((edge) => nodeIds.has(edge.source) || nodeIds.has(edge.target));
};
function getFitViewNodes(nodeLookup, options) {
  const fitViewNodes = /* @__PURE__ */ new Map();
  const optionNodeIds = options?.nodes ? new Set(options.nodes.map((node) => node.id)) : null;
  nodeLookup.forEach((n) => {
    const isVisible = n.measured.width && n.measured.height && (options?.includeHiddenNodes || !n.hidden);
    if (isVisible && (!optionNodeIds || optionNodeIds.has(n.id))) {
      fitViewNodes.set(n.id, n);
    }
  });
  return fitViewNodes;
}
async function fitViewport({ nodes, width, height, panZoom, minZoom, maxZoom }, options) {
  if (nodes.size === 0) {
    return Promise.resolve(true);
  }
  const nodesToFit = getFitViewNodes(nodes, options);
  const bounds = getInternalNodesBounds(nodesToFit);
  const viewport = getViewportForBounds(bounds, width, height, options?.minZoom ?? minZoom, options?.maxZoom ?? maxZoom, options?.padding ?? 0.1);
  await panZoom.setViewport(viewport, {
    duration: options?.duration,
    ease: options?.ease,
    interpolate: options?.interpolate
  });
  return Promise.resolve(true);
}
function calculateNodePosition({ nodeId, nextPosition, nodeLookup, nodeOrigin = [0, 0], nodeExtent, onError }) {
  const node = nodeLookup.get(nodeId);
  const parentNode = node.parentId ? nodeLookup.get(node.parentId) : void 0;
  const { x: parentX, y: parentY } = parentNode ? parentNode.internals.positionAbsolute : { x: 0, y: 0 };
  const origin = node.origin ?? nodeOrigin;
  let extent = node.extent || nodeExtent;
  if (node.extent === "parent" && !node.expandParent) {
    if (!parentNode) {
      onError?.("005", errorMessages["error005"]());
    } else {
      const parentWidth = parentNode.measured.width;
      const parentHeight = parentNode.measured.height;
      if (parentWidth && parentHeight) {
        extent = [
          [parentX, parentY],
          [parentX + parentWidth, parentY + parentHeight]
        ];
      }
    }
  } else if (parentNode && isCoordinateExtent(node.extent)) {
    extent = [
      [node.extent[0][0] + parentX, node.extent[0][1] + parentY],
      [node.extent[1][0] + parentX, node.extent[1][1] + parentY]
    ];
  }
  const positionAbsolute = isCoordinateExtent(extent) ? clampPosition(nextPosition, extent, node.measured) : nextPosition;
  if (node.measured.width === void 0 || node.measured.height === void 0) {
    onError?.("015", errorMessages["error015"]());
  }
  return {
    position: {
      x: positionAbsolute.x - parentX + (node.measured.width ?? 0) * origin[0],
      y: positionAbsolute.y - parentY + (node.measured.height ?? 0) * origin[1]
    },
    positionAbsolute
  };
}
async function getElementsToRemove({ nodesToRemove = [], edgesToRemove = [], nodes, edges, onBeforeDelete }) {
  const nodeIds = new Set(nodesToRemove.map((node) => node.id));
  const matchingNodes = [];
  for (const node of nodes) {
    if (node.deletable === false) {
      continue;
    }
    const isIncluded = nodeIds.has(node.id);
    const parentHit = !isIncluded && node.parentId && matchingNodes.find((n) => n.id === node.parentId);
    if (isIncluded || parentHit) {
      matchingNodes.push(node);
    }
  }
  const edgeIds = new Set(edgesToRemove.map((edge) => edge.id));
  const deletableEdges = edges.filter((edge) => edge.deletable !== false);
  const connectedEdges = getConnectedEdges(matchingNodes, deletableEdges);
  const matchingEdges = connectedEdges;
  for (const edge of deletableEdges) {
    const isIncluded = edgeIds.has(edge.id);
    if (isIncluded && !matchingEdges.find((e) => e.id === edge.id)) {
      matchingEdges.push(edge);
    }
  }
  if (!onBeforeDelete) {
    return {
      edges: matchingEdges,
      nodes: matchingNodes
    };
  }
  const onBeforeDeleteResult = await onBeforeDelete({
    nodes: matchingNodes,
    edges: matchingEdges
  });
  if (typeof onBeforeDeleteResult === "boolean") {
    return onBeforeDeleteResult ? { edges: matchingEdges, nodes: matchingNodes } : { edges: [], nodes: [] };
  }
  return onBeforeDeleteResult;
}
var clamp = (val, min = 0, max = 1) => Math.min(Math.max(val, min), max);
var clampPosition = (position = { x: 0, y: 0 }, extent, dimensions) => ({
  x: clamp(position.x, extent[0][0], extent[1][0] - (dimensions?.width ?? 0)),
  y: clamp(position.y, extent[0][1], extent[1][1] - (dimensions?.height ?? 0))
});
function clampPositionToParent(childPosition, childDimensions, parent) {
  const { width: parentWidth, height: parentHeight } = getNodeDimensions(parent);
  const { x: parentX, y: parentY } = parent.internals.positionAbsolute;
  return clampPosition(childPosition, [
    [parentX, parentY],
    [parentX + parentWidth, parentY + parentHeight]
  ], childDimensions);
}
var calcAutoPanVelocity = (value, min, max) => {
  if (value < min) {
    return clamp(Math.abs(value - min), 1, min) / min;
  } else if (value > max) {
    return -clamp(Math.abs(value - max), 1, min) / min;
  }
  return 0;
};
var calcAutoPan = (pos, bounds, speed = 15, distance2 = 40) => {
  const xMovement = calcAutoPanVelocity(pos.x, distance2, bounds.width - distance2) * speed;
  const yMovement = calcAutoPanVelocity(pos.y, distance2, bounds.height - distance2) * speed;
  return [xMovement, yMovement];
};
var getBoundsOfBoxes = (box1, box2) => ({
  x: Math.min(box1.x, box2.x),
  y: Math.min(box1.y, box2.y),
  x2: Math.max(box1.x2, box2.x2),
  y2: Math.max(box1.y2, box2.y2)
});
var rectToBox = ({ x, y, width, height }) => ({
  x,
  y,
  x2: x + width,
  y2: y + height
});
var boxToRect = ({ x, y, x2, y2 }) => ({
  x,
  y,
  width: x2 - x,
  height: y2 - y
});
var nodeToRect = (node, nodeOrigin = [0, 0]) => {
  const { x, y } = isInternalNodeBase(node) ? node.internals.positionAbsolute : getNodePositionWithOrigin(node, nodeOrigin);
  return {
    x,
    y,
    width: node.measured?.width ?? node.width ?? node.initialWidth ?? 0,
    height: node.measured?.height ?? node.height ?? node.initialHeight ?? 0
  };
};
var nodeToBox = (node, nodeOrigin = [0, 0]) => {
  const { x, y } = isInternalNodeBase(node) ? node.internals.positionAbsolute : getNodePositionWithOrigin(node, nodeOrigin);
  return {
    x,
    y,
    x2: x + (node.measured?.width ?? node.width ?? node.initialWidth ?? 0),
    y2: y + (node.measured?.height ?? node.height ?? node.initialHeight ?? 0)
  };
};
var getBoundsOfRects = (rect1, rect2) => boxToRect(getBoundsOfBoxes(rectToBox(rect1), rectToBox(rect2)));
var getOverlappingArea = (rectA, rectB) => {
  const xOverlap = Math.max(0, Math.min(rectA.x + rectA.width, rectB.x + rectB.width) - Math.max(rectA.x, rectB.x));
  const yOverlap = Math.max(0, Math.min(rectA.y + rectA.height, rectB.y + rectB.height) - Math.max(rectA.y, rectB.y));
  return Math.ceil(xOverlap * yOverlap);
};
var isRectObject = (obj) => isNumeric(obj.width) && isNumeric(obj.height) && isNumeric(obj.x) && isNumeric(obj.y);
var isNumeric = (n) => !isNaN(n) && isFinite(n);
var devWarn = (id2, message) => {
  if (true) {
    console.warn(`[React Flow]: ${message} Help: https://reactflow.dev/error#${id2}`);
  }
};
var snapPosition = (position, snapGrid = [1, 1]) => {
  return {
    x: snapGrid[0] * Math.round(position.x / snapGrid[0]),
    y: snapGrid[1] * Math.round(position.y / snapGrid[1])
  };
};
var pointToRendererPoint = ({ x, y }, [tx, ty, tScale], snapToGrid = false, snapGrid = [1, 1]) => {
  const position = {
    x: (x - tx) / tScale,
    y: (y - ty) / tScale
  };
  return snapToGrid ? snapPosition(position, snapGrid) : position;
};
var rendererPointToPoint = ({ x, y }, [tx, ty, tScale]) => {
  return {
    x: x * tScale + tx,
    y: y * tScale + ty
  };
};
function parsePadding(padding, viewport) {
  if (typeof padding === "number") {
    return Math.floor((viewport - viewport / (1 + padding)) * 0.5);
  }
  if (typeof padding === "string" && padding.endsWith("px")) {
    const paddingValue = parseFloat(padding);
    if (!Number.isNaN(paddingValue)) {
      return Math.floor(paddingValue);
    }
  }
  if (typeof padding === "string" && padding.endsWith("%")) {
    const paddingValue = parseFloat(padding);
    if (!Number.isNaN(paddingValue)) {
      return Math.floor(viewport * paddingValue * 0.01);
    }
  }
  console.error(`[React Flow] The padding value "${padding}" is invalid. Please provide a number or a string with a valid unit (px or %).`);
  return 0;
}
function parsePaddings(padding, width, height) {
  if (typeof padding === "string" || typeof padding === "number") {
    const paddingY = parsePadding(padding, height);
    const paddingX = parsePadding(padding, width);
    return {
      top: paddingY,
      right: paddingX,
      bottom: paddingY,
      left: paddingX,
      x: paddingX * 2,
      y: paddingY * 2
    };
  }
  if (typeof padding === "object") {
    const top = parsePadding(padding.top ?? padding.y ?? 0, height);
    const bottom = parsePadding(padding.bottom ?? padding.y ?? 0, height);
    const left = parsePadding(padding.left ?? padding.x ?? 0, width);
    const right = parsePadding(padding.right ?? padding.x ?? 0, width);
    return { top, right, bottom, left, x: left + right, y: top + bottom };
  }
  return { top: 0, right: 0, bottom: 0, left: 0, x: 0, y: 0 };
}
function calculateAppliedPaddings(bounds, x, y, zoom2, width, height) {
  const { x: left, y: top } = rendererPointToPoint(bounds, [x, y, zoom2]);
  const { x: boundRight, y: boundBottom } = rendererPointToPoint({ x: bounds.x + bounds.width, y: bounds.y + bounds.height }, [x, y, zoom2]);
  const right = width - boundRight;
  const bottom = height - boundBottom;
  return {
    left: Math.floor(left),
    top: Math.floor(top),
    right: Math.floor(right),
    bottom: Math.floor(bottom)
  };
}
var getViewportForBounds = (bounds, width, height, minZoom, maxZoom, padding) => {
  const p = parsePaddings(padding, width, height);
  const xZoom = (width - p.x) / bounds.width;
  const yZoom = (height - p.y) / bounds.height;
  const zoom2 = Math.min(xZoom, yZoom);
  const clampedZoom = clamp(zoom2, minZoom, maxZoom);
  const boundsCenterX = bounds.x + bounds.width / 2;
  const boundsCenterY = bounds.y + bounds.height / 2;
  const x = width / 2 - boundsCenterX * clampedZoom;
  const y = height / 2 - boundsCenterY * clampedZoom;
  const newPadding = calculateAppliedPaddings(bounds, x, y, clampedZoom, width, height);
  const offset = {
    left: Math.min(newPadding.left - p.left, 0),
    top: Math.min(newPadding.top - p.top, 0),
    right: Math.min(newPadding.right - p.right, 0),
    bottom: Math.min(newPadding.bottom - p.bottom, 0)
  };
  return {
    x: x - offset.left + offset.right,
    y: y - offset.top + offset.bottom,
    zoom: clampedZoom
  };
};
var isMacOs = () => typeof navigator !== "undefined" && navigator?.userAgent?.indexOf("Mac") >= 0;
function isCoordinateExtent(extent) {
  return extent !== void 0 && extent !== null && extent !== "parent";
}
function getNodeDimensions(node) {
  return {
    width: node.measured?.width ?? node.width ?? node.initialWidth ?? 0,
    height: node.measured?.height ?? node.height ?? node.initialHeight ?? 0
  };
}
function nodeHasDimensions(node) {
  return (node.measured?.width ?? node.width ?? node.initialWidth) !== void 0 && (node.measured?.height ?? node.height ?? node.initialHeight) !== void 0;
}
function evaluateAbsolutePosition(position, dimensions = { width: 0, height: 0 }, parentId, nodeLookup, nodeOrigin) {
  const positionAbsolute = { ...position };
  const parent = nodeLookup.get(parentId);
  if (parent) {
    const origin = parent.origin || nodeOrigin;
    positionAbsolute.x += parent.internals.positionAbsolute.x - (dimensions.width ?? 0) * origin[0];
    positionAbsolute.y += parent.internals.positionAbsolute.y - (dimensions.height ?? 0) * origin[1];
  }
  return positionAbsolute;
}
function mergeAriaLabelConfig(partial) {
  return { ...defaultAriaLabelConfig, ...partial || {} };
}
function getPointerPosition(event2, { snapGrid = [0, 0], snapToGrid = false, transform: transform2, containerBounds }) {
  const { x, y } = getEventPosition(event2);
  const pointerPos = pointToRendererPoint({ x: x - (containerBounds?.left ?? 0), y: y - (containerBounds?.top ?? 0) }, transform2);
  const { x: xSnapped, y: ySnapped } = snapToGrid ? snapPosition(pointerPos, snapGrid) : pointerPos;
  return {
    xSnapped,
    ySnapped,
    ...pointerPos
  };
}
var getDimensions = (node) => ({
  width: node.offsetWidth,
  height: node.offsetHeight
});
var getHostForElement = (element) => element?.getRootNode?.() || window?.document;
var inputTags = ["INPUT", "SELECT", "TEXTAREA"];
function isInputDOMNode(event2) {
  const target = event2.composedPath?.()?.[0] || event2.target;
  if (target?.nodeType !== 1)
    return false;
  const isInput = inputTags.includes(target.nodeName) || target.hasAttribute("contenteditable");
  return isInput || !!target.closest(".nokey");
}
var isMouseEvent = (event2) => "clientX" in event2;
var getEventPosition = (event2, bounds) => {
  const isMouse = isMouseEvent(event2);
  const evtX = isMouse ? event2.clientX : event2.touches?.[0].clientX;
  const evtY = isMouse ? event2.clientY : event2.touches?.[0].clientY;
  return {
    x: evtX - (bounds?.left ?? 0),
    y: evtY - (bounds?.top ?? 0)
  };
};
var getHandleBounds = (type, nodeElement, nodeBounds, zoom2, nodeId) => {
  const handles = nodeElement.querySelectorAll(`.${type}`);
  if (!handles || !handles.length) {
    return null;
  }
  return Array.from(handles).map((handle) => {
    const handleBounds = handle.getBoundingClientRect();
    return {
      id: handle.getAttribute("data-handleid"),
      type,
      nodeId,
      position: handle.getAttribute("data-handlepos"),
      x: (handleBounds.left - nodeBounds.left) / zoom2,
      y: (handleBounds.top - nodeBounds.top) / zoom2,
      ...getDimensions(handle)
    };
  });
};
function getBezierEdgeCenter({ sourceX, sourceY, targetX, targetY, sourceControlX, sourceControlY, targetControlX, targetControlY }) {
  const centerX = sourceX * 0.125 + sourceControlX * 0.375 + targetControlX * 0.375 + targetX * 0.125;
  const centerY = sourceY * 0.125 + sourceControlY * 0.375 + targetControlY * 0.375 + targetY * 0.125;
  const offsetX = Math.abs(centerX - sourceX);
  const offsetY = Math.abs(centerY - sourceY);
  return [centerX, centerY, offsetX, offsetY];
}
function calculateControlOffset(distance2, curvature) {
  if (distance2 >= 0) {
    return 0.5 * distance2;
  }
  return curvature * 25 * Math.sqrt(-distance2);
}
function getControlWithCurvature({ pos, x1, y1, x2, y2, c }) {
  switch (pos) {
    case Position.Left:
      return [x1 - calculateControlOffset(x1 - x2, c), y1];
    case Position.Right:
      return [x1 + calculateControlOffset(x2 - x1, c), y1];
    case Position.Top:
      return [x1, y1 - calculateControlOffset(y1 - y2, c)];
    case Position.Bottom:
      return [x1, y1 + calculateControlOffset(y2 - y1, c)];
  }
}
function getBezierPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, curvature = 0.25 }) {
  const [sourceControlX, sourceControlY] = getControlWithCurvature({
    pos: sourcePosition,
    x1: sourceX,
    y1: sourceY,
    x2: targetX,
    y2: targetY,
    c: curvature
  });
  const [targetControlX, targetControlY] = getControlWithCurvature({
    pos: targetPosition,
    x1: targetX,
    y1: targetY,
    x2: sourceX,
    y2: sourceY,
    c: curvature
  });
  const [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({
    sourceX,
    sourceY,
    targetX,
    targetY,
    sourceControlX,
    sourceControlY,
    targetControlX,
    targetControlY
  });
  return [
    `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,
    labelX,
    labelY,
    offsetX,
    offsetY
  ];
}
function getEdgeCenter({ sourceX, sourceY, targetX, targetY }) {
  const xOffset = Math.abs(targetX - sourceX) / 2;
  const centerX = targetX < sourceX ? targetX + xOffset : targetX - xOffset;
  const yOffset = Math.abs(targetY - sourceY) / 2;
  const centerY = targetY < sourceY ? targetY + yOffset : targetY - yOffset;
  return [centerX, centerY, xOffset, yOffset];
}
function getElevatedEdgeZIndex({ sourceNode, targetNode, selected = false, zIndex, elevateOnSelect = false }) {
  if (zIndex !== void 0) {
    return zIndex;
  }
  const edgeZ = elevateOnSelect && selected ? 1e3 : 0;
  const nodeZ = Math.max(sourceNode.parentId || elevateOnSelect && sourceNode.selected ? sourceNode.internals.z : 0, targetNode.parentId || elevateOnSelect && targetNode.selected ? targetNode.internals.z : 0);
  return edgeZ + nodeZ;
}
function isEdgeVisible({ sourceNode, targetNode, width, height, transform: transform2 }) {
  const edgeBox = getBoundsOfBoxes(nodeToBox(sourceNode), nodeToBox(targetNode));
  if (edgeBox.x === edgeBox.x2) {
    edgeBox.x2 += 1;
  }
  if (edgeBox.y === edgeBox.y2) {
    edgeBox.y2 += 1;
  }
  const viewRect = {
    x: -transform2[0] / transform2[2],
    y: -transform2[1] / transform2[2],
    width: width / transform2[2],
    height: height / transform2[2]
  };
  return getOverlappingArea(viewRect, boxToRect(edgeBox)) > 0;
}
var getEdgeId = ({ source, sourceHandle, target, targetHandle }) => `xy-edge__${source}${sourceHandle || ""}-${target}${targetHandle || ""}`;
var connectionExists = (edge, edges) => {
  return edges.some((el) => el.source === edge.source && el.target === edge.target && (el.sourceHandle === edge.sourceHandle || !el.sourceHandle && !edge.sourceHandle) && (el.targetHandle === edge.targetHandle || !el.targetHandle && !edge.targetHandle));
};
var addEdge = (edgeParams, edges) => {
  if (!edgeParams.source || !edgeParams.target) {
    devWarn("006", errorMessages["error006"]());
    return edges;
  }
  let edge;
  if (isEdgeBase(edgeParams)) {
    edge = { ...edgeParams };
  } else {
    edge = {
      ...edgeParams,
      id: getEdgeId(edgeParams)
    };
  }
  if (connectionExists(edge, edges)) {
    return edges;
  }
  if (edge.sourceHandle === null) {
    delete edge.sourceHandle;
  }
  if (edge.targetHandle === null) {
    delete edge.targetHandle;
  }
  return edges.concat(edge);
};
function getStraightPath({ sourceX, sourceY, targetX, targetY }) {
  const [labelX, labelY, offsetX, offsetY] = getEdgeCenter({
    sourceX,
    sourceY,
    targetX,
    targetY
  });
  return [`M ${sourceX},${sourceY}L ${targetX},${targetY}`, labelX, labelY, offsetX, offsetY];
}
var handleDirections = {
  [Position.Left]: { x: -1, y: 0 },
  [Position.Right]: { x: 1, y: 0 },
  [Position.Top]: { x: 0, y: -1 },
  [Position.Bottom]: { x: 0, y: 1 }
};
var getDirection = ({ source, sourcePosition = Position.Bottom, target }) => {
  if (sourcePosition === Position.Left || sourcePosition === Position.Right) {
    return source.x < target.x ? { x: 1, y: 0 } : { x: -1, y: 0 };
  }
  return source.y < target.y ? { x: 0, y: 1 } : { x: 0, y: -1 };
};
var distance = (a, b) => Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));
function getPoints({ source, sourcePosition = Position.Bottom, target, targetPosition = Position.Top, center, offset, stepPosition }) {
  const sourceDir = handleDirections[sourcePosition];
  const targetDir = handleDirections[targetPosition];
  const sourceGapped = { x: source.x + sourceDir.x * offset, y: source.y + sourceDir.y * offset };
  const targetGapped = { x: target.x + targetDir.x * offset, y: target.y + targetDir.y * offset };
  const dir = getDirection({
    source: sourceGapped,
    sourcePosition,
    target: targetGapped
  });
  const dirAccessor = dir.x !== 0 ? "x" : "y";
  const currDir = dir[dirAccessor];
  let points = [];
  let centerX, centerY;
  const sourceGapOffset = { x: 0, y: 0 };
  const targetGapOffset = { x: 0, y: 0 };
  const [, , defaultOffsetX, defaultOffsetY] = getEdgeCenter({
    sourceX: source.x,
    sourceY: source.y,
    targetX: target.x,
    targetY: target.y
  });
  if (sourceDir[dirAccessor] * targetDir[dirAccessor] === -1) {
    if (dirAccessor === "x") {
      centerX = center.x ?? sourceGapped.x + (targetGapped.x - sourceGapped.x) * stepPosition;
      centerY = center.y ?? (sourceGapped.y + targetGapped.y) / 2;
    } else {
      centerX = center.x ?? (sourceGapped.x + targetGapped.x) / 2;
      centerY = center.y ?? sourceGapped.y + (targetGapped.y - sourceGapped.y) * stepPosition;
    }
    const verticalSplit = [
      { x: centerX, y: sourceGapped.y },
      { x: centerX, y: targetGapped.y }
    ];
    const horizontalSplit = [
      { x: sourceGapped.x, y: centerY },
      { x: targetGapped.x, y: centerY }
    ];
    if (sourceDir[dirAccessor] === currDir) {
      points = dirAccessor === "x" ? verticalSplit : horizontalSplit;
    } else {
      points = dirAccessor === "x" ? horizontalSplit : verticalSplit;
    }
  } else {
    const sourceTarget = [{ x: sourceGapped.x, y: targetGapped.y }];
    const targetSource = [{ x: targetGapped.x, y: sourceGapped.y }];
    if (dirAccessor === "x") {
      points = sourceDir.x === currDir ? targetSource : sourceTarget;
    } else {
      points = sourceDir.y === currDir ? sourceTarget : targetSource;
    }
    if (sourcePosition === targetPosition) {
      const diff = Math.abs(source[dirAccessor] - target[dirAccessor]);
      if (diff <= offset) {
        const gapOffset = Math.min(offset - 1, offset - diff);
        if (sourceDir[dirAccessor] === currDir) {
          sourceGapOffset[dirAccessor] = (sourceGapped[dirAccessor] > source[dirAccessor] ? -1 : 1) * gapOffset;
        } else {
          targetGapOffset[dirAccessor] = (targetGapped[dirAccessor] > target[dirAccessor] ? -1 : 1) * gapOffset;
        }
      }
    }
    if (sourcePosition !== targetPosition) {
      const dirAccessorOpposite = dirAccessor === "x" ? "y" : "x";
      const isSameDir = sourceDir[dirAccessor] === targetDir[dirAccessorOpposite];
      const sourceGtTargetOppo = sourceGapped[dirAccessorOpposite] > targetGapped[dirAccessorOpposite];
      const sourceLtTargetOppo = sourceGapped[dirAccessorOpposite] < targetGapped[dirAccessorOpposite];
      const flipSourceTarget = sourceDir[dirAccessor] === 1 && (!isSameDir && sourceGtTargetOppo || isSameDir && sourceLtTargetOppo) || sourceDir[dirAccessor] !== 1 && (!isSameDir && sourceLtTargetOppo || isSameDir && sourceGtTargetOppo);
      if (flipSourceTarget) {
        points = dirAccessor === "x" ? sourceTarget : targetSource;
      }
    }
    const sourceGapPoint = { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y };
    const targetGapPoint = { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y };
    const maxXDistance = Math.max(Math.abs(sourceGapPoint.x - points[0].x), Math.abs(targetGapPoint.x - points[0].x));
    const maxYDistance = Math.max(Math.abs(sourceGapPoint.y - points[0].y), Math.abs(targetGapPoint.y - points[0].y));
    if (maxXDistance >= maxYDistance) {
      centerX = (sourceGapPoint.x + targetGapPoint.x) / 2;
      centerY = points[0].y;
    } else {
      centerX = points[0].x;
      centerY = (sourceGapPoint.y + targetGapPoint.y) / 2;
    }
  }
  const pathPoints = [
    source,
    { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y },
    ...points,
    { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y },
    target
  ];
  return [pathPoints, centerX, centerY, defaultOffsetX, defaultOffsetY];
}
function getBend(a, b, c, size) {
  const bendSize = Math.min(distance(a, b) / 2, distance(b, c) / 2, size);
  const { x, y } = b;
  if (a.x === x && x === c.x || a.y === y && y === c.y) {
    return `L${x} ${y}`;
  }
  if (a.y === y) {
    const xDir2 = a.x < c.x ? -1 : 1;
    const yDir2 = a.y < c.y ? 1 : -1;
    return `L ${x + bendSize * xDir2},${y}Q ${x},${y} ${x},${y + bendSize * yDir2}`;
  }
  const xDir = a.x < c.x ? 1 : -1;
  const yDir = a.y < c.y ? -1 : 1;
  return `L ${x},${y + bendSize * yDir}Q ${x},${y} ${x + bendSize * xDir},${y}`;
}
function getSmoothStepPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, borderRadius = 5, centerX, centerY, offset = 20, stepPosition = 0.5 }) {
  const [points, labelX, labelY, offsetX, offsetY] = getPoints({
    source: { x: sourceX, y: sourceY },
    sourcePosition,
    target: { x: targetX, y: targetY },
    targetPosition,
    center: { x: centerX, y: centerY },
    offset,
    stepPosition
  });
  const path = points.reduce((res, p, i) => {
    let segment = "";
    if (i > 0 && i < points.length - 1) {
      segment = getBend(points[i - 1], p, points[i + 1], borderRadius);
    } else {
      segment = `${i === 0 ? "M" : "L"}${p.x} ${p.y}`;
    }
    res += segment;
    return res;
  }, "");
  return [path, labelX, labelY, offsetX, offsetY];
}
function isNodeInitialized(node) {
  return node && !!(node.internals.handleBounds || node.handles?.length) && !!(node.measured.width || node.width || node.initialWidth);
}
function getEdgePosition(params) {
  const { sourceNode, targetNode } = params;
  if (!isNodeInitialized(sourceNode) || !isNodeInitialized(targetNode)) {
    return null;
  }
  const sourceHandleBounds = sourceNode.internals.handleBounds || toHandleBounds(sourceNode.handles);
  const targetHandleBounds = targetNode.internals.handleBounds || toHandleBounds(targetNode.handles);
  const sourceHandle = getHandle$1(sourceHandleBounds?.source ?? [], params.sourceHandle);
  const targetHandle = getHandle$1(
    // when connection type is loose we can define all handles as sources and connect source -> source
    params.connectionMode === ConnectionMode.Strict ? targetHandleBounds?.target ?? [] : (targetHandleBounds?.target ?? []).concat(targetHandleBounds?.source ?? []),
    params.targetHandle
  );
  if (!sourceHandle || !targetHandle) {
    params.onError?.("008", errorMessages["error008"](!sourceHandle ? "source" : "target", {
      id: params.id,
      sourceHandle: params.sourceHandle,
      targetHandle: params.targetHandle
    }));
    return null;
  }
  const sourcePosition = sourceHandle?.position || Position.Bottom;
  const targetPosition = targetHandle?.position || Position.Top;
  const source = getHandlePosition(sourceNode, sourceHandle, sourcePosition);
  const target = getHandlePosition(targetNode, targetHandle, targetPosition);
  return {
    sourceX: source.x,
    sourceY: source.y,
    targetX: target.x,
    targetY: target.y,
    sourcePosition,
    targetPosition
  };
}
function toHandleBounds(handles) {
  if (!handles) {
    return null;
  }
  const source = [];
  const target = [];
  for (const handle of handles) {
    handle.width = handle.width ?? 1;
    handle.height = handle.height ?? 1;
    if (handle.type === "source") {
      source.push(handle);
    } else if (handle.type === "target") {
      target.push(handle);
    }
  }
  return {
    source,
    target
  };
}
function getHandlePosition(node, handle, fallbackPosition = Position.Left, center = false) {
  const x = (handle?.x ?? 0) + node.internals.positionAbsolute.x;
  const y = (handle?.y ?? 0) + node.internals.positionAbsolute.y;
  const { width, height } = handle ?? getNodeDimensions(node);
  if (center) {
    return { x: x + width / 2, y: y + height / 2 };
  }
  const position = handle?.position ?? fallbackPosition;
  switch (position) {
    case Position.Top:
      return { x: x + width / 2, y };
    case Position.Right:
      return { x: x + width, y: y + height / 2 };
    case Position.Bottom:
      return { x: x + width / 2, y: y + height };
    case Position.Left:
      return { x, y: y + height / 2 };
  }
}
function getHandle$1(bounds, handleId) {
  if (!bounds) {
    return null;
  }
  return (!handleId ? bounds[0] : bounds.find((d) => d.id === handleId)) || null;
}
function getMarkerId(marker, id2) {
  if (!marker) {
    return "";
  }
  if (typeof marker === "string") {
    return marker;
  }
  const idPrefix = id2 ? `${id2}__` : "";
  return `${idPrefix}${Object.keys(marker).sort().map((key2) => `${key2}=${marker[key2]}`).join("&")}`;
}
function createMarkerIds(edges, { id: id2, defaultColor, defaultMarkerStart, defaultMarkerEnd }) {
  const ids = /* @__PURE__ */ new Set();
  return edges.reduce((markers, edge) => {
    [edge.markerStart || defaultMarkerStart, edge.markerEnd || defaultMarkerEnd].forEach((marker) => {
      if (marker && typeof marker === "object") {
        const markerId = getMarkerId(marker, id2);
        if (!ids.has(markerId)) {
          markers.push({ id: markerId, color: marker.color || defaultColor, ...marker });
          ids.add(markerId);
        }
      }
    });
    return markers;
  }, []).sort((a, b) => a.id.localeCompare(b.id));
}
function getNodeToolbarTransform(nodeRect, viewport, position, offset, align) {
  let alignmentOffset = 0.5;
  if (align === "start") {
    alignmentOffset = 0;
  } else if (align === "end") {
    alignmentOffset = 1;
  }
  let pos = [
    (nodeRect.x + nodeRect.width * alignmentOffset) * viewport.zoom + viewport.x,
    nodeRect.y * viewport.zoom + viewport.y - offset
  ];
  let shift = [-100 * alignmentOffset, -100];
  switch (position) {
    case Position.Right:
      pos = [
        (nodeRect.x + nodeRect.width) * viewport.zoom + viewport.x + offset,
        (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y
      ];
      shift = [0, -100 * alignmentOffset];
      break;
    case Position.Bottom:
      pos[1] = (nodeRect.y + nodeRect.height) * viewport.zoom + viewport.y + offset;
      shift[1] = 0;
      break;
    case Position.Left:
      pos = [
        nodeRect.x * viewport.zoom + viewport.x - offset,
        (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y
      ];
      shift = [-100, -100 * alignmentOffset];
      break;
  }
  return `translate(${pos[0]}px, ${pos[1]}px) translate(${shift[0]}%, ${shift[1]}%)`;
}
var alignXToPercent = {
  left: 0,
  center: 50,
  right: 100
};
var alignYToPercent = {
  top: 0,
  center: 50,
  bottom: 100
};
function getEdgeToolbarTransform(x, y, zoom2, alignX = "center", alignY = "center") {
  return `translate(${x}px, ${y}px) scale(${1 / zoom2}) translate(${-(alignXToPercent[alignX] ?? 50)}%, ${-(alignYToPercent[alignY] ?? 50)}%)`;
}
var SELECTED_NODE_Z = 1e3;
var ROOT_PARENT_Z_INCREMENT = 10;
var defaultOptions = {
  nodeOrigin: [0, 0],
  nodeExtent: infiniteExtent,
  elevateNodesOnSelect: true,
  defaults: {}
};
var adoptUserNodesDefaultOptions = {
  ...defaultOptions,
  checkEquality: true
};
function mergeObjects(base, incoming) {
  const result = { ...base };
  for (const key2 in incoming) {
    if (incoming[key2] !== void 0) {
      result[key2] = incoming[key2];
    }
  }
  return result;
}
function updateAbsolutePositions(nodeLookup, parentLookup, options) {
  const _options = mergeObjects(defaultOptions, options);
  for (const node of nodeLookup.values()) {
    if (node.parentId) {
      updateChildNode(node, nodeLookup, parentLookup, _options);
    } else {
      const positionWithOrigin = getNodePositionWithOrigin(node, _options.nodeOrigin);
      const extent = isCoordinateExtent(node.extent) ? node.extent : _options.nodeExtent;
      const clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(node));
      node.internals.positionAbsolute = clampedPosition;
    }
  }
}
function parseHandles(userNode, internalNode) {
  if (!userNode.handles) {
    return !userNode.measured ? void 0 : internalNode?.internals.handleBounds;
  }
  const source = [];
  const target = [];
  for (const handle of userNode.handles) {
    const handleBounds = {
      id: handle.id,
      width: handle.width ?? 1,
      height: handle.height ?? 1,
      nodeId: userNode.id,
      x: handle.x,
      y: handle.y,
      position: handle.position,
      type: handle.type
    };
    if (handle.type === "source") {
      source.push(handleBounds);
    } else if (handle.type === "target") {
      target.push(handleBounds);
    }
  }
  return {
    source,
    target
  };
}
function adoptUserNodes(nodes, nodeLookup, parentLookup, options) {
  const _options = mergeObjects(adoptUserNodesDefaultOptions, options);
  let rootParentIndex = { i: -1 };
  let nodesInitialized = nodes.length > 0;
  const tmpLookup = new Map(nodeLookup);
  const selectedNodeZ = _options?.elevateNodesOnSelect ? SELECTED_NODE_Z : 0;
  nodeLookup.clear();
  parentLookup.clear();
  for (const userNode of nodes) {
    let internalNode = tmpLookup.get(userNode.id);
    if (_options.checkEquality && userNode === internalNode?.internals.userNode) {
      nodeLookup.set(userNode.id, internalNode);
    } else {
      const positionWithOrigin = getNodePositionWithOrigin(userNode, _options.nodeOrigin);
      const extent = isCoordinateExtent(userNode.extent) ? userNode.extent : _options.nodeExtent;
      const clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(userNode));
      internalNode = {
        ..._options.defaults,
        ...userNode,
        measured: {
          width: userNode.measured?.width,
          height: userNode.measured?.height
        },
        internals: {
          positionAbsolute: clampedPosition,
          // if user re-initializes the node or removes `measured` for whatever reason, we reset the handleBounds so that the node gets re-measured
          handleBounds: parseHandles(userNode, internalNode),
          z: calculateZ(userNode, selectedNodeZ),
          userNode
        }
      };
      nodeLookup.set(userNode.id, internalNode);
    }
    if ((internalNode.measured === void 0 || internalNode.measured.width === void 0 || internalNode.measured.height === void 0) && !internalNode.hidden) {
      nodesInitialized = false;
    }
    if (userNode.parentId) {
      updateChildNode(internalNode, nodeLookup, parentLookup, options, rootParentIndex);
    }
  }
  return nodesInitialized;
}
function updateParentLookup(node, parentLookup) {
  if (!node.parentId) {
    return;
  }
  const childNodes = parentLookup.get(node.parentId);
  if (childNodes) {
    childNodes.set(node.id, node);
  } else {
    parentLookup.set(node.parentId, /* @__PURE__ */ new Map([[node.id, node]]));
  }
}
function updateChildNode(node, nodeLookup, parentLookup, options, rootParentIndex) {
  const { elevateNodesOnSelect, nodeOrigin, nodeExtent } = mergeObjects(defaultOptions, options);
  const parentId = node.parentId;
  const parentNode = nodeLookup.get(parentId);
  if (!parentNode) {
    console.warn(`Parent node ${parentId} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`);
    return;
  }
  updateParentLookup(node, parentLookup);
  if (rootParentIndex && !parentNode.parentId && parentNode.internals.rootParentIndex === void 0) {
    parentNode.internals.rootParentIndex = ++rootParentIndex.i;
    parentNode.internals.z = parentNode.internals.z + rootParentIndex.i * ROOT_PARENT_Z_INCREMENT;
  }
  if (rootParentIndex && parentNode.internals.rootParentIndex !== void 0) {
    rootParentIndex.i = parentNode.internals.rootParentIndex;
  }
  const selectedNodeZ = elevateNodesOnSelect ? SELECTED_NODE_Z : 0;
  const { x, y, z } = calculateChildXYZ(node, parentNode, nodeOrigin, nodeExtent, selectedNodeZ);
  const { positionAbsolute } = node.internals;
  const positionChanged = x !== positionAbsolute.x || y !== positionAbsolute.y;
  if (positionChanged || z !== node.internals.z) {
    nodeLookup.set(node.id, {
      ...node,
      internals: {
        ...node.internals,
        positionAbsolute: positionChanged ? { x, y } : positionAbsolute,
        z
      }
    });
  }
}
function calculateZ(node, selectedNodeZ) {
  return (isNumeric(node.zIndex) ? node.zIndex : 0) + (node.selected ? selectedNodeZ : 0);
}
function calculateChildXYZ(childNode, parentNode, nodeOrigin, nodeExtent, selectedNodeZ) {
  const { x: parentX, y: parentY } = parentNode.internals.positionAbsolute;
  const childDimensions = getNodeDimensions(childNode);
  const positionWithOrigin = getNodePositionWithOrigin(childNode, nodeOrigin);
  const clampedPosition = isCoordinateExtent(childNode.extent) ? clampPosition(positionWithOrigin, childNode.extent, childDimensions) : positionWithOrigin;
  let absolutePosition = clampPosition({ x: parentX + clampedPosition.x, y: parentY + clampedPosition.y }, nodeExtent, childDimensions);
  if (childNode.extent === "parent") {
    absolutePosition = clampPositionToParent(absolutePosition, childDimensions, parentNode);
  }
  const childZ = calculateZ(childNode, selectedNodeZ);
  const parentZ = parentNode.internals.z ?? 0;
  return {
    x: absolutePosition.x,
    y: absolutePosition.y,
    z: parentZ >= childZ ? parentZ + 1 : childZ
  };
}
function handleExpandParent(children2, nodeLookup, parentLookup, nodeOrigin = [0, 0]) {
  const changes = [];
  const parentExpansions = /* @__PURE__ */ new Map();
  for (const child2 of children2) {
    const parent = nodeLookup.get(child2.parentId);
    if (!parent) {
      continue;
    }
    const parentRect = parentExpansions.get(child2.parentId)?.expandedRect ?? nodeToRect(parent);
    const expandedRect = getBoundsOfRects(parentRect, child2.rect);
    parentExpansions.set(child2.parentId, { expandedRect, parent });
  }
  if (parentExpansions.size > 0) {
    parentExpansions.forEach(({ expandedRect, parent }, parentId) => {
      const positionAbsolute = parent.internals.positionAbsolute;
      const dimensions = getNodeDimensions(parent);
      const origin = parent.origin ?? nodeOrigin;
      const xChange = expandedRect.x < positionAbsolute.x ? Math.round(Math.abs(positionAbsolute.x - expandedRect.x)) : 0;
      const yChange = expandedRect.y < positionAbsolute.y ? Math.round(Math.abs(positionAbsolute.y - expandedRect.y)) : 0;
      const newWidth = Math.max(dimensions.width, Math.round(expandedRect.width));
      const newHeight = Math.max(dimensions.height, Math.round(expandedRect.height));
      const widthChange = (newWidth - dimensions.width) * origin[0];
      const heightChange = (newHeight - dimensions.height) * origin[1];
      if (xChange > 0 || yChange > 0 || widthChange || heightChange) {
        changes.push({
          id: parentId,
          type: "position",
          position: {
            x: parent.position.x - xChange + widthChange,
            y: parent.position.y - yChange + heightChange
          }
        });
        parentLookup.get(parentId)?.forEach((childNode) => {
          if (!children2.some((child2) => child2.id === childNode.id)) {
            changes.push({
              id: childNode.id,
              type: "position",
              position: {
                x: childNode.position.x + xChange,
                y: childNode.position.y + yChange
              }
            });
          }
        });
      }
      if (dimensions.width < expandedRect.width || dimensions.height < expandedRect.height || xChange || yChange) {
        changes.push({
          id: parentId,
          type: "dimensions",
          setAttributes: true,
          dimensions: {
            width: newWidth + (xChange ? origin[0] * xChange - widthChange : 0),
            height: newHeight + (yChange ? origin[1] * yChange - heightChange : 0)
          }
        });
      }
    });
  }
  return changes;
}
function updateNodeInternals(updates, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent) {
  const viewportNode = domNode?.querySelector(".xyflow__viewport");
  let updatedInternals = false;
  if (!viewportNode) {
    return { changes: [], updatedInternals };
  }
  const changes = [];
  const style = window.getComputedStyle(viewportNode);
  const { m22: zoom2 } = new window.DOMMatrixReadOnly(style.transform);
  const parentExpandChildren = [];
  for (const update of updates.values()) {
    const node = nodeLookup.get(update.id);
    if (!node) {
      continue;
    }
    if (node.hidden) {
      nodeLookup.set(node.id, {
        ...node,
        internals: {
          ...node.internals,
          handleBounds: void 0
        }
      });
      updatedInternals = true;
      continue;
    }
    const dimensions = getDimensions(update.nodeElement);
    const dimensionChanged = node.measured.width !== dimensions.width || node.measured.height !== dimensions.height;
    const doUpdate = !!(dimensions.width && dimensions.height && (dimensionChanged || !node.internals.handleBounds || update.force));
    if (doUpdate) {
      const nodeBounds = update.nodeElement.getBoundingClientRect();
      const extent = isCoordinateExtent(node.extent) ? node.extent : nodeExtent;
      let { positionAbsolute } = node.internals;
      if (node.parentId && node.extent === "parent") {
        positionAbsolute = clampPositionToParent(positionAbsolute, dimensions, nodeLookup.get(node.parentId));
      } else if (extent) {
        positionAbsolute = clampPosition(positionAbsolute, extent, dimensions);
      }
      const newNode = {
        ...node,
        measured: dimensions,
        internals: {
          ...node.internals,
          positionAbsolute,
          handleBounds: {
            source: getHandleBounds("source", update.nodeElement, nodeBounds, zoom2, node.id),
            target: getHandleBounds("target", update.nodeElement, nodeBounds, zoom2, node.id)
          }
        }
      };
      nodeLookup.set(node.id, newNode);
      if (node.parentId) {
        updateChildNode(newNode, nodeLookup, parentLookup, { nodeOrigin });
      }
      updatedInternals = true;
      if (dimensionChanged) {
        changes.push({
          id: node.id,
          type: "dimensions",
          dimensions
        });
        if (node.expandParent && node.parentId) {
          parentExpandChildren.push({
            id: node.id,
            parentId: node.parentId,
            rect: nodeToRect(newNode, nodeOrigin)
          });
        }
      }
    }
  }
  if (parentExpandChildren.length > 0) {
    const parentExpandChanges = handleExpandParent(parentExpandChildren, nodeLookup, parentLookup, nodeOrigin);
    changes.push(...parentExpandChanges);
  }
  return { changes, updatedInternals };
}
async function panBy({ delta, panZoom, transform: transform2, translateExtent, width, height }) {
  if (!panZoom || !delta.x && !delta.y) {
    return Promise.resolve(false);
  }
  const nextViewport = await panZoom.setViewportConstrained({
    x: transform2[0] + delta.x,
    y: transform2[1] + delta.y,
    zoom: transform2[2]
  }, [
    [0, 0],
    [width, height]
  ], translateExtent);
  const transformChanged = !!nextViewport && (nextViewport.x !== transform2[0] || nextViewport.y !== transform2[1] || nextViewport.k !== transform2[2]);
  return Promise.resolve(transformChanged);
}
function addConnectionToLookup(type, connection, connectionKey, connectionLookup, nodeId, handleId) {
  let key2 = nodeId;
  const nodeMap = connectionLookup.get(key2) || /* @__PURE__ */ new Map();
  connectionLookup.set(key2, nodeMap.set(connectionKey, connection));
  key2 = `${nodeId}-${type}`;
  const typeMap = connectionLookup.get(key2) || /* @__PURE__ */ new Map();
  connectionLookup.set(key2, typeMap.set(connectionKey, connection));
  if (handleId) {
    key2 = `${nodeId}-${type}-${handleId}`;
    const handleMap = connectionLookup.get(key2) || /* @__PURE__ */ new Map();
    connectionLookup.set(key2, handleMap.set(connectionKey, connection));
  }
}
function updateConnectionLookup(connectionLookup, edgeLookup, edges) {
  connectionLookup.clear();
  edgeLookup.clear();
  for (const edge of edges) {
    const { source: sourceNode, target: targetNode, sourceHandle = null, targetHandle = null } = edge;
    const connection = { edgeId: edge.id, source: sourceNode, target: targetNode, sourceHandle, targetHandle };
    const sourceKey = `${sourceNode}-${sourceHandle}--${targetNode}-${targetHandle}`;
    const targetKey = `${targetNode}-${targetHandle}--${sourceNode}-${sourceHandle}`;
    addConnectionToLookup("source", connection, targetKey, connectionLookup, sourceNode, sourceHandle);
    addConnectionToLookup("target", connection, sourceKey, connectionLookup, targetNode, targetHandle);
    edgeLookup.set(edge.id, edge);
  }
}
function shallowNodeData(a, b) {
  if (a === null || b === null) {
    return false;
  }
  const _a = Array.isArray(a) ? a : [a];
  const _b = Array.isArray(b) ? b : [b];
  if (_a.length !== _b.length) {
    return false;
  }
  for (let i = 0; i < _a.length; i++) {
    if (_a[i].id !== _b[i].id || _a[i].type !== _b[i].type || !Object.is(_a[i].data, _b[i].data)) {
      return false;
    }
  }
  return true;
}
function isParentSelected(node, nodeLookup) {
  if (!node.parentId) {
    return false;
  }
  const parentNode = nodeLookup.get(node.parentId);
  if (!parentNode) {
    return false;
  }
  if (parentNode.selected) {
    return true;
  }
  return isParentSelected(parentNode, nodeLookup);
}
function hasSelector(target, selector, domNode) {
  let current = target;
  do {
    if (current?.matches?.(selector))
      return true;
    if (current === domNode)
      return false;
    current = current?.parentElement;
  } while (current);
  return false;
}
function getDragItems(nodeLookup, nodesDraggable, mousePos, nodeId) {
  const dragItems = /* @__PURE__ */ new Map();
  for (const [id2, node] of nodeLookup) {
    if ((node.selected || node.id === nodeId) && (!node.parentId || !isParentSelected(node, nodeLookup)) && (node.draggable || nodesDraggable && typeof node.draggable === "undefined")) {
      const internalNode = nodeLookup.get(id2);
      if (internalNode) {
        dragItems.set(id2, {
          id: id2,
          position: internalNode.position || { x: 0, y: 0 },
          distance: {
            x: mousePos.x - internalNode.internals.positionAbsolute.x,
            y: mousePos.y - internalNode.internals.positionAbsolute.y
          },
          extent: internalNode.extent,
          parentId: internalNode.parentId,
          origin: internalNode.origin,
          expandParent: internalNode.expandParent,
          internals: {
            positionAbsolute: internalNode.internals.positionAbsolute || { x: 0, y: 0 }
          },
          measured: {
            width: internalNode.measured.width ?? 0,
            height: internalNode.measured.height ?? 0
          }
        });
      }
    }
  }
  return dragItems;
}
function getEventHandlerParams({ nodeId, dragItems, nodeLookup, dragging = true }) {
  const nodesFromDragItems = [];
  for (const [id2, dragItem] of dragItems) {
    const node2 = nodeLookup.get(id2)?.internals.userNode;
    if (node2) {
      nodesFromDragItems.push({
        ...node2,
        position: dragItem.position,
        dragging
      });
    }
  }
  if (!nodeId) {
    return [nodesFromDragItems[0], nodesFromDragItems];
  }
  const node = nodeLookup.get(nodeId)?.internals.userNode;
  return [
    !node ? nodesFromDragItems[0] : {
      ...node,
      position: dragItems.get(nodeId)?.position || node.position,
      dragging
    },
    nodesFromDragItems
  ];
}
function calculateSnapOffset({ dragItems, snapGrid, x, y }) {
  const refDragItem = dragItems.values().next().value;
  if (!refDragItem) {
    return null;
  }
  const refPos = {
    x: x - refDragItem.distance.x,
    y: y - refDragItem.distance.y
  };
  const refPosSnapped = snapPosition(refPos, snapGrid);
  return {
    x: refPosSnapped.x - refPos.x,
    y: refPosSnapped.y - refPos.y
  };
}
function XYDrag({ onNodeMouseDown, getStoreItems, onDragStart, onDrag, onDragStop }) {
  let lastPos = { x: null, y: null };
  let autoPanId = 0;
  let dragItems = /* @__PURE__ */ new Map();
  let autoPanStarted = false;
  let mousePosition = { x: 0, y: 0 };
  let containerBounds = null;
  let dragStarted = false;
  let d3Selection = null;
  let abortDrag = false;
  let nodePositionsChanged = false;
  let dragEvent = null;
  function update({ noDragClassName, handleSelector, domNode, isSelectable, nodeId, nodeClickDistance = 0 }) {
    d3Selection = select_default2(domNode);
    function updateNodes({ x, y }) {
      const { nodeLookup, nodeExtent, snapGrid, snapToGrid, nodeOrigin, onNodeDrag, onSelectionDrag, onError, updateNodePositions } = getStoreItems();
      lastPos = { x, y };
      let hasChange = false;
      const isMultiDrag = dragItems.size > 1;
      const nodesBox = isMultiDrag && nodeExtent ? rectToBox(getInternalNodesBounds(dragItems)) : null;
      const multiDragSnapOffset = isMultiDrag && snapToGrid ? calculateSnapOffset({
        dragItems,
        snapGrid,
        x,
        y
      }) : null;
      for (const [id2, dragItem] of dragItems) {
        if (!nodeLookup.has(id2)) {
          continue;
        }
        let nextPosition = { x: x - dragItem.distance.x, y: y - dragItem.distance.y };
        if (snapToGrid) {
          nextPosition = multiDragSnapOffset ? {
            x: Math.round(nextPosition.x + multiDragSnapOffset.x),
            y: Math.round(nextPosition.y + multiDragSnapOffset.y)
          } : snapPosition(nextPosition, snapGrid);
        }
        let adjustedNodeExtent = null;
        if (isMultiDrag && nodeExtent && !dragItem.extent && nodesBox) {
          const { positionAbsolute: positionAbsolute2 } = dragItem.internals;
          const x1 = positionAbsolute2.x - nodesBox.x + nodeExtent[0][0];
          const x2 = positionAbsolute2.x + dragItem.measured.width - nodesBox.x2 + nodeExtent[1][0];
          const y1 = positionAbsolute2.y - nodesBox.y + nodeExtent[0][1];
          const y2 = positionAbsolute2.y + dragItem.measured.height - nodesBox.y2 + nodeExtent[1][1];
          adjustedNodeExtent = [
            [x1, y1],
            [x2, y2]
          ];
        }
        const { position, positionAbsolute } = calculateNodePosition({
          nodeId: id2,
          nextPosition,
          nodeLookup,
          nodeExtent: adjustedNodeExtent ? adjustedNodeExtent : nodeExtent,
          nodeOrigin,
          onError
        });
        hasChange = hasChange || dragItem.position.x !== position.x || dragItem.position.y !== position.y;
        dragItem.position = position;
        dragItem.internals.positionAbsolute = positionAbsolute;
      }
      nodePositionsChanged = nodePositionsChanged || hasChange;
      if (!hasChange) {
        return;
      }
      updateNodePositions(dragItems, true);
      if (dragEvent && (onDrag || onNodeDrag || !nodeId && onSelectionDrag)) {
        const [currentNode, currentNodes] = getEventHandlerParams({
          nodeId,
          dragItems,
          nodeLookup
        });
        onDrag?.(dragEvent, dragItems, currentNode, currentNodes);
        onNodeDrag?.(dragEvent, currentNode, currentNodes);
        if (!nodeId) {
          onSelectionDrag?.(dragEvent, currentNodes);
        }
      }
    }
    async function autoPan() {
      if (!containerBounds) {
        return;
      }
      const { transform: transform2, panBy: panBy2, autoPanSpeed, autoPanOnNodeDrag } = getStoreItems();
      if (!autoPanOnNodeDrag) {
        autoPanStarted = false;
        cancelAnimationFrame(autoPanId);
        return;
      }
      const [xMovement, yMovement] = calcAutoPan(mousePosition, containerBounds, autoPanSpeed);
      if (xMovement !== 0 || yMovement !== 0) {
        lastPos.x = (lastPos.x ?? 0) - xMovement / transform2[2];
        lastPos.y = (lastPos.y ?? 0) - yMovement / transform2[2];
        if (await panBy2({ x: xMovement, y: yMovement })) {
          updateNodes(lastPos);
        }
      }
      autoPanId = requestAnimationFrame(autoPan);
    }
    function startDrag(event2) {
      const { nodeLookup, multiSelectionActive, nodesDraggable, transform: transform2, snapGrid, snapToGrid, selectNodesOnDrag, onNodeDragStart, onSelectionDragStart, unselectNodesAndEdges } = getStoreItems();
      dragStarted = true;
      if ((!selectNodesOnDrag || !isSelectable) && !multiSelectionActive && nodeId) {
        if (!nodeLookup.get(nodeId)?.selected) {
          unselectNodesAndEdges();
        }
      }
      if (isSelectable && selectNodesOnDrag && nodeId) {
        onNodeMouseDown?.(nodeId);
      }
      const pointerPos = getPointerPosition(event2.sourceEvent, { transform: transform2, snapGrid, snapToGrid, containerBounds });
      lastPos = pointerPos;
      dragItems = getDragItems(nodeLookup, nodesDraggable, pointerPos, nodeId);
      if (dragItems.size > 0 && (onDragStart || onNodeDragStart || !nodeId && onSelectionDragStart)) {
        const [currentNode, currentNodes] = getEventHandlerParams({
          nodeId,
          dragItems,
          nodeLookup
        });
        onDragStart?.(event2.sourceEvent, dragItems, currentNode, currentNodes);
        onNodeDragStart?.(event2.sourceEvent, currentNode, currentNodes);
        if (!nodeId) {
          onSelectionDragStart?.(event2.sourceEvent, currentNodes);
        }
      }
    }
    const d3DragInstance = drag_default().clickDistance(nodeClickDistance).on("start", (event2) => {
      const { domNode: domNode2, nodeDragThreshold, transform: transform2, snapGrid, snapToGrid } = getStoreItems();
      containerBounds = domNode2?.getBoundingClientRect() || null;
      abortDrag = false;
      nodePositionsChanged = false;
      dragEvent = event2.sourceEvent;
      if (nodeDragThreshold === 0) {
        startDrag(event2);
      }
      const pointerPos = getPointerPosition(event2.sourceEvent, { transform: transform2, snapGrid, snapToGrid, containerBounds });
      lastPos = pointerPos;
      mousePosition = getEventPosition(event2.sourceEvent, containerBounds);
    }).on("drag", (event2) => {
      const { autoPanOnNodeDrag, transform: transform2, snapGrid, snapToGrid, nodeDragThreshold, nodeLookup } = getStoreItems();
      const pointerPos = getPointerPosition(event2.sourceEvent, { transform: transform2, snapGrid, snapToGrid, containerBounds });
      dragEvent = event2.sourceEvent;
      if (event2.sourceEvent.type === "touchmove" && event2.sourceEvent.touches.length > 1 || // if user deletes a node while dragging, we need to abort the drag to prevent errors
      nodeId && !nodeLookup.has(nodeId)) {
        abortDrag = true;
      }
      if (abortDrag) {
        return;
      }
      if (!autoPanStarted && autoPanOnNodeDrag && dragStarted) {
        autoPanStarted = true;
        autoPan();
      }
      if (!dragStarted) {
        const currentMousePosition = getEventPosition(event2.sourceEvent, containerBounds);
        const x = currentMousePosition.x - mousePosition.x;
        const y = currentMousePosition.y - mousePosition.y;
        const distance2 = Math.sqrt(x * x + y * y);
        if (distance2 > nodeDragThreshold) {
          startDrag(event2);
        }
      }
      if ((lastPos.x !== pointerPos.xSnapped || lastPos.y !== pointerPos.ySnapped) && dragItems && dragStarted) {
        mousePosition = getEventPosition(event2.sourceEvent, containerBounds);
        updateNodes(pointerPos);
      }
    }).on("end", (event2) => {
      if (!dragStarted || abortDrag) {
        return;
      }
      autoPanStarted = false;
      dragStarted = false;
      cancelAnimationFrame(autoPanId);
      if (dragItems.size > 0) {
        const { nodeLookup, updateNodePositions, onNodeDragStop, onSelectionDragStop } = getStoreItems();
        if (nodePositionsChanged) {
          updateNodePositions(dragItems, false);
          nodePositionsChanged = false;
        }
        if (onDragStop || onNodeDragStop || !nodeId && onSelectionDragStop) {
          const [currentNode, currentNodes] = getEventHandlerParams({
            nodeId,
            dragItems,
            nodeLookup,
            dragging: false
          });
          onDragStop?.(event2.sourceEvent, dragItems, currentNode, currentNodes);
          onNodeDragStop?.(event2.sourceEvent, currentNode, currentNodes);
          if (!nodeId) {
            onSelectionDragStop?.(event2.sourceEvent, currentNodes);
          }
        }
      }
    }).filter((event2) => {
      const target = event2.target;
      const isDraggable = !event2.button && (!noDragClassName || !hasSelector(target, `.${noDragClassName}`, domNode)) && (!handleSelector || hasSelector(target, handleSelector, domNode));
      return isDraggable;
    });
    d3Selection.call(d3DragInstance);
  }
  function destroy() {
    d3Selection?.on(".drag", null);
  }
  return {
    update,
    destroy
  };
}
function getNodesWithinDistance(position, nodeLookup, distance2) {
  const nodes = [];
  const rect = {
    x: position.x - distance2,
    y: position.y - distance2,
    width: distance2 * 2,
    height: distance2 * 2
  };
  for (const node of nodeLookup.values()) {
    if (getOverlappingArea(rect, nodeToRect(node)) > 0) {
      nodes.push(node);
    }
  }
  return nodes;
}
var ADDITIONAL_DISTANCE = 250;
function getClosestHandle(position, connectionRadius, nodeLookup, fromHandle) {
  let closestHandles = [];
  let minDistance = Infinity;
  const closeNodes = getNodesWithinDistance(position, nodeLookup, connectionRadius + ADDITIONAL_DISTANCE);
  for (const node of closeNodes) {
    const allHandles = [...node.internals.handleBounds?.source ?? [], ...node.internals.handleBounds?.target ?? []];
    for (const handle of allHandles) {
      if (fromHandle.nodeId === handle.nodeId && fromHandle.type === handle.type && fromHandle.id === handle.id) {
        continue;
      }
      const { x, y } = getHandlePosition(node, handle, handle.position, true);
      const distance2 = Math.sqrt(Math.pow(x - position.x, 2) + Math.pow(y - position.y, 2));
      if (distance2 > connectionRadius) {
        continue;
      }
      if (distance2 < minDistance) {
        closestHandles = [{ ...handle, x, y }];
        minDistance = distance2;
      } else if (distance2 === minDistance) {
        closestHandles.push({ ...handle, x, y });
      }
    }
  }
  if (!closestHandles.length) {
    return null;
  }
  if (closestHandles.length > 1) {
    const oppositeHandleType = fromHandle.type === "source" ? "target" : "source";
    return closestHandles.find((handle) => handle.type === oppositeHandleType) ?? closestHandles[0];
  }
  return closestHandles[0];
}
function getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode, withAbsolutePosition = false) {
  const node = nodeLookup.get(nodeId);
  if (!node) {
    return null;
  }
  const handles = connectionMode === "strict" ? node.internals.handleBounds?.[handleType] : [...node.internals.handleBounds?.source ?? [], ...node.internals.handleBounds?.target ?? []];
  const handle = (handleId ? handles?.find((h) => h.id === handleId) : handles?.[0]) ?? null;
  return handle && withAbsolutePosition ? { ...handle, ...getHandlePosition(node, handle, handle.position, true) } : handle;
}
function getHandleType(edgeUpdaterType, handleDomNode) {
  if (edgeUpdaterType) {
    return edgeUpdaterType;
  } else if (handleDomNode?.classList.contains("target")) {
    return "target";
  } else if (handleDomNode?.classList.contains("source")) {
    return "source";
  }
  return null;
}
function isConnectionValid(isInsideConnectionRadius, isHandleValid) {
  let isValid = null;
  if (isHandleValid) {
    isValid = true;
  } else if (isInsideConnectionRadius && !isHandleValid) {
    isValid = false;
  }
  return isValid;
}
var alwaysValid = () => true;
function onPointerDown(event2, { connectionMode, connectionRadius, handleId, nodeId, edgeUpdaterType, isTarget, domNode, nodeLookup, lib, autoPanOnConnect, flowId, panBy: panBy2, cancelConnection, onConnectStart, onConnect, onConnectEnd, isValidConnection = alwaysValid, onReconnectEnd, updateConnection, getTransform, getFromHandle, autoPanSpeed, dragThreshold = 1, handleDomNode }) {
  const doc = getHostForElement(event2.target);
  let autoPanId = 0;
  let closestHandle;
  const { x, y } = getEventPosition(event2);
  const handleType = getHandleType(edgeUpdaterType, handleDomNode);
  const containerBounds = domNode?.getBoundingClientRect();
  let connectionStarted = false;
  if (!containerBounds || !handleType) {
    return;
  }
  const fromHandleInternal = getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode);
  if (!fromHandleInternal) {
    return;
  }
  let position = getEventPosition(event2, containerBounds);
  let autoPanStarted = false;
  let connection = null;
  let isValid = false;
  let resultHandleDomNode = null;
  function autoPan() {
    if (!autoPanOnConnect || !containerBounds) {
      return;
    }
    const [x2, y2] = calcAutoPan(position, containerBounds, autoPanSpeed);
    panBy2({ x: x2, y: y2 });
    autoPanId = requestAnimationFrame(autoPan);
  }
  const fromHandle = {
    ...fromHandleInternal,
    nodeId,
    type: handleType,
    position: fromHandleInternal.position
  };
  const fromNodeInternal = nodeLookup.get(nodeId);
  const from = getHandlePosition(fromNodeInternal, fromHandle, Position.Left, true);
  let previousConnection = {
    inProgress: true,
    isValid: null,
    from,
    fromHandle,
    fromPosition: fromHandle.position,
    fromNode: fromNodeInternal,
    to: position,
    toHandle: null,
    toPosition: oppositePosition[fromHandle.position],
    toNode: null,
    pointer: position
  };
  function startConnection() {
    connectionStarted = true;
    updateConnection(previousConnection);
    onConnectStart?.(event2, { nodeId, handleId, handleType });
  }
  if (dragThreshold === 0) {
    startConnection();
  }
  function onPointerMove(event3) {
    if (!connectionStarted) {
      const { x: evtX, y: evtY } = getEventPosition(event3);
      const dx = evtX - x;
      const dy = evtY - y;
      const nextConnectionStarted = dx * dx + dy * dy > dragThreshold * dragThreshold;
      if (!nextConnectionStarted) {
        return;
      }
      startConnection();
    }
    if (!getFromHandle() || !fromHandle) {
      onPointerUp(event3);
      return;
    }
    const transform2 = getTransform();
    position = getEventPosition(event3, containerBounds);
    closestHandle = getClosestHandle(pointToRendererPoint(position, transform2, false, [1, 1]), connectionRadius, nodeLookup, fromHandle);
    if (!autoPanStarted) {
      autoPan();
      autoPanStarted = true;
    }
    const result = isValidHandle(event3, {
      handle: closestHandle,
      connectionMode,
      fromNodeId: nodeId,
      fromHandleId: handleId,
      fromType: isTarget ? "target" : "source",
      isValidConnection,
      doc,
      lib,
      flowId,
      nodeLookup
    });
    resultHandleDomNode = result.handleDomNode;
    connection = result.connection;
    isValid = isConnectionValid(!!closestHandle, result.isValid);
    const newConnection = {
      // from stays the same
      ...previousConnection,
      isValid,
      to: result.toHandle && isValid ? rendererPointToPoint({ x: result.toHandle.x, y: result.toHandle.y }, transform2) : position,
      toHandle: result.toHandle,
      toPosition: isValid && result.toHandle ? result.toHandle.position : oppositePosition[fromHandle.position],
      toNode: result.toHandle ? nodeLookup.get(result.toHandle.nodeId) : null,
      pointer: position
    };
    updateConnection(newConnection);
    previousConnection = newConnection;
  }
  function onPointerUp(event3) {
    if ("touches" in event3 && event3.touches.length > 0) {
      return;
    }
    if (connectionStarted) {
      if ((closestHandle || resultHandleDomNode) && connection && isValid) {
        onConnect?.(connection);
      }
      const { inProgress, ...connectionState } = previousConnection;
      const finalConnectionState = {
        ...connectionState,
        toPosition: previousConnection.toHandle ? previousConnection.toPosition : null
      };
      onConnectEnd?.(event3, finalConnectionState);
      if (edgeUpdaterType) {
        onReconnectEnd?.(event3, finalConnectionState);
      }
    }
    cancelConnection();
    cancelAnimationFrame(autoPanId);
    autoPanStarted = false;
    isValid = false;
    connection = null;
    resultHandleDomNode = null;
    doc.removeEventListener("mousemove", onPointerMove);
    doc.removeEventListener("mouseup", onPointerUp);
    doc.removeEventListener("touchmove", onPointerMove);
    doc.removeEventListener("touchend", onPointerUp);
  }
  doc.addEventListener("mousemove", onPointerMove);
  doc.addEventListener("mouseup", onPointerUp);
  doc.addEventListener("touchmove", onPointerMove);
  doc.addEventListener("touchend", onPointerUp);
}
function isValidHandle(event2, { handle, connectionMode, fromNodeId, fromHandleId, fromType, doc, lib, flowId, isValidConnection = alwaysValid, nodeLookup }) {
  const isTarget = fromType === "target";
  const handleDomNode = handle ? doc.querySelector(`.${lib}-flow__handle[data-id="${flowId}-${handle?.nodeId}-${handle?.id}-${handle?.type}"]`) : null;
  const { x, y } = getEventPosition(event2);
  const handleBelow = doc.elementFromPoint(x, y);
  const handleToCheck = handleBelow?.classList.contains(`${lib}-flow__handle`) ? handleBelow : handleDomNode;
  const result = {
    handleDomNode: handleToCheck,
    isValid: false,
    connection: null,
    toHandle: null
  };
  if (handleToCheck) {
    const handleType = getHandleType(void 0, handleToCheck);
    const handleNodeId = handleToCheck.getAttribute("data-nodeid");
    const handleId = handleToCheck.getAttribute("data-handleid");
    const connectable = handleToCheck.classList.contains("connectable");
    const connectableEnd = handleToCheck.classList.contains("connectableend");
    if (!handleNodeId || !handleType) {
      return result;
    }
    const connection = {
      source: isTarget ? handleNodeId : fromNodeId,
      sourceHandle: isTarget ? handleId : fromHandleId,
      target: isTarget ? fromNodeId : handleNodeId,
      targetHandle: isTarget ? fromHandleId : handleId
    };
    result.connection = connection;
    const isConnectable = connectable && connectableEnd;
    const isValid = isConnectable && (connectionMode === ConnectionMode.Strict ? isTarget && handleType === "source" || !isTarget && handleType === "target" : handleNodeId !== fromNodeId || handleId !== fromHandleId);
    result.isValid = isValid && isValidConnection(connection);
    result.toHandle = getHandle(handleNodeId, handleType, handleId, nodeLookup, connectionMode, true);
  }
  return result;
}
var XYHandle = {
  onPointerDown,
  isValid: isValidHandle
};
function XYMinimap({ domNode, panZoom, getTransform, getViewScale }) {
  const selection2 = select_default2(domNode);
  function update({ translateExtent, width, height, zoomStep = 1, pannable = true, zoomable = true, inversePan = false }) {
    const zoomHandler = (event2) => {
      if (event2.sourceEvent.type !== "wheel" || !panZoom) {
        return;
      }
      const transform2 = getTransform();
      const factor = event2.sourceEvent.ctrlKey && isMacOs() ? 10 : 1;
      const pinchDelta = -event2.sourceEvent.deltaY * (event2.sourceEvent.deltaMode === 1 ? 0.05 : event2.sourceEvent.deltaMode ? 1 : 2e-3) * zoomStep;
      const nextZoom = transform2[2] * Math.pow(2, pinchDelta * factor);
      panZoom.scaleTo(nextZoom);
    };
    let panStart = [0, 0];
    const panStartHandler = (event2) => {
      if (event2.sourceEvent.type === "mousedown" || event2.sourceEvent.type === "touchstart") {
        panStart = [
          event2.sourceEvent.clientX ?? event2.sourceEvent.touches[0].clientX,
          event2.sourceEvent.clientY ?? event2.sourceEvent.touches[0].clientY
        ];
      }
    };
    const panHandler = (event2) => {
      const transform2 = getTransform();
      if (event2.sourceEvent.type !== "mousemove" && event2.sourceEvent.type !== "touchmove" || !panZoom) {
        return;
      }
      const panCurrent = [
        event2.sourceEvent.clientX ?? event2.sourceEvent.touches[0].clientX,
        event2.sourceEvent.clientY ?? event2.sourceEvent.touches[0].clientY
      ];
      const panDelta = [panCurrent[0] - panStart[0], panCurrent[1] - panStart[1]];
      panStart = panCurrent;
      const moveScale = getViewScale() * Math.max(transform2[2], Math.log(transform2[2])) * (inversePan ? -1 : 1);
      const position = {
        x: transform2[0] - panDelta[0] * moveScale,
        y: transform2[1] - panDelta[1] * moveScale
      };
      const extent = [
        [0, 0],
        [width, height]
      ];
      panZoom.setViewportConstrained({
        x: position.x,
        y: position.y,
        zoom: transform2[2]
      }, extent, translateExtent);
    };
    const zoomAndPanHandler = zoom_default2().on("start", panStartHandler).on("zoom", pannable ? panHandler : null).on("zoom.wheel", zoomable ? zoomHandler : null);
    selection2.call(zoomAndPanHandler, {});
  }
  function destroy() {
    selection2.on("zoom", null);
  }
  return {
    update,
    destroy,
    pointer: pointer_default
  };
}
var transformToViewport = (transform2) => ({
  x: transform2.x,
  y: transform2.y,
  zoom: transform2.k
});
var viewportToTransform = ({ x, y, zoom: zoom2 }) => identity2.translate(x, y).scale(zoom2);
var isWrappedWithClass = (event2, className) => event2.target.closest(`.${className}`);
var isRightClickPan = (panOnDrag, usedButton) => usedButton === 2 && Array.isArray(panOnDrag) && panOnDrag.includes(2);
var defaultEase = (t) => ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
var getD3Transition = (selection2, duration = 0, ease = defaultEase, onEnd = () => {
}) => {
  const hasDuration = typeof duration === "number" && duration > 0;
  if (!hasDuration) {
    onEnd();
  }
  return hasDuration ? selection2.transition().duration(duration).ease(ease).on("end", onEnd) : selection2;
};
var wheelDelta = (event2) => {
  const factor = event2.ctrlKey && isMacOs() ? 10 : 1;
  return -event2.deltaY * (event2.deltaMode === 1 ? 0.05 : event2.deltaMode ? 1 : 2e-3) * factor;
};
function createPanOnScrollHandler({ zoomPanValues, noWheelClassName, d3Selection, d3Zoom, panOnScrollMode, panOnScrollSpeed, zoomOnPinch, onPanZoomStart, onPanZoom, onPanZoomEnd }) {
  return (event2) => {
    if (isWrappedWithClass(event2, noWheelClassName)) {
      if (event2.ctrlKey) {
        event2.preventDefault();
      }
      return false;
    }
    event2.preventDefault();
    event2.stopImmediatePropagation();
    const currentZoom = d3Selection.property("__zoom").k || 1;
    if (event2.ctrlKey && zoomOnPinch) {
      const point = pointer_default(event2);
      const pinchDelta = wheelDelta(event2);
      const zoom2 = currentZoom * Math.pow(2, pinchDelta);
      d3Zoom.scaleTo(d3Selection, zoom2, point, event2);
      return;
    }
    const deltaNormalize = event2.deltaMode === 1 ? 20 : 1;
    let deltaX = panOnScrollMode === PanOnScrollMode.Vertical ? 0 : event2.deltaX * deltaNormalize;
    let deltaY = panOnScrollMode === PanOnScrollMode.Horizontal ? 0 : event2.deltaY * deltaNormalize;
    if (!isMacOs() && event2.shiftKey && panOnScrollMode !== PanOnScrollMode.Vertical) {
      deltaX = event2.deltaY * deltaNormalize;
      deltaY = 0;
    }
    d3Zoom.translateBy(
      d3Selection,
      -(deltaX / currentZoom) * panOnScrollSpeed,
      -(deltaY / currentZoom) * panOnScrollSpeed,
      // @ts-ignore
      { internal: true }
    );
    const nextViewport = transformToViewport(d3Selection.property("__zoom"));
    clearTimeout(zoomPanValues.panScrollTimeout);
    if (!zoomPanValues.isPanScrolling) {
      zoomPanValues.isPanScrolling = true;
      onPanZoomStart?.(event2, nextViewport);
    } else {
      onPanZoom?.(event2, nextViewport);
      zoomPanValues.panScrollTimeout = setTimeout(() => {
        onPanZoomEnd?.(event2, nextViewport);
        zoomPanValues.isPanScrolling = false;
      }, 150);
    }
  };
}
function createZoomOnScrollHandler({ noWheelClassName, preventScrolling, d3ZoomHandler }) {
  return function(event2, d) {
    const isWheel = event2.type === "wheel";
    const preventZoom = !preventScrolling && isWheel && !event2.ctrlKey;
    const hasNoWheelClass = isWrappedWithClass(event2, noWheelClassName);
    if (event2.ctrlKey && isWheel && hasNoWheelClass) {
      event2.preventDefault();
    }
    if (preventZoom || hasNoWheelClass) {
      return null;
    }
    event2.preventDefault();
    d3ZoomHandler.call(this, event2, d);
  };
}
function createPanZoomStartHandler({ zoomPanValues, onDraggingChange, onPanZoomStart }) {
  return (event2) => {
    if (event2.sourceEvent?.internal) {
      return;
    }
    const viewport = transformToViewport(event2.transform);
    zoomPanValues.mouseButton = event2.sourceEvent?.button || 0;
    zoomPanValues.isZoomingOrPanning = true;
    zoomPanValues.prevViewport = viewport;
    if (event2.sourceEvent?.type === "mousedown") {
      onDraggingChange(true);
    }
    if (onPanZoomStart) {
      onPanZoomStart?.(event2.sourceEvent, viewport);
    }
  };
}
function createPanZoomHandler({ zoomPanValues, panOnDrag, onPaneContextMenu, onTransformChange, onPanZoom }) {
  return (event2) => {
    zoomPanValues.usedRightMouseButton = !!(onPaneContextMenu && isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0));
    if (!event2.sourceEvent?.sync) {
      onTransformChange([event2.transform.x, event2.transform.y, event2.transform.k]);
    }
    if (onPanZoom && !event2.sourceEvent?.internal) {
      onPanZoom?.(event2.sourceEvent, transformToViewport(event2.transform));
    }
  };
}
function createPanZoomEndHandler({ zoomPanValues, panOnDrag, panOnScroll, onDraggingChange, onPanZoomEnd, onPaneContextMenu }) {
  return (event2) => {
    if (event2.sourceEvent?.internal) {
      return;
    }
    zoomPanValues.isZoomingOrPanning = false;
    if (onPaneContextMenu && isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0) && !zoomPanValues.usedRightMouseButton && event2.sourceEvent) {
      onPaneContextMenu(event2.sourceEvent);
    }
    zoomPanValues.usedRightMouseButton = false;
    onDraggingChange(false);
    if (onPanZoomEnd) {
      const viewport = transformToViewport(event2.transform);
      zoomPanValues.prevViewport = viewport;
      clearTimeout(zoomPanValues.timerId);
      zoomPanValues.timerId = setTimeout(
        () => {
          onPanZoomEnd?.(event2.sourceEvent, viewport);
        },
        // we need a setTimeout for panOnScroll to supress multiple end events fired during scroll
        panOnScroll ? 150 : 0
      );
    }
  };
}
function createFilter({ zoomActivationKeyPressed, zoomOnScroll, zoomOnPinch, panOnDrag, panOnScroll, zoomOnDoubleClick, userSelectionActive, noWheelClassName, noPanClassName, lib, connectionInProgress }) {
  return (event2) => {
    const zoomScroll = zoomActivationKeyPressed || zoomOnScroll;
    const pinchZoom = zoomOnPinch && event2.ctrlKey;
    const isWheelEvent = event2.type === "wheel";
    if (event2.button === 1 && event2.type === "mousedown" && (isWrappedWithClass(event2, `${lib}-flow__node`) || isWrappedWithClass(event2, `${lib}-flow__edge`))) {
      return true;
    }
    if (!panOnDrag && !zoomScroll && !panOnScroll && !zoomOnDoubleClick && !zoomOnPinch) {
      return false;
    }
    if (userSelectionActive) {
      return false;
    }
    if (connectionInProgress && !isWheelEvent) {
      return false;
    }
    if (isWrappedWithClass(event2, noWheelClassName) && isWheelEvent) {
      return false;
    }
    if (isWrappedWithClass(event2, noPanClassName) && (!isWheelEvent || panOnScroll && isWheelEvent && !zoomActivationKeyPressed)) {
      return false;
    }
    if (!zoomOnPinch && event2.ctrlKey && isWheelEvent) {
      return false;
    }
    if (!zoomOnPinch && event2.type === "touchstart" && event2.touches?.length > 1) {
      event2.preventDefault();
      return false;
    }
    if (!zoomScroll && !panOnScroll && !pinchZoom && isWheelEvent) {
      return false;
    }
    if (!panOnDrag && (event2.type === "mousedown" || event2.type === "touchstart")) {
      return false;
    }
    if (Array.isArray(panOnDrag) && !panOnDrag.includes(event2.button) && event2.type === "mousedown") {
      return false;
    }
    const buttonAllowed = Array.isArray(panOnDrag) && panOnDrag.includes(event2.button) || !event2.button || event2.button <= 1;
    return (!event2.ctrlKey || isWheelEvent) && buttonAllowed;
  };
}
function XYPanZoom({ domNode, minZoom, maxZoom, translateExtent, viewport, onPanZoom, onPanZoomStart, onPanZoomEnd, onDraggingChange }) {
  const zoomPanValues = {
    isZoomingOrPanning: false,
    usedRightMouseButton: false,
    prevViewport: { x: 0, y: 0, zoom: 0 },
    mouseButton: 0,
    timerId: void 0,
    panScrollTimeout: void 0,
    isPanScrolling: false
  };
  const bbox = domNode.getBoundingClientRect();
  const d3ZoomInstance = zoom_default2().scaleExtent([minZoom, maxZoom]).translateExtent(translateExtent);
  const d3Selection = select_default2(domNode).call(d3ZoomInstance);
  setViewportConstrained({
    x: viewport.x,
    y: viewport.y,
    zoom: clamp(viewport.zoom, minZoom, maxZoom)
  }, [
    [0, 0],
    [bbox.width, bbox.height]
  ], translateExtent);
  const d3ZoomHandler = d3Selection.on("wheel.zoom");
  const d3DblClickZoomHandler = d3Selection.on("dblclick.zoom");
  d3ZoomInstance.wheelDelta(wheelDelta);
  function setTransform(transform2, options) {
    if (d3Selection) {
      return new Promise((resolve) => {
        d3ZoomInstance?.interpolate(options?.interpolate === "linear" ? value_default : zoom_default).transform(getD3Transition(d3Selection, options?.duration, options?.ease, () => resolve(true)), transform2);
      });
    }
    return Promise.resolve(false);
  }
  function update({ noWheelClassName, noPanClassName, onPaneContextMenu, userSelectionActive, panOnScroll, panOnDrag, panOnScrollMode, panOnScrollSpeed, preventScrolling, zoomOnPinch, zoomOnScroll, zoomOnDoubleClick, zoomActivationKeyPressed, lib, onTransformChange, connectionInProgress, paneClickDistance, selectionOnDrag }) {
    if (userSelectionActive && !zoomPanValues.isZoomingOrPanning) {
      destroy();
    }
    const isPanOnScroll = panOnScroll && !zoomActivationKeyPressed && !userSelectionActive;
    d3ZoomInstance.clickDistance(selectionOnDrag ? Infinity : !isNumeric(paneClickDistance) || paneClickDistance < 0 ? 0 : paneClickDistance);
    const wheelHandler = isPanOnScroll ? createPanOnScrollHandler({
      zoomPanValues,
      noWheelClassName,
      d3Selection,
      d3Zoom: d3ZoomInstance,
      panOnScrollMode,
      panOnScrollSpeed,
      zoomOnPinch,
      onPanZoomStart,
      onPanZoom,
      onPanZoomEnd
    }) : createZoomOnScrollHandler({
      noWheelClassName,
      preventScrolling,
      d3ZoomHandler
    });
    d3Selection.on("wheel.zoom", wheelHandler, { passive: false });
    if (!userSelectionActive) {
      const startHandler = createPanZoomStartHandler({
        zoomPanValues,
        onDraggingChange,
        onPanZoomStart
      });
      d3ZoomInstance.on("start", startHandler);
      const panZoomHandler = createPanZoomHandler({
        zoomPanValues,
        panOnDrag,
        onPaneContextMenu: !!onPaneContextMenu,
        onPanZoom,
        onTransformChange
      });
      d3ZoomInstance.on("zoom", panZoomHandler);
      const panZoomEndHandler = createPanZoomEndHandler({
        zoomPanValues,
        panOnDrag,
        panOnScroll,
        onPaneContextMenu,
        onPanZoomEnd,
        onDraggingChange
      });
      d3ZoomInstance.on("end", panZoomEndHandler);
    }
    const filter2 = createFilter({
      zoomActivationKeyPressed,
      panOnDrag,
      zoomOnScroll,
      panOnScroll,
      zoomOnDoubleClick,
      zoomOnPinch,
      userSelectionActive,
      noPanClassName,
      noWheelClassName,
      lib,
      connectionInProgress
    });
    d3ZoomInstance.filter(filter2);
    if (zoomOnDoubleClick) {
      d3Selection.on("dblclick.zoom", d3DblClickZoomHandler);
    } else {
      d3Selection.on("dblclick.zoom", null);
    }
  }
  function destroy() {
    d3ZoomInstance.on("zoom", null);
  }
  async function setViewportConstrained(viewport2, extent, translateExtent2) {
    const nextTransform = viewportToTransform(viewport2);
    const contrainedTransform = d3ZoomInstance?.constrain()(nextTransform, extent, translateExtent2);
    if (contrainedTransform) {
      await setTransform(contrainedTransform);
    }
    return new Promise((resolve) => resolve(contrainedTransform));
  }
  async function setViewport(viewport2, options) {
    const nextTransform = viewportToTransform(viewport2);
    await setTransform(nextTransform, options);
    return new Promise((resolve) => resolve(nextTransform));
  }
  function syncViewport(viewport2) {
    if (d3Selection) {
      const nextTransform = viewportToTransform(viewport2);
      const currentTransform = d3Selection.property("__zoom");
      if (currentTransform.k !== viewport2.zoom || currentTransform.x !== viewport2.x || currentTransform.y !== viewport2.y) {
        d3ZoomInstance?.transform(d3Selection, nextTransform, null, { sync: true });
      }
    }
  }
  function getViewport() {
    const transform2 = d3Selection ? transform(d3Selection.node()) : { x: 0, y: 0, k: 1 };
    return { x: transform2.x, y: transform2.y, zoom: transform2.k };
  }
  function scaleTo(zoom2, options) {
    if (d3Selection) {
      return new Promise((resolve) => {
        d3ZoomInstance?.interpolate(options?.interpolate === "linear" ? value_default : zoom_default).scaleTo(getD3Transition(d3Selection, options?.duration, options?.ease, () => resolve(true)), zoom2);
      });
    }
    return Promise.resolve(false);
  }
  function scaleBy(factor, options) {
    if (d3Selection) {
      return new Promise((resolve) => {
        d3ZoomInstance?.interpolate(options?.interpolate === "linear" ? value_default : zoom_default).scaleBy(getD3Transition(d3Selection, options?.duration, options?.ease, () => resolve(true)), factor);
      });
    }
    return Promise.resolve(false);
  }
  function setScaleExtent(scaleExtent) {
    d3ZoomInstance?.scaleExtent(scaleExtent);
  }
  function setTranslateExtent(translateExtent2) {
    d3ZoomInstance?.translateExtent(translateExtent2);
  }
  function setClickDistance(distance2) {
    const validDistance = !isNumeric(distance2) || distance2 < 0 ? 0 : distance2;
    d3ZoomInstance?.clickDistance(validDistance);
  }
  return {
    update,
    destroy,
    setViewport,
    setViewportConstrained,
    getViewport,
    scaleTo,
    scaleBy,
    setScaleExtent,
    setTranslateExtent,
    syncViewport,
    setClickDistance
  };
}
var ResizeControlVariant;
(function(ResizeControlVariant2) {
  ResizeControlVariant2["Line"] = "line";
  ResizeControlVariant2["Handle"] = "handle";
})(ResizeControlVariant || (ResizeControlVariant = {}));
var XY_RESIZER_HANDLE_POSITIONS = ["top-left", "top-right", "bottom-left", "bottom-right"];
var XY_RESIZER_LINE_POSITIONS = ["top", "right", "bottom", "left"];
function getResizeDirection({ width, prevWidth, height, prevHeight, affectsX, affectsY }) {
  const deltaWidth = width - prevWidth;
  const deltaHeight = height - prevHeight;
  const direction = [deltaWidth > 0 ? 1 : deltaWidth < 0 ? -1 : 0, deltaHeight > 0 ? 1 : deltaHeight < 0 ? -1 : 0];
  if (deltaWidth && affectsX) {
    direction[0] = direction[0] * -1;
  }
  if (deltaHeight && affectsY) {
    direction[1] = direction[1] * -1;
  }
  return direction;
}
function getControlDirection(controlPosition) {
  const isHorizontal = controlPosition.includes("right") || controlPosition.includes("left");
  const isVertical = controlPosition.includes("bottom") || controlPosition.includes("top");
  const affectsX = controlPosition.includes("left");
  const affectsY = controlPosition.includes("top");
  return {
    isHorizontal,
    isVertical,
    affectsX,
    affectsY
  };
}
function getLowerExtentClamp(lowerExtent, lowerBound) {
  return Math.max(0, lowerBound - lowerExtent);
}
function getUpperExtentClamp(upperExtent, upperBound) {
  return Math.max(0, upperExtent - upperBound);
}
function getSizeClamp(size, minSize, maxSize) {
  return Math.max(0, minSize - size, size - maxSize);
}
function xor(a, b) {
  return a ? !b : b;
}
function getDimensionsAfterResize(startValues, controlDirection, pointerPosition, boundaries, keepAspectRatio, nodeOrigin, extent, childExtent) {
  let { affectsX, affectsY } = controlDirection;
  const { isHorizontal, isVertical } = controlDirection;
  const isDiagonal = isHorizontal && isVertical;
  const { xSnapped, ySnapped } = pointerPosition;
  const { minWidth, maxWidth, minHeight, maxHeight } = boundaries;
  const { x: startX, y: startY, width: startWidth, height: startHeight, aspectRatio } = startValues;
  let distX = Math.floor(isHorizontal ? xSnapped - startValues.pointerX : 0);
  let distY = Math.floor(isVertical ? ySnapped - startValues.pointerY : 0);
  const newWidth = startWidth + (affectsX ? -distX : distX);
  const newHeight = startHeight + (affectsY ? -distY : distY);
  const originOffsetX = -nodeOrigin[0] * startWidth;
  const originOffsetY = -nodeOrigin[1] * startHeight;
  let clampX = getSizeClamp(newWidth, minWidth, maxWidth);
  let clampY = getSizeClamp(newHeight, minHeight, maxHeight);
  if (extent) {
    let xExtentClamp = 0;
    let yExtentClamp = 0;
    if (affectsX && distX < 0) {
      xExtentClamp = getLowerExtentClamp(startX + distX + originOffsetX, extent[0][0]);
    } else if (!affectsX && distX > 0) {
      xExtentClamp = getUpperExtentClamp(startX + newWidth + originOffsetX, extent[1][0]);
    }
    if (affectsY && distY < 0) {
      yExtentClamp = getLowerExtentClamp(startY + distY + originOffsetY, extent[0][1]);
    } else if (!affectsY && distY > 0) {
      yExtentClamp = getUpperExtentClamp(startY + newHeight + originOffsetY, extent[1][1]);
    }
    clampX = Math.max(clampX, xExtentClamp);
    clampY = Math.max(clampY, yExtentClamp);
  }
  if (childExtent) {
    let xExtentClamp = 0;
    let yExtentClamp = 0;
    if (affectsX && distX > 0) {
      xExtentClamp = getUpperExtentClamp(startX + distX, childExtent[0][0]);
    } else if (!affectsX && distX < 0) {
      xExtentClamp = getLowerExtentClamp(startX + newWidth, childExtent[1][0]);
    }
    if (affectsY && distY > 0) {
      yExtentClamp = getUpperExtentClamp(startY + distY, childExtent[0][1]);
    } else if (!affectsY && distY < 0) {
      yExtentClamp = getLowerExtentClamp(startY + newHeight, childExtent[1][1]);
    }
    clampX = Math.max(clampX, xExtentClamp);
    clampY = Math.max(clampY, yExtentClamp);
  }
  if (keepAspectRatio) {
    if (isHorizontal) {
      const aspectHeightClamp = getSizeClamp(newWidth / aspectRatio, minHeight, maxHeight) * aspectRatio;
      clampX = Math.max(clampX, aspectHeightClamp);
      if (extent) {
        let aspectExtentClamp = 0;
        if (!affectsX && !affectsY || affectsX && !affectsY && isDiagonal) {
          aspectExtentClamp = getUpperExtentClamp(startY + originOffsetY + newWidth / aspectRatio, extent[1][1]) * aspectRatio;
        } else {
          aspectExtentClamp = getLowerExtentClamp(startY + originOffsetY + (affectsX ? distX : -distX) / aspectRatio, extent[0][1]) * aspectRatio;
        }
        clampX = Math.max(clampX, aspectExtentClamp);
      }
      if (childExtent) {
        let aspectExtentClamp = 0;
        if (!affectsX && !affectsY || affectsX && !affectsY && isDiagonal) {
          aspectExtentClamp = getLowerExtentClamp(startY + newWidth / aspectRatio, childExtent[1][1]) * aspectRatio;
        } else {
          aspectExtentClamp = getUpperExtentClamp(startY + (affectsX ? distX : -distX) / aspectRatio, childExtent[0][1]) * aspectRatio;
        }
        clampX = Math.max(clampX, aspectExtentClamp);
      }
    }
    if (isVertical) {
      const aspectWidthClamp = getSizeClamp(newHeight * aspectRatio, minWidth, maxWidth) / aspectRatio;
      clampY = Math.max(clampY, aspectWidthClamp);
      if (extent) {
        let aspectExtentClamp = 0;
        if (!affectsX && !affectsY || affectsY && !affectsX && isDiagonal) {
          aspectExtentClamp = getUpperExtentClamp(startX + newHeight * aspectRatio + originOffsetX, extent[1][0]) / aspectRatio;
        } else {
          aspectExtentClamp = getLowerExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio + originOffsetX, extent[0][0]) / aspectRatio;
        }
        clampY = Math.max(clampY, aspectExtentClamp);
      }
      if (childExtent) {
        let aspectExtentClamp = 0;
        if (!affectsX && !affectsY || affectsY && !affectsX && isDiagonal) {
          aspectExtentClamp = getLowerExtentClamp(startX + newHeight * aspectRatio, childExtent[1][0]) / aspectRatio;
        } else {
          aspectExtentClamp = getUpperExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio, childExtent[0][0]) / aspectRatio;
        }
        clampY = Math.max(clampY, aspectExtentClamp);
      }
    }
  }
  distY = distY + (distY < 0 ? clampY : -clampY);
  distX = distX + (distX < 0 ? clampX : -clampX);
  if (keepAspectRatio) {
    if (isDiagonal) {
      if (newWidth > newHeight * aspectRatio) {
        distY = (xor(affectsX, affectsY) ? -distX : distX) / aspectRatio;
      } else {
        distX = (xor(affectsX, affectsY) ? -distY : distY) * aspectRatio;
      }
    } else {
      if (isHorizontal) {
        distY = distX / aspectRatio;
        affectsY = affectsX;
      } else {
        distX = distY * aspectRatio;
        affectsX = affectsY;
      }
    }
  }
  const x = affectsX ? startX + distX : startX;
  const y = affectsY ? startY + distY : startY;
  return {
    width: startWidth + (affectsX ? -distX : distX),
    height: startHeight + (affectsY ? -distY : distY),
    x: nodeOrigin[0] * distX * (!affectsX ? 1 : -1) + x,
    y: nodeOrigin[1] * distY * (!affectsY ? 1 : -1) + y
  };
}
var initPrevValues = { width: 0, height: 0, x: 0, y: 0 };
var initStartValues = {
  ...initPrevValues,
  pointerX: 0,
  pointerY: 0,
  aspectRatio: 1
};
function nodeToParentExtent(node) {
  return [
    [0, 0],
    [node.measured.width, node.measured.height]
  ];
}
function nodeToChildExtent(child2, parent, nodeOrigin) {
  const x = parent.position.x + child2.position.x;
  const y = parent.position.y + child2.position.y;
  const width = child2.measured.width ?? 0;
  const height = child2.measured.height ?? 0;
  const originOffsetX = nodeOrigin[0] * width;
  const originOffsetY = nodeOrigin[1] * height;
  return [
    [x - originOffsetX, y - originOffsetY],
    [x + width - originOffsetX, y + height - originOffsetY]
  ];
}
function XYResizer({ domNode, nodeId, getStoreItems, onChange, onEnd }) {
  const selection2 = select_default2(domNode);
  let params = {
    controlDirection: getControlDirection("bottom-right"),
    boundaries: {
      minWidth: 0,
      minHeight: 0,
      maxWidth: Number.MAX_VALUE,
      maxHeight: Number.MAX_VALUE
    },
    resizeDirection: void 0,
    keepAspectRatio: false
  };
  function update({ controlPosition, boundaries, keepAspectRatio, resizeDirection, onResizeStart, onResize, onResizeEnd, shouldResize }) {
    let prevValues = { ...initPrevValues };
    let startValues = { ...initStartValues };
    params = {
      boundaries,
      resizeDirection,
      keepAspectRatio,
      controlDirection: getControlDirection(controlPosition)
    };
    let node = void 0;
    let containerBounds = null;
    let childNodes = [];
    let parentNode = void 0;
    let parentExtent = void 0;
    let childExtent = void 0;
    let resizeDetected = false;
    const dragHandler = drag_default().on("start", (event2) => {
      const { nodeLookup, transform: transform2, snapGrid, snapToGrid, nodeOrigin, paneDomNode } = getStoreItems();
      node = nodeLookup.get(nodeId);
      if (!node) {
        return;
      }
      containerBounds = paneDomNode?.getBoundingClientRect() ?? null;
      const { xSnapped, ySnapped } = getPointerPosition(event2.sourceEvent, {
        transform: transform2,
        snapGrid,
        snapToGrid,
        containerBounds
      });
      prevValues = {
        width: node.measured.width ?? 0,
        height: node.measured.height ?? 0,
        x: node.position.x ?? 0,
        y: node.position.y ?? 0
      };
      startValues = {
        ...prevValues,
        pointerX: xSnapped,
        pointerY: ySnapped,
        aspectRatio: prevValues.width / prevValues.height
      };
      parentNode = void 0;
      if (node.parentId && (node.extent === "parent" || node.expandParent)) {
        parentNode = nodeLookup.get(node.parentId);
        parentExtent = parentNode && node.extent === "parent" ? nodeToParentExtent(parentNode) : void 0;
      }
      childNodes = [];
      childExtent = void 0;
      for (const [childId, child2] of nodeLookup) {
        if (child2.parentId === nodeId) {
          childNodes.push({
            id: childId,
            position: { ...child2.position },
            extent: child2.extent
          });
          if (child2.extent === "parent" || child2.expandParent) {
            const extent = nodeToChildExtent(child2, node, child2.origin ?? nodeOrigin);
            if (childExtent) {
              childExtent = [
                [Math.min(extent[0][0], childExtent[0][0]), Math.min(extent[0][1], childExtent[0][1])],
                [Math.max(extent[1][0], childExtent[1][0]), Math.max(extent[1][1], childExtent[1][1])]
              ];
            } else {
              childExtent = extent;
            }
          }
        }
      }
      onResizeStart?.(event2, { ...prevValues });
    }).on("drag", (event2) => {
      const { transform: transform2, snapGrid, snapToGrid, nodeOrigin: storeNodeOrigin } = getStoreItems();
      const pointerPosition = getPointerPosition(event2.sourceEvent, {
        transform: transform2,
        snapGrid,
        snapToGrid,
        containerBounds
      });
      const childChanges = [];
      if (!node) {
        return;
      }
      const { x: prevX, y: prevY, width: prevWidth, height: prevHeight } = prevValues;
      const change = {};
      const nodeOrigin = node.origin ?? storeNodeOrigin;
      const { width, height, x, y } = getDimensionsAfterResize(startValues, params.controlDirection, pointerPosition, params.boundaries, params.keepAspectRatio, nodeOrigin, parentExtent, childExtent);
      const isWidthChange = width !== prevWidth;
      const isHeightChange = height !== prevHeight;
      const isXPosChange = x !== prevX && isWidthChange;
      const isYPosChange = y !== prevY && isHeightChange;
      if (!isXPosChange && !isYPosChange && !isWidthChange && !isHeightChange) {
        return;
      }
      if (isXPosChange || isYPosChange || nodeOrigin[0] === 1 || nodeOrigin[1] === 1) {
        change.x = isXPosChange ? x : prevValues.x;
        change.y = isYPosChange ? y : prevValues.y;
        prevValues.x = change.x;
        prevValues.y = change.y;
        if (childNodes.length > 0) {
          const xChange = x - prevX;
          const yChange = y - prevY;
          for (const childNode of childNodes) {
            childNode.position = {
              x: childNode.position.x - xChange + nodeOrigin[0] * (width - prevWidth),
              y: childNode.position.y - yChange + nodeOrigin[1] * (height - prevHeight)
            };
            childChanges.push(childNode);
          }
        }
      }
      if (isWidthChange || isHeightChange) {
        change.width = isWidthChange && (!params.resizeDirection || params.resizeDirection === "horizontal") ? width : prevValues.width;
        change.height = isHeightChange && (!params.resizeDirection || params.resizeDirection === "vertical") ? height : prevValues.height;
        prevValues.width = change.width;
        prevValues.height = change.height;
      }
      if (parentNode && node.expandParent) {
        const xLimit = nodeOrigin[0] * (change.width ?? 0);
        if (change.x && change.x < xLimit) {
          prevValues.x = xLimit;
          startValues.x = startValues.x - (change.x - xLimit);
        }
        const yLimit = nodeOrigin[1] * (change.height ?? 0);
        if (change.y && change.y < yLimit) {
          prevValues.y = yLimit;
          startValues.y = startValues.y - (change.y - yLimit);
        }
      }
      const direction = getResizeDirection({
        width: prevValues.width,
        prevWidth,
        height: prevValues.height,
        prevHeight,
        affectsX: params.controlDirection.affectsX,
        affectsY: params.controlDirection.affectsY
      });
      const nextValues = { ...prevValues, direction };
      const callResize = shouldResize?.(event2, nextValues);
      if (callResize === false) {
        return;
      }
      resizeDetected = true;
      onResize?.(event2, nextValues);
      onChange(change, childChanges);
    }).on("end", (event2) => {
      if (!resizeDetected) {
        return;
      }
      onResizeEnd?.(event2, { ...prevValues });
      onEnd?.({ ...prevValues });
      resizeDetected = false;
    });
    selection2.call(dragHandler);
  }
  function destroy() {
    selection2.on(".drag", null);
  }
  return {
    update,
    destroy
  };
}

// node_modules/@xyflow/svelte/dist/lib/components/Handle/Handle.svelte
Handle[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/Handle/Handle.svelte";
var root2 = add_locations(from_html(`<div><!></div>`), Handle[FILENAME], [[204, 0]]);
function Handle($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Handle);
  let handleId = prop($$props, "id", 3, null), type = prop($$props, "type", 3, "source"), position = prop($$props, "position", 19, () => Position.Top), isConnectableStart = prop($$props, "isConnectableStart", 3, true), isConnectableEnd = prop($$props, "isConnectableEnd", 3, true), rest = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "type",
      "position",
      "style",
      "class",
      "isConnectable",
      "isConnectableStart",
      "isConnectableEnd",
      "isValidConnection",
      "onconnect",
      "ondisconnect",
      "children"
    ],
    "rest"
  );
  const nodeId = getContext("svelteflow__node_id");
  const isConnectableContext = getContext("svelteflow__node_connectable");
  let isTarget = tag(user_derived(() => strict_equals(type(), "target")), "isTarget");
  let isConnectable = tag(user_derived(() => strict_equals($$props.isConnectable, void 0, false) ? $$props.isConnectable : isConnectableContext.value), "isConnectable");
  let store = useStore();
  let ariaLabelConfig = tag(user_derived(() => store.ariaLabelConfig), "ariaLabelConfig");
  let prevConnections = null;
  user_pre_effect(() => {
    if ($$props.onconnect || $$props.ondisconnect) {
      store.edges;
      let connections = store.connectionLookup.get(`${nodeId}-${type()}${handleId() ? `-${handleId()}` : ""}`);
      if (prevConnections && !areConnectionMapsEqual(connections, prevConnections)) {
        const _connections = connections ?? /* @__PURE__ */ new Map();
        handleConnectionChange(prevConnections, _connections, $$props.ondisconnect);
        handleConnectionChange(_connections, prevConnections, $$props.onconnect);
      }
      prevConnections = new Map(connections);
    }
  });
  let $$d = tag(
    user_derived(() => {
      if (!store.connection.inProgress) {
        return [false, false, false, false, null];
      }
      const { fromHandle, toHandle, isValid } = store.connection;
      const connectingFrom2 = fromHandle && strict_equals(fromHandle.nodeId, nodeId) && strict_equals(fromHandle.type, type()) && strict_equals(fromHandle.id, handleId());
      const connectingTo2 = toHandle && strict_equals(toHandle.nodeId, nodeId) && strict_equals(toHandle.type, type()) && strict_equals(toHandle.id, handleId());
      const isPossibleTargetHandle2 = strict_equals(store.connectionMode, ConnectionMode.Strict) ? strict_equals(fromHandle?.type, type(), false) : strict_equals(nodeId, fromHandle?.nodeId, false) || strict_equals(handleId(), fromHandle?.id, false);
      const valid2 = connectingTo2 && isValid;
      return [
        true,
        connectingFrom2,
        connectingTo2,
        isPossibleTargetHandle2,
        valid2
      ];
    }),
    "[$derived iterable]"
  ), $$array = tag(user_derived(() => to_array(get($$d), 5)), "[$derived iterable]"), connectionInProgress = tag(user_derived(() => get($$array)[0]), "connectionInProgress"), connectingFrom = tag(user_derived(() => get($$array)[1]), "connectingFrom"), connectingTo = tag(user_derived(() => get($$array)[2]), "connectingTo"), isPossibleTargetHandle = tag(user_derived(() => get($$array)[3]), "isPossibleTargetHandle"), valid = tag(user_derived(() => get($$array)[4]), "valid");
  function onConnectExtended(connection) {
    const edge = store.onbeforeconnect ? store.onbeforeconnect(connection) : connection;
    if (!edge) {
      return;
    }
    store.addEdge(edge);
    store.onconnect?.(connection);
  }
  function onpointerdown(event2) {
    const isMouseTriggered = isMouseEvent(event2);
    if (event2.currentTarget && (isMouseTriggered && strict_equals(event2.button, 0) || !isMouseTriggered)) {
      XYHandle.onPointerDown(event2, {
        handleId: handleId(),
        nodeId,
        isTarget: get(isTarget),
        connectionRadius: store.connectionRadius,
        domNode: store.domNode,
        nodeLookup: store.nodeLookup,
        connectionMode: store.connectionMode,
        lib: "svelte",
        autoPanOnConnect: store.autoPanOnConnect,
        autoPanSpeed: store.autoPanSpeed,
        flowId: store.flowId,
        isValidConnection: $$props.isValidConnection ?? store.isValidConnection,
        updateConnection: store.updateConnection,
        cancelConnection: store.cancelConnection,
        panBy: store.panBy,
        onConnect: onConnectExtended,
        onConnectStart: (event3, startParams) => {
          store.onconnectstart?.(event3, {
            nodeId: startParams.nodeId,
            handleId: startParams.handleId,
            handleType: startParams.handleType
          });
        },
        onConnectEnd: (event3, connectionState) => {
          store.onconnectend?.(event3, connectionState);
        },
        getTransform: () => [store.viewport.x, store.viewport.y, store.viewport.zoom],
        getFromHandle: () => store.connection.fromHandle,
        dragThreshold: store.connectionDragThreshold,
        handleDomNode: event2.currentTarget
      });
    }
  }
  function onclick(event2) {
    if (!nodeId || !store.clickConnectStartHandle && !isConnectableStart()) {
      return;
    }
    if (!store.clickConnectStartHandle) {
      store.onclickconnectstart?.(event2, { nodeId, handleId: handleId(), handleType: type() });
      store.clickConnectStartHandle = { nodeId, type: type(), id: handleId() };
      return;
    }
    const doc = getHostForElement(event2.target);
    const isValidConnectionHandler = $$props.isValidConnection ?? store.isValidConnection;
    const { connectionMode, clickConnectStartHandle, flowId, nodeLookup } = store;
    const { connection, isValid } = XYHandle.isValid(event2, {
      handle: { nodeId, id: handleId(), type: type() },
      connectionMode,
      fromNodeId: clickConnectStartHandle.nodeId,
      fromHandleId: clickConnectStartHandle.id ?? null,
      fromType: clickConnectStartHandle.type,
      isValidConnection: isValidConnectionHandler,
      flowId,
      doc,
      lib: "svelte",
      nodeLookup
    });
    if (isValid && connection) {
      onConnectExtended(connection);
    }
    const connectionClone = structuredClone(snapshot(store.connection));
    delete connectionClone.inProgress;
    connectionClone.toPosition = connectionClone.toHandle ? connectionClone.toHandle.position : null;
    store.onclickconnectend?.(event2, connectionClone);
    store.clickConnectStartHandle = null;
  }
  var $$exports = { ...legacy_api() };
  var div = root2();
  var event_handler = () => {
  };
  attribute_effect(div, () => ({
    "data-handleid": handleId(),
    "data-nodeid": nodeId,
    "data-handlepos": position(),
    "data-id": `${store.flowId ?? ""}-${nodeId ?? ""}-${handleId() ?? "null" ?? ""}-${type() ?? ""}`,
    class: [
      "svelte-flow__handle",
      `svelte-flow__handle-${position()}`,
      store.noDragClass,
      store.noPanClass,
      position(),
      $$props.class
    ],
    onmousedown: onpointerdown,
    ontouchstart: onpointerdown,
    onclick: store.clickConnect ? onclick : void 0,
    onkeypress: event_handler,
    style: $$props.style,
    role: "button",
    "aria-label": get(ariaLabelConfig)[`handle.ariaLabel`],
    tabindex: "-1",
    ...rest,
    [CLASS]: {
      valid: get(valid),
      connectingto: get(connectingTo),
      connectingfrom: get(connectingFrom),
      source: !get(isTarget),
      target: get(isTarget),
      connectablestart: isConnectableStart(),
      connectableend: isConnectableEnd(),
      connectable: get(isConnectable),
      connectionindicator: get(isConnectable) && (!get(connectionInProgress) || get(isPossibleTargetHandle)) && (get(connectionInProgress) || store.clickConnectStartHandle ? isConnectableEnd() : isConnectableStart())
    }
  }));
  var node = child(div);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop), "render", Handle, 238, 2);
  reset(div);
  append($$anchor, div);
  return pop($$exports);
}
if (import.meta.hot) {
  Handle = hmr(Handle, () => Handle[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Handle[HMR].source;
    set(Handle[HMR].source, module.default[HMR].original);
  });
}
var Handle_default = Handle;

// node_modules/@xyflow/svelte/dist/lib/components/nodes/DefaultNode.svelte
DefaultNode[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/nodes/DefaultNode.svelte";
var root3 = add_locations(from_html(`<!> <!>`, 1), DefaultNode[FILENAME], []);
function DefaultNode($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, DefaultNode);
  let targetPosition = prop($$props, "targetPosition", 19, () => Position.Top), sourcePosition = prop($$props, "sourcePosition", 19, () => Position.Bottom);
  var $$exports = { ...legacy_api() };
  var fragment = root3();
  var node = first_child(fragment);
  add_svelte_meta(
    () => Handle_default(node, {
      type: "target",
      get position() {
        return targetPosition();
      }
    }),
    "component",
    DefaultNode,
    14,
    0,
    { componentTag: "Handle" }
  );
  var text2 = sibling(node);
  var node_1 = sibling(text2);
  add_svelte_meta(
    () => Handle_default(node_1, {
      type: "source",
      get position() {
        return sourcePosition();
      }
    }),
    "component",
    DefaultNode,
    16,
    0,
    { componentTag: "Handle" }
  );
  template_effect(() => set_text(text2, ` ${$$props.data?.label ?? ""} `));
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  DefaultNode = hmr(DefaultNode, () => DefaultNode[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DefaultNode[HMR].source;
    set(DefaultNode[HMR].source, module.default[HMR].original);
  });
}
var DefaultNode_default = DefaultNode;

// node_modules/@xyflow/svelte/dist/lib/components/nodes/InputNode.svelte
InputNode[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/nodes/InputNode.svelte";
var root4 = add_locations(from_html(` <!>`, 1), InputNode[FILENAME], []);
function InputNode($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, InputNode);
  let data = prop($$props, "data", 19, () => ({ label: "Node" })), sourcePosition = prop($$props, "sourcePosition", 19, () => Position.Bottom);
  var $$exports = { ...legacy_api() };
  next();
  var fragment = root4();
  var text2 = first_child(fragment);
  var node = sibling(text2);
  add_svelte_meta(
    () => Handle_default(node, {
      type: "source",
      get position() {
        return sourcePosition();
      }
    }),
    "component",
    InputNode,
    11,
    0,
    { componentTag: "Handle" }
  );
  template_effect(() => set_text(text2, `${data()?.label ?? ""} `));
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  InputNode = hmr(InputNode, () => InputNode[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InputNode[HMR].source;
    set(InputNode[HMR].source, module.default[HMR].original);
  });
}
var InputNode_default = InputNode;

// node_modules/@xyflow/svelte/dist/lib/components/nodes/OutputNode.svelte
OutputNode[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/nodes/OutputNode.svelte";
var root5 = add_locations(from_html(` <!>`, 1), OutputNode[FILENAME], []);
function OutputNode($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, OutputNode);
  let data = prop($$props, "data", 19, () => ({ label: "Node" })), targetPosition = prop($$props, "targetPosition", 19, () => Position.Top);
  var $$exports = { ...legacy_api() };
  next();
  var fragment = root5();
  var text2 = first_child(fragment);
  var node = sibling(text2);
  add_svelte_meta(
    () => Handle_default(node, {
      type: "target",
      get position() {
        return targetPosition();
      }
    }),
    "component",
    OutputNode,
    11,
    0,
    { componentTag: "Handle" }
  );
  template_effect(() => set_text(text2, `${data()?.label ?? ""} `));
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  OutputNode = hmr(OutputNode, () => OutputNode[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = OutputNode[HMR].source;
    set(OutputNode[HMR].source, module.default[HMR].original);
  });
}
var OutputNode_default = OutputNode;

// node_modules/@xyflow/svelte/dist/lib/components/nodes/GroupNode.svelte
GroupNode[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/nodes/GroupNode.svelte";
function GroupNode($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, GroupNode);
  var $$exports = { ...legacy_api() };
  return pop($$exports);
}
if (import.meta.hot) {
  GroupNode = hmr(GroupNode, () => GroupNode[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = GroupNode[HMR].source;
    set(GroupNode[HMR].source, module.default[HMR].original);
  });
}
var GroupNode_default = GroupNode;

// node_modules/@xyflow/svelte/dist/lib/actions/portal/portal.svelte.js
function tryToMount(node, domNode, target) {
  if (!target || !domNode) {
    return;
  }
  const targetEl = strict_equals(target, "root") ? domNode : domNode.querySelector(`.svelte-flow__${target}`);
  if (targetEl) {
    targetEl.appendChild(node);
  }
}
function portal(node, target) {
  const $$d = tag(user_derived(useStore), "[$derived object]"), domNode = tag(user_derived(() => get($$d).domNode), "domNode");
  let destroyEffect;
  if (get(domNode)) {
    tryToMount(node, get(domNode), target);
  } else {
    destroyEffect = effect_root(() => {
      user_effect(() => {
        tryToMount(node, get(domNode), target);
        destroyEffect?.();
      });
    });
  }
  return {
    async update(target2) {
      tryToMount(node, get(domNode), target2);
    },
    destroy() {
      if (node.parentNode) {
        node.parentNode.removeChild(node);
      }
      destroyEffect?.();
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/actions/portal/utils.svelte.js
function hideOnSSR() {
  let hide = tag(state(proxy(strict_equals(typeof window, "undefined"))), "hide");
  if (get(hide)) {
    const destroyEffect = effect_root(() => {
      user_effect(() => {
        set(hide, false);
        destroyEffect?.();
      });
    });
  }
  return {
    get value() {
      return get(hide);
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/utils/index.js
var isNode = (element) => isNodeBase(element);
var isEdge = (element) => isEdgeBase(element);
function toPxString(value) {
  return value === void 0 ? void 0 : `${value}px`;
}
var arrowKeyDiffs = {
  ArrowUp: { x: 0, y: -1 },
  ArrowDown: { x: 0, y: 1 },
  ArrowLeft: { x: -1, y: 0 },
  ArrowRight: { x: 1, y: 0 }
};

// node_modules/@xyflow/svelte/dist/lib/components/EdgeLabel/EdgeLabel.svelte
EdgeLabel[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/EdgeLabel/EdgeLabel.svelte";
var root6 = add_locations(from_html(`<div><!></div>`), EdgeLabel[FILENAME], [[31, 0]]);
var $$css = {
  hash: "s-rSqMSqQbyZC9",
  code: "\n  .transparent.s-rSqMSqQbyZC9 {\n    background: transparent;\n  }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRWRnZUxhYmVsLnN2ZWx0ZSIsInNvdXJjZXMiOlsiRWRnZUxhYmVsLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuICBpbXBvcnQgeyBnZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcblxuICBpbXBvcnQgeyBoaWRlT25TU1IsIHBvcnRhbCB9IGZyb20gJy4uLy4uL2FjdGlvbnMvcG9ydGFsJztcbiAgaW1wb3J0IHsgdXNlU3RvcmUgfSBmcm9tICcuLi8uLi9zdG9yZSc7XG4gIGltcG9ydCB0eXBlIHsgRWRnZUxhYmVsUHJvcHMgfSBmcm9tICcuL3R5cGVzJztcbiAgaW1wb3J0IHsgdG9QeFN0cmluZyB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuICBsZXQge1xuICAgIHggPSAwLFxuICAgIHkgPSAwLFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBzZWxlY3RFZGdlT25DbGljayA9IGZhbHNlLFxuICAgIHRyYW5zcGFyZW50ID0gZmFsc2UsXG4gICAgY2xhc3M6IGNsYXNzTmFtZSxcbiAgICBjaGlsZHJlbixcbiAgICAuLi5yZXN0XG4gIH06IEVkZ2VMYWJlbFByb3BzID0gJHByb3BzKCk7XG5cbiAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZSgpO1xuICBjb25zdCBlZGdlSWQgPSBnZXRDb250ZXh0PHN0cmluZz4oJ3N2ZWx0ZWZsb3dfX2VkZ2VfaWQnKTtcblxuICBpZiAoIWVkZ2VJZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRWRnZUxhYmVsIG11c3QgYmUgdXNlZCB3aXRoaW4gYW4gZWRnZScpO1xuICB9XG5cbiAgbGV0IHogPSAkZGVyaXZlZChzdG9yZS52aXNpYmxlLmVkZ2VzLmdldChlZGdlSWQpPy56SW5kZXgpO1xuPC9zY3JpcHQ+XG5cbjxkaXZcbiAgdXNlOnBvcnRhbD17J2VkZ2UtbGFiZWxzJ31cbiAgc3R5bGU6ZGlzcGxheT17aGlkZU9uU1NSKCkudmFsdWUgPyAnbm9uZScgOiB1bmRlZmluZWR9XG4gIGNsYXNzPXtbJ3N2ZWx0ZS1mbG93X19lZGdlLWxhYmVsJywgeyB0cmFuc3BhcmVudCB9LCBjbGFzc05hbWVdfVxuICBzdHlsZTpjdXJzb3I9e3NlbGVjdEVkZ2VPbkNsaWNrID8gJ3BvaW50ZXInIDogdW5kZWZpbmVkfVxuICBzdHlsZTp0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoLTUwJSwgLTUwJSkgdHJhbnNsYXRlKHt4fXB4LHt5fXB4KVwiXG4gIHN0eWxlOnBvaW50ZXItZXZlbnRzPVwiYWxsXCJcbiAgc3R5bGU6d2lkdGg9e3RvUHhTdHJpbmcod2lkdGgpfVxuICBzdHlsZTpoZWlnaHQ9e3RvUHhTdHJpbmcoaGVpZ2h0KX1cbiAgc3R5bGU6ei1pbmRleD17en1cbiAgdGFiaW5kZXg9XCItMVwiXG4gIG9uY2xpY2s9eygpID0+IHtcbiAgICBpZiAoc2VsZWN0RWRnZU9uQ2xpY2spIHN0b3JlLmhhbmRsZUVkZ2VTZWxlY3Rpb24oZWRnZUlkKTtcbiAgfX1cbiAgey4uLnJlc3R9XG4+XG4gIHtAcmVuZGVyIGNoaWxkcmVuPy4oKX1cbjwvZGl2PlxuXG48c3R5bGU+XG4gIC50cmFuc3BhcmVudCB7XG4gICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gIH1cbjwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImlnbm9yZUxpc3QiOltdfQ== */"
};
function EdgeLabel($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, EdgeLabel);
  append_styles($$anchor, $$css);
  let x = prop($$props, "x", 3, 0), y = prop($$props, "y", 3, 0), selectEdgeOnClick = prop($$props, "selectEdgeOnClick", 3, false), transparent = prop($$props, "transparent", 3, false), rest = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "x",
      "y",
      "width",
      "height",
      "selectEdgeOnClick",
      "transparent",
      "class",
      "children"
    ],
    "rest"
  );
  const store = useStore();
  const edgeId = getContext("svelteflow__edge_id");
  if (!edgeId) {
    throw new Error("EdgeLabel must be used within an edge");
  }
  let z = tag(user_derived(() => store.visible.edges.get(edgeId)?.zIndex), "z");
  var $$exports = { ...legacy_api() };
  var div = root6();
  var event_handler = () => {
    if (selectEdgeOnClick()) store.handleEdgeSelection(edgeId);
  };
  attribute_effect(
    div,
    ($0) => ({
      class: [
        "svelte-flow__edge-label",
        { transparent: transparent() },
        $$props.class
      ],
      tabindex: "-1",
      onclick: event_handler,
      ...rest,
      [STYLE]: $0
    }),
    [
      () => ({
        display: hideOnSSR().value ? "none" : void 0,
        cursor: selectEdgeOnClick() ? "pointer" : void 0,
        transform: `translate(-50%, -50%) translate(${x() ?? ""}px,${y() ?? ""}px)`,
        "pointer-events": "all",
        width: toPxString($$props.width),
        height: toPxString($$props.height),
        "z-index": get(z)
      })
    ],
    void 0,
    void 0,
    "s-rSqMSqQbyZC9"
  );
  var node = child(div);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop), "render", EdgeLabel, 47, 2);
  reset(div);
  action(div, ($$node, $$action_arg) => portal?.($$node, $$action_arg), () => "edge-labels");
  append($$anchor, div);
  return pop($$exports);
}
if (import.meta.hot) {
  EdgeLabel = hmr(EdgeLabel, () => EdgeLabel[HMR].source);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-rSqMSqQbyZC9");
    module.default[HMR].source = EdgeLabel[HMR].source;
    set(EdgeLabel[HMR].source, module.default[HMR].original);
  });
}
var EdgeLabel_default = EdgeLabel;

// node_modules/@xyflow/svelte/dist/lib/components/edges/BaseEdge.svelte
BaseEdge[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/edges/BaseEdge.svelte";
var root_1 = add_locations(from_svg(`<path></path>`), BaseEdge[FILENAME], [[32, 2]]);
var root7 = add_locations(from_svg(`<path fill="none"></path><!><!>`, 1), BaseEdge[FILENAME], [[21, 0]]);
function BaseEdge($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, BaseEdge);
  let interactionWidth = prop($$props, "interactionWidth", 3, 20), rest = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "path",
      "label",
      "labelX",
      "labelY",
      "labelStyle",
      "markerStart",
      "markerEnd",
      "style",
      "interactionWidth",
      "class"
    ],
    "rest"
  );
  var $$exports = { ...legacy_api() };
  var fragment = root7();
  var path_1 = first_child(fragment);
  var node = sibling(path_1);
  {
    var consequent = ($$anchor2) => {
      var path_2 = root_1();
      attribute_effect(path_2, () => ({
        d: $$props.path,
        "stroke-opacity": 0,
        "stroke-width": interactionWidth(),
        fill: "none",
        class: "svelte-flow__edge-interaction",
        ...rest
      }));
      append($$anchor2, path_2);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (interactionWidth() > 0) $$render(consequent);
      }),
      "if",
      BaseEdge,
      31,
      0
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_2 = first_child(fragment_1);
      add_svelte_meta(
        () => EdgeLabel_default(node_2, {
          get x() {
            return $$props.labelX;
          },
          get y() {
            return $$props.labelY;
          },
          get style() {
            return $$props.labelStyle;
          },
          selectEdgeOnClick: true,
          children: wrap_snippet(BaseEdge, ($$anchor3, $$slotProps) => {
            next();
            var text2 = text();
            template_effect(() => set_text(text2, $$props.label));
            append($$anchor3, text2);
          }),
          $$slots: { default: true }
        }),
        "component",
        BaseEdge,
        43,
        2,
        { componentTag: "EdgeLabel" }
      );
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        if ($$props.label) $$render(consequent_1);
      }),
      "if",
      BaseEdge,
      42,
      0
    );
  }
  template_effect(() => {
    set_attribute(path_1, "id", $$props.id);
    set_attribute(path_1, "d", $$props.path);
    set_class(path_1, 0, clsx(["svelte-flow__edge-path", $$props.class]));
    set_attribute(path_1, "marker-start", $$props.markerStart);
    set_attribute(path_1, "marker-end", $$props.markerEnd);
    set_style(path_1, $$props.style);
  });
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  BaseEdge = hmr(BaseEdge, () => BaseEdge[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BaseEdge[HMR].source;
    set(BaseEdge[HMR].source, module.default[HMR].original);
  });
}
var BaseEdge_default = BaseEdge;

// node_modules/@xyflow/svelte/dist/lib/components/edges/BezierEdge.svelte
BezierEdge[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/edges/BezierEdge.svelte";
function BezierEdge($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, BezierEdge);
  let $$d = tag(
    user_derived(() => getBezierPath({
      sourceX: $$props.sourceX,
      sourceY: $$props.sourceY,
      targetX: $$props.targetX,
      targetY: $$props.targetY,
      sourcePosition: $$props.sourcePosition,
      targetPosition: $$props.targetPosition,
      curvature: $$props.pathOptions?.curvature
    })),
    "[$derived iterable]"
  ), $$array = tag(user_derived(() => to_array(get($$d), 3)), "[$derived iterable]"), path = tag(user_derived(() => get($$array)[0]), "path"), labelX = tag(user_derived(() => get($$array)[1]), "labelX"), labelY = tag(user_derived(() => get($$array)[2]), "labelY");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => BaseEdge_default(node, {
      get id() {
        return $$props.id;
      },
      get path() {
        return get(path);
      },
      get labelX() {
        return get(labelX);
      },
      get labelY() {
        return get(labelY);
      },
      get label() {
        return $$props.label;
      },
      get labelStyle() {
        return $$props.labelStyle;
      },
      get markerStart() {
        return $$props.markerStart;
      },
      get markerEnd() {
        return $$props.markerEnd;
      },
      get interactionWidth() {
        return $$props.interactionWidth;
      },
      get style() {
        return $$props.style;
      }
    }),
    "component",
    BezierEdge,
    37,
    0,
    { componentTag: "BaseEdge" }
  );
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  BezierEdge = hmr(BezierEdge, () => BezierEdge[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BezierEdge[HMR].source;
    set(BezierEdge[HMR].source, module.default[HMR].original);
  });
}
var BezierEdge_default = BezierEdge;

// node_modules/@xyflow/svelte/dist/lib/components/edges/SmoothStepEdge.svelte
SmoothStepEdge[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/edges/SmoothStepEdge.svelte";
function SmoothStepEdge($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, SmoothStepEdge);
  let $$d = tag(
    user_derived(() => getSmoothStepPath({
      sourceX: $$props.sourceX,
      sourceY: $$props.sourceY,
      targetX: $$props.targetX,
      targetY: $$props.targetY,
      sourcePosition: $$props.sourcePosition,
      targetPosition: $$props.targetPosition,
      borderRadius: $$props.pathOptions?.borderRadius,
      offset: $$props.pathOptions?.offset,
      stepPosition: $$props.pathOptions?.stepPosition
    })),
    "[$derived iterable]"
  ), $$array = tag(user_derived(() => to_array(get($$d), 3)), "[$derived iterable]"), path = tag(user_derived(() => get($$array)[0]), "path"), labelX = tag(user_derived(() => get($$array)[1]), "labelX"), labelY = tag(user_derived(() => get($$array)[2]), "labelY");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => BaseEdge_default(node, {
      get id() {
        return $$props.id;
      },
      get path() {
        return get(path);
      },
      get labelX() {
        return get(labelX);
      },
      get labelY() {
        return get(labelY);
      },
      get label() {
        return $$props.label;
      },
      get labelStyle() {
        return $$props.labelStyle;
      },
      get markerStart() {
        return $$props.markerStart;
      },
      get markerEnd() {
        return $$props.markerEnd;
      },
      get interactionWidth() {
        return $$props.interactionWidth;
      },
      get style() {
        return $$props.style;
      }
    }),
    "component",
    SmoothStepEdge,
    39,
    0,
    { componentTag: "BaseEdge" }
  );
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  SmoothStepEdge = hmr(SmoothStepEdge, () => SmoothStepEdge[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SmoothStepEdge[HMR].source;
    set(SmoothStepEdge[HMR].source, module.default[HMR].original);
  });
}
var SmoothStepEdge_default = SmoothStepEdge;

// node_modules/@xyflow/svelte/dist/lib/components/edges/SmoothStepEdgeInternal.svelte
SmoothStepEdgeInternal[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/edges/SmoothStepEdgeInternal.svelte";
function SmoothStepEdgeInternal($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, SmoothStepEdgeInternal);
  let $$d = tag(
    user_derived(() => getSmoothStepPath({
      sourceX: $$props.sourceX,
      sourceY: $$props.sourceY,
      targetX: $$props.targetX,
      targetY: $$props.targetY,
      sourcePosition: $$props.sourcePosition,
      targetPosition: $$props.targetPosition
    })),
    "[$derived iterable]"
  ), $$array = tag(user_derived(() => to_array(get($$d), 3)), "[$derived iterable]"), path = tag(user_derived(() => get($$array)[0]), "path"), labelX = tag(user_derived(() => get($$array)[1]), "labelX"), labelY = tag(user_derived(() => get($$array)[2]), "labelY");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => BaseEdge_default(node, {
      get path() {
        return get(path);
      },
      get labelX() {
        return get(labelX);
      },
      get labelY() {
        return get(labelY);
      },
      get label() {
        return $$props.label;
      },
      get labelStyle() {
        return $$props.labelStyle;
      },
      get markerStart() {
        return $$props.markerStart;
      },
      get markerEnd() {
        return $$props.markerEnd;
      },
      get interactionWidth() {
        return $$props.interactionWidth;
      },
      get style() {
        return $$props.style;
      }
    }),
    "component",
    SmoothStepEdgeInternal,
    34,
    0,
    { componentTag: "BaseEdge" }
  );
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  SmoothStepEdgeInternal = hmr(SmoothStepEdgeInternal, () => SmoothStepEdgeInternal[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SmoothStepEdgeInternal[HMR].source;
    set(SmoothStepEdgeInternal[HMR].source, module.default[HMR].original);
  });
}
var SmoothStepEdgeInternal_default = SmoothStepEdgeInternal;

// node_modules/@xyflow/svelte/dist/lib/components/edges/StraightEdge.svelte
StraightEdge[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/edges/StraightEdge.svelte";
function StraightEdge($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, StraightEdge);
  let $$d = tag(
    user_derived(() => getStraightPath({
      sourceX: $$props.sourceX,
      sourceY: $$props.sourceY,
      targetX: $$props.targetX,
      targetY: $$props.targetY
    })),
    "[$derived iterable]"
  ), $$array = tag(user_derived(() => to_array(get($$d), 3)), "[$derived iterable]"), path = tag(user_derived(() => get($$array)[0]), "path"), labelX = tag(user_derived(() => get($$array)[1]), "labelX"), labelY = tag(user_derived(() => get($$array)[2]), "labelY");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => BaseEdge_default(node, {
      get id() {
        return $$props.id;
      },
      get path() {
        return get(path);
      },
      get labelX() {
        return get(labelX);
      },
      get labelY() {
        return get(labelY);
      },
      get label() {
        return $$props.label;
      },
      get labelStyle() {
        return $$props.labelStyle;
      },
      get markerStart() {
        return $$props.markerStart;
      },
      get markerEnd() {
        return $$props.markerEnd;
      },
      get interactionWidth() {
        return $$props.interactionWidth;
      },
      get style() {
        return $$props.style;
      }
    }),
    "component",
    StraightEdge,
    31,
    0,
    { componentTag: "BaseEdge" }
  );
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  StraightEdge = hmr(StraightEdge, () => StraightEdge[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = StraightEdge[HMR].source;
    set(StraightEdge[HMR].source, module.default[HMR].original);
  });
}
var StraightEdge_default = StraightEdge;

// node_modules/@xyflow/svelte/dist/lib/components/edges/StraightEdgeInternal.svelte
StraightEdgeInternal[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/edges/StraightEdgeInternal.svelte";
function StraightEdgeInternal($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, StraightEdgeInternal);
  let $$d = tag(
    user_derived(() => getStraightPath({
      sourceX: $$props.sourceX,
      sourceY: $$props.sourceY,
      targetX: $$props.targetX,
      targetY: $$props.targetY
    })),
    "[$derived iterable]"
  ), $$array = tag(user_derived(() => to_array(get($$d), 3)), "[$derived iterable]"), path = tag(user_derived(() => get($$array)[0]), "path"), labelX = tag(user_derived(() => get($$array)[1]), "labelX"), labelY = tag(user_derived(() => get($$array)[2]), "labelY");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => BaseEdge_default(node, {
      get path() {
        return get(path);
      },
      get labelX() {
        return get(labelX);
      },
      get labelY() {
        return get(labelY);
      },
      get label() {
        return $$props.label;
      },
      get labelStyle() {
        return $$props.labelStyle;
      },
      get markerStart() {
        return $$props.markerStart;
      },
      get markerEnd() {
        return $$props.markerEnd;
      },
      get interactionWidth() {
        return $$props.interactionWidth;
      },
      get style() {
        return $$props.style;
      }
    }),
    "component",
    StraightEdgeInternal,
    30,
    0,
    { componentTag: "BaseEdge" }
  );
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  StraightEdgeInternal = hmr(StraightEdgeInternal, () => StraightEdgeInternal[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = StraightEdgeInternal[HMR].source;
    set(StraightEdgeInternal[HMR].source, module.default[HMR].original);
  });
}
var StraightEdgeInternal_default = StraightEdgeInternal;

// node_modules/@xyflow/svelte/dist/lib/components/edges/StepEdge.svelte
StepEdge[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/edges/StepEdge.svelte";
function StepEdge($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, StepEdge);
  let $$d = tag(
    user_derived(() => getSmoothStepPath({
      sourceX: $$props.sourceX,
      sourceY: $$props.sourceY,
      targetX: $$props.targetX,
      targetY: $$props.targetY,
      sourcePosition: $$props.sourcePosition,
      targetPosition: $$props.targetPosition,
      borderRadius: 0,
      offset: $$props.pathOptions?.offset
    })),
    "[$derived iterable]"
  ), $$array = tag(user_derived(() => to_array(get($$d), 3)), "[$derived iterable]"), path = tag(user_derived(() => get($$array)[0]), "path"), labelX = tag(user_derived(() => get($$array)[1]), "labelX"), labelY = tag(user_derived(() => get($$array)[2]), "labelY");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => BaseEdge_default(node, {
      get id() {
        return $$props.id;
      },
      get path() {
        return get(path);
      },
      get labelX() {
        return get(labelX);
      },
      get labelY() {
        return get(labelY);
      },
      get label() {
        return $$props.label;
      },
      get labelStyle() {
        return $$props.labelStyle;
      },
      get markerStart() {
        return $$props.markerStart;
      },
      get markerEnd() {
        return $$props.markerEnd;
      },
      get interactionWidth() {
        return $$props.interactionWidth;
      },
      get style() {
        return $$props.style;
      }
    }),
    "component",
    StepEdge,
    38,
    0,
    { componentTag: "BaseEdge" }
  );
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  StepEdge = hmr(StepEdge, () => StepEdge[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = StepEdge[HMR].source;
    set(StepEdge[HMR].source, module.default[HMR].original);
  });
}
var StepEdge_default = StepEdge;

// node_modules/@xyflow/svelte/dist/lib/components/edges/StepEdgeInternal.svelte
StepEdgeInternal[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/edges/StepEdgeInternal.svelte";
function StepEdgeInternal($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, StepEdgeInternal);
  let $$d = tag(
    user_derived(() => getSmoothStepPath({
      sourceX: $$props.sourceX,
      sourceY: $$props.sourceY,
      targetX: $$props.targetX,
      targetY: $$props.targetY,
      sourcePosition: $$props.sourcePosition,
      targetPosition: $$props.targetPosition,
      borderRadius: 0
    })),
    "[$derived iterable]"
  ), $$array = tag(user_derived(() => to_array(get($$d), 3)), "[$derived iterable]"), path = tag(user_derived(() => get($$array)[0]), "path"), labelX = tag(user_derived(() => get($$array)[1]), "labelX"), labelY = tag(user_derived(() => get($$array)[2]), "labelY");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => BaseEdge_default(node, {
      get path() {
        return get(path);
      },
      get labelX() {
        return get(labelX);
      },
      get labelY() {
        return get(labelY);
      },
      get label() {
        return $$props.label;
      },
      get labelStyle() {
        return $$props.labelStyle;
      },
      get markerStart() {
        return $$props.markerStart;
      },
      get markerEnd() {
        return $$props.markerEnd;
      },
      get interactionWidth() {
        return $$props.interactionWidth;
      },
      get style() {
        return $$props.style;
      }
    }),
    "component",
    StepEdgeInternal,
    35,
    0,
    { componentTag: "BaseEdge" }
  );
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  StepEdgeInternal = hmr(StepEdgeInternal, () => StepEdgeInternal[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = StepEdgeInternal[HMR].source;
    set(StepEdgeInternal[HMR].source, module.default[HMR].original);
  });
}
var StepEdgeInternal_default = StepEdgeInternal;

// node_modules/@xyflow/svelte/dist/lib/store/visibleElements.js
function getVisibleNodes(nodeLookup, transform2, width, height) {
  const visibleNodes = /* @__PURE__ */ new Map();
  getNodesInside(nodeLookup, { x: 0, y: 0, width, height }, transform2, true).forEach((node) => {
    visibleNodes.set(node.id, node);
  });
  return visibleNodes;
}
function getLayoutedEdges(options) {
  const { edges, defaultEdgeOptions, nodeLookup, previousEdges, connectionMode, onerror, onlyRenderVisible, elevateEdgesOnSelect } = options;
  const layoutedEdges = /* @__PURE__ */ new Map();
  for (const edge of edges) {
    const sourceNode = nodeLookup.get(edge.source);
    const targetNode = nodeLookup.get(edge.target);
    if (!sourceNode || !targetNode) {
      continue;
    }
    if (onlyRenderVisible) {
      const { visibleNodes, transform: transform2, width, height } = options;
      if (isEdgeVisible({
        sourceNode,
        targetNode,
        width,
        height,
        transform: transform2
      })) {
        visibleNodes.set(sourceNode.id, sourceNode);
        visibleNodes.set(targetNode.id, targetNode);
      } else {
        continue;
      }
    }
    const previous = previousEdges.get(edge.id);
    if (previous && edge === previous.edge && sourceNode == previous.sourceNode && targetNode == previous.targetNode) {
      layoutedEdges.set(edge.id, previous);
      continue;
    }
    const edgePosition = getEdgePosition({
      id: edge.id,
      sourceNode,
      targetNode,
      sourceHandle: edge.sourceHandle || null,
      targetHandle: edge.targetHandle || null,
      connectionMode,
      onError: onerror
    });
    if (edgePosition) {
      layoutedEdges.set(edge.id, {
        ...defaultEdgeOptions,
        ...edge,
        ...edgePosition,
        zIndex: getElevatedEdgeZIndex({
          selected: edge.selected,
          zIndex: edge.zIndex ?? defaultEdgeOptions.zIndex,
          sourceNode,
          targetNode,
          elevateOnSelect: elevateEdgesOnSelect
        }),
        sourceNode,
        targetNode,
        edge
      });
    }
  }
  return layoutedEdges;
}

// node_modules/@xyflow/svelte/dist/lib/store/initial-store.svelte.js
var initialNodeTypes = {
  input: InputNode_default,
  output: OutputNode_default,
  default: DefaultNode_default,
  group: GroupNode_default
};
var initialEdgeTypes = {
  straight: StraightEdgeInternal_default,
  smoothstep: SmoothStepEdgeInternal_default,
  default: BezierEdge_default,
  step: StepEdgeInternal_default
};
function getInitialViewport(_nodesInitialized, fitView, initialViewport, width, height, nodeLookup) {
  if (fitView && !initialViewport && width && height) {
    const bounds = getInternalNodesBounds(nodeLookup, {
      filter: (node) => !!((node.width || node.initialWidth) && (node.height || node.initialHeight))
    });
    return getViewportForBounds(bounds, width, height, 0.5, 2, 0.1);
  } else {
    return initialViewport ?? { x: 0, y: 0, zoom: 1 };
  }
}
function getInitialStore(signals) {
  class SvelteFlowStore {
    #flowId = tag(user_derived(() => signals.props.id ?? "1"), "SvelteFlowStore.flowId");
    get flowId() {
      return get(this.#flowId);
    }
    set flowId(value) {
      set(this.#flowId, value);
    }
    #domNode = tag(state(null), "SvelteFlowStore.domNode");
    get domNode() {
      return get(this.#domNode);
    }
    set domNode(value) {
      set(this.#domNode, value);
    }
    #panZoom = tag(state(null), "SvelteFlowStore.panZoom");
    get panZoom() {
      return get(this.#panZoom);
    }
    set panZoom(value) {
      set(this.#panZoom, value);
    }
    #width = tag(state(signals.width ?? 0), "SvelteFlowStore.width");
    get width() {
      return get(this.#width);
    }
    set width(value) {
      set(this.#width, value);
    }
    #height = tag(state(signals.height ?? 0), "SvelteFlowStore.height");
    get height() {
      return get(this.#height);
    }
    set height(value) {
      set(this.#height, value);
    }
    #nodesInitialized = tag(
      user_derived(() => {
        const nodesInitialized = adoptUserNodes(signals.nodes, this.nodeLookup, this.parentLookup, {
          nodeExtent: this.nodeExtent,
          nodeOrigin: this.nodeOrigin,
          elevateNodesOnSelect: signals.props.elevateNodesOnSelect ?? true,
          checkEquality: true
        });
        if (this.fitViewQueued && nodesInitialized) {
          if (this.fitViewOptions?.duration) {
            this.resolveFitView();
          } else {
            queueMicrotask(() => {
              this.resolveFitView();
            });
          }
        }
        return nodesInitialized;
      }),
      "SvelteFlowStore.nodesInitialized"
    );
    get nodesInitialized() {
      return get(this.#nodesInitialized);
    }
    set nodesInitialized(value) {
      set(this.#nodesInitialized, value);
    }
    #viewportInitialized = tag(user_derived(() => strict_equals(this.panZoom, null, false)), "SvelteFlowStore.viewportInitialized");
    get viewportInitialized() {
      return get(this.#viewportInitialized);
    }
    set viewportInitialized(value) {
      set(this.#viewportInitialized, value);
    }
    #_edges = tag(
      user_derived(() => {
        updateConnectionLookup(this.connectionLookup, this.edgeLookup, signals.edges);
        return signals.edges;
      }),
      "SvelteFlowStore._edges"
    );
    get _edges() {
      return get(this.#_edges);
    }
    set _edges(value) {
      set(this.#_edges, value);
    }
    get nodes() {
      this.nodesInitialized;
      return signals.nodes;
    }
    set nodes(nodes) {
      signals.nodes = nodes;
    }
    get edges() {
      return this._edges;
    }
    set edges(edges) {
      signals.edges = edges;
    }
    _prevSelectedNodes = [];
    _prevSelectedNodeIds = /* @__PURE__ */ new Set();
    #selectedNodes = tag(
      user_derived(() => {
        const selectedNodesCount = this._prevSelectedNodeIds.size;
        const selectedNodeIds = /* @__PURE__ */ new Set();
        const selectedNodes = this.nodes.filter((node) => {
          if (node.selected) {
            selectedNodeIds.add(node.id);
            this._prevSelectedNodeIds.delete(node.id);
          }
          return node.selected;
        });
        if (strict_equals(selectedNodesCount, selectedNodeIds.size, false) || this._prevSelectedNodeIds.size > 0) {
          this._prevSelectedNodes = selectedNodes;
        }
        this._prevSelectedNodeIds = selectedNodeIds;
        return this._prevSelectedNodes;
      }),
      "SvelteFlowStore.selectedNodes"
    );
    get selectedNodes() {
      return get(this.#selectedNodes);
    }
    set selectedNodes(value) {
      set(this.#selectedNodes, value);
    }
    _prevSelectedEdges = [];
    _prevSelectedEdgeIds = /* @__PURE__ */ new Set();
    #selectedEdges = tag(
      user_derived(() => {
        const selectedEdgesCount = this._prevSelectedEdgeIds.size;
        const selectedEdgeIds = /* @__PURE__ */ new Set();
        const selectedEdges = this.edges.filter((edge) => {
          if (edge.selected) {
            selectedEdgeIds.add(edge.id);
            this._prevSelectedEdgeIds.delete(edge.id);
          }
          return edge.selected;
        });
        if (strict_equals(selectedEdgesCount, selectedEdgeIds.size, false) || this._prevSelectedEdgeIds.size > 0) {
          this._prevSelectedEdges = selectedEdges;
        }
        this._prevSelectedEdgeIds = selectedEdgeIds;
        return this._prevSelectedEdges;
      }),
      "SvelteFlowStore.selectedEdges"
    );
    get selectedEdges() {
      return get(this.#selectedEdges);
    }
    set selectedEdges(value) {
      set(this.#selectedEdges, value);
    }
    selectionChangeHandlers = /* @__PURE__ */ new Map();
    nodeLookup = /* @__PURE__ */ new Map();
    parentLookup = /* @__PURE__ */ new Map();
    connectionLookup = /* @__PURE__ */ new Map();
    edgeLookup = /* @__PURE__ */ new Map();
    _prevVisibleEdges = /* @__PURE__ */ new Map();
    #visible = tag(
      user_derived(() => {
        const {
          // We need to access this._nodes to trigger on changes
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          nodes,
          _edges: edges,
          _prevVisibleEdges: previousEdges,
          nodeLookup,
          connectionMode,
          onerror,
          onlyRenderVisibleElements,
          defaultEdgeOptions
        } = this;
        let visibleNodes;
        let visibleEdges;
        const options = {
          edges,
          defaultEdgeOptions,
          previousEdges,
          nodeLookup,
          connectionMode,
          elevateEdgesOnSelect: signals.props.elevateEdgesOnSelect ?? true,
          onerror
        };
        if (onlyRenderVisibleElements) {
          const { viewport, width, height } = this;
          const transform2 = [viewport.x, viewport.y, viewport.zoom];
          visibleNodes = getVisibleNodes(nodeLookup, transform2, width, height);
          visibleEdges = getLayoutedEdges({
            ...options,
            onlyRenderVisible: true,
            visibleNodes,
            transform: transform2,
            width,
            height
          });
        } else {
          visibleNodes = this.nodeLookup;
          visibleEdges = getLayoutedEdges(options);
        }
        return { nodes: visibleNodes, edges: visibleEdges };
      }),
      "SvelteFlowStore.visible"
    );
    get visible() {
      return get(this.#visible);
    }
    set visible(value) {
      set(this.#visible, value);
    }
    #nodesDraggable = tag(user_derived(() => signals.props.nodesDraggable ?? true), "SvelteFlowStore.nodesDraggable");
    get nodesDraggable() {
      return get(this.#nodesDraggable);
    }
    set nodesDraggable(value) {
      set(this.#nodesDraggable, value);
    }
    #nodesConnectable = tag(user_derived(() => signals.props.nodesConnectable ?? true), "SvelteFlowStore.nodesConnectable");
    get nodesConnectable() {
      return get(this.#nodesConnectable);
    }
    set nodesConnectable(value) {
      set(this.#nodesConnectable, value);
    }
    #elementsSelectable = tag(user_derived(() => signals.props.elementsSelectable ?? true), "SvelteFlowStore.elementsSelectable");
    get elementsSelectable() {
      return get(this.#elementsSelectable);
    }
    set elementsSelectable(value) {
      set(this.#elementsSelectable, value);
    }
    #nodesFocusable = tag(user_derived(() => signals.props.nodesFocusable ?? true), "SvelteFlowStore.nodesFocusable");
    get nodesFocusable() {
      return get(this.#nodesFocusable);
    }
    set nodesFocusable(value) {
      set(this.#nodesFocusable, value);
    }
    #edgesFocusable = tag(user_derived(() => signals.props.edgesFocusable ?? true), "SvelteFlowStore.edgesFocusable");
    get edgesFocusable() {
      return get(this.#edgesFocusable);
    }
    set edgesFocusable(value) {
      set(this.#edgesFocusable, value);
    }
    #disableKeyboardA11y = tag(user_derived(() => signals.props.disableKeyboardA11y ?? false), "SvelteFlowStore.disableKeyboardA11y");
    get disableKeyboardA11y() {
      return get(this.#disableKeyboardA11y);
    }
    set disableKeyboardA11y(value) {
      set(this.#disableKeyboardA11y, value);
    }
    #minZoom = tag(user_derived(() => signals.props.minZoom ?? 0.5), "SvelteFlowStore.minZoom");
    get minZoom() {
      return get(this.#minZoom);
    }
    set minZoom(value) {
      set(this.#minZoom, value);
    }
    #maxZoom = tag(user_derived(() => signals.props.maxZoom ?? 2), "SvelteFlowStore.maxZoom");
    get maxZoom() {
      return get(this.#maxZoom);
    }
    set maxZoom(value) {
      set(this.#maxZoom, value);
    }
    #nodeOrigin = tag(user_derived(() => signals.props.nodeOrigin ?? [0, 0]), "SvelteFlowStore.nodeOrigin");
    get nodeOrigin() {
      return get(this.#nodeOrigin);
    }
    set nodeOrigin(value) {
      set(this.#nodeOrigin, value);
    }
    #nodeExtent = tag(user_derived(() => signals.props.nodeExtent ?? infiniteExtent), "SvelteFlowStore.nodeExtent");
    get nodeExtent() {
      return get(this.#nodeExtent);
    }
    set nodeExtent(value) {
      set(this.#nodeExtent, value);
    }
    #translateExtent = tag(user_derived(() => signals.props.translateExtent ?? infiniteExtent), "SvelteFlowStore.translateExtent");
    get translateExtent() {
      return get(this.#translateExtent);
    }
    set translateExtent(value) {
      set(this.#translateExtent, value);
    }
    #defaultEdgeOptions = tag(user_derived(() => signals.props.defaultEdgeOptions ?? {}), "SvelteFlowStore.defaultEdgeOptions");
    get defaultEdgeOptions() {
      return get(this.#defaultEdgeOptions);
    }
    set defaultEdgeOptions(value) {
      set(this.#defaultEdgeOptions, value);
    }
    #nodeDragThreshold = tag(user_derived(() => signals.props.nodeDragThreshold ?? 1), "SvelteFlowStore.nodeDragThreshold");
    get nodeDragThreshold() {
      return get(this.#nodeDragThreshold);
    }
    set nodeDragThreshold(value) {
      set(this.#nodeDragThreshold, value);
    }
    #autoPanOnNodeDrag = tag(user_derived(() => signals.props.autoPanOnNodeDrag ?? true), "SvelteFlowStore.autoPanOnNodeDrag");
    get autoPanOnNodeDrag() {
      return get(this.#autoPanOnNodeDrag);
    }
    set autoPanOnNodeDrag(value) {
      set(this.#autoPanOnNodeDrag, value);
    }
    #autoPanOnConnect = tag(user_derived(() => signals.props.autoPanOnConnect ?? true), "SvelteFlowStore.autoPanOnConnect");
    get autoPanOnConnect() {
      return get(this.#autoPanOnConnect);
    }
    set autoPanOnConnect(value) {
      set(this.#autoPanOnConnect, value);
    }
    #autoPanOnNodeFocus = tag(user_derived(() => signals.props.autoPanOnNodeFocus ?? true), "SvelteFlowStore.autoPanOnNodeFocus");
    get autoPanOnNodeFocus() {
      return get(this.#autoPanOnNodeFocus);
    }
    set autoPanOnNodeFocus(value) {
      set(this.#autoPanOnNodeFocus, value);
    }
    #autoPanSpeed = tag(user_derived(() => signals.props.autoPanSpeed ?? 15), "SvelteFlowStore.autoPanSpeed");
    get autoPanSpeed() {
      return get(this.#autoPanSpeed);
    }
    set autoPanSpeed(value) {
      set(this.#autoPanSpeed, value);
    }
    #connectionDragThreshold = tag(user_derived(() => signals.props.connectionDragThreshold ?? 1), "SvelteFlowStore.connectionDragThreshold");
    get connectionDragThreshold() {
      return get(this.#connectionDragThreshold);
    }
    set connectionDragThreshold(value) {
      set(this.#connectionDragThreshold, value);
    }
    fitViewQueued = signals.props.fitView ?? false;
    fitViewOptions = signals.props.fitViewOptions;
    fitViewResolver = null;
    #snapGrid = tag(user_derived(() => signals.props.snapGrid ?? null), "SvelteFlowStore.snapGrid");
    get snapGrid() {
      return get(this.#snapGrid);
    }
    set snapGrid(value) {
      set(this.#snapGrid, value);
    }
    #dragging = tag(state(false), "SvelteFlowStore.dragging");
    get dragging() {
      return get(this.#dragging);
    }
    set dragging(value) {
      set(this.#dragging, value);
    }
    #selectionRect = tag(state(null), "SvelteFlowStore.selectionRect");
    get selectionRect() {
      return get(this.#selectionRect);
    }
    set selectionRect(value) {
      set(this.#selectionRect, value);
    }
    #selectionKeyPressed = tag(state(false), "SvelteFlowStore.selectionKeyPressed");
    get selectionKeyPressed() {
      return get(this.#selectionKeyPressed);
    }
    set selectionKeyPressed(value) {
      set(this.#selectionKeyPressed, value);
    }
    #multiselectionKeyPressed = tag(state(false), "SvelteFlowStore.multiselectionKeyPressed");
    get multiselectionKeyPressed() {
      return get(this.#multiselectionKeyPressed);
    }
    set multiselectionKeyPressed(value) {
      set(this.#multiselectionKeyPressed, value);
    }
    #deleteKeyPressed = tag(state(false), "SvelteFlowStore.deleteKeyPressed");
    get deleteKeyPressed() {
      return get(this.#deleteKeyPressed);
    }
    set deleteKeyPressed(value) {
      set(this.#deleteKeyPressed, value);
    }
    #panActivationKeyPressed = tag(state(false), "SvelteFlowStore.panActivationKeyPressed");
    get panActivationKeyPressed() {
      return get(this.#panActivationKeyPressed);
    }
    set panActivationKeyPressed(value) {
      set(this.#panActivationKeyPressed, value);
    }
    #zoomActivationKeyPressed = tag(state(false), "SvelteFlowStore.zoomActivationKeyPressed");
    get zoomActivationKeyPressed() {
      return get(this.#zoomActivationKeyPressed);
    }
    set zoomActivationKeyPressed(value) {
      set(this.#zoomActivationKeyPressed, value);
    }
    #selectionRectMode = tag(state(null), "SvelteFlowStore.selectionRectMode");
    get selectionRectMode() {
      return get(this.#selectionRectMode);
    }
    set selectionRectMode(value) {
      set(this.#selectionRectMode, value);
    }
    #ariaLiveMessage = tag(state(""), "SvelteFlowStore.ariaLiveMessage");
    get ariaLiveMessage() {
      return get(this.#ariaLiveMessage);
    }
    set ariaLiveMessage(value) {
      set(this.#ariaLiveMessage, value);
    }
    #selectionMode = tag(user_derived(() => signals.props.selectionMode ?? SelectionMode.Partial), "SvelteFlowStore.selectionMode");
    get selectionMode() {
      return get(this.#selectionMode);
    }
    set selectionMode(value) {
      set(this.#selectionMode, value);
    }
    #nodeTypes = tag(user_derived(() => ({ ...initialNodeTypes, ...signals.props.nodeTypes })), "SvelteFlowStore.nodeTypes");
    get nodeTypes() {
      return get(this.#nodeTypes);
    }
    set nodeTypes(value) {
      set(this.#nodeTypes, value);
    }
    #edgeTypes = tag(user_derived(() => ({ ...initialEdgeTypes, ...signals.props.edgeTypes })), "SvelteFlowStore.edgeTypes");
    get edgeTypes() {
      return get(this.#edgeTypes);
    }
    set edgeTypes(value) {
      set(this.#edgeTypes, value);
    }
    #noPanClass = tag(user_derived(() => signals.props.noPanClass ?? "nopan"), "SvelteFlowStore.noPanClass");
    get noPanClass() {
      return get(this.#noPanClass);
    }
    set noPanClass(value) {
      set(this.#noPanClass, value);
    }
    #noDragClass = tag(user_derived(() => signals.props.noDragClass ?? "nodrag"), "SvelteFlowStore.noDragClass");
    get noDragClass() {
      return get(this.#noDragClass);
    }
    set noDragClass(value) {
      set(this.#noDragClass, value);
    }
    #noWheelClass = tag(user_derived(() => signals.props.noWheelClass ?? "nowheel"), "SvelteFlowStore.noWheelClass");
    get noWheelClass() {
      return get(this.#noWheelClass);
    }
    set noWheelClass(value) {
      set(this.#noWheelClass, value);
    }
    #ariaLabelConfig = tag(user_derived(() => mergeAriaLabelConfig(signals.props.ariaLabelConfig)), "SvelteFlowStore.ariaLabelConfig");
    get ariaLabelConfig() {
      return get(this.#ariaLabelConfig);
    }
    set ariaLabelConfig(value) {
      set(this.#ariaLabelConfig, value);
    }
    #_viewport = tag(state(getInitialViewport(this.nodesInitialized, signals.props.fitView, signals.props.initialViewport, this.width, this.height, this.nodeLookup)), "SvelteFlowStore._viewport");
    get _viewport() {
      return get(this.#_viewport);
    }
    set _viewport(value) {
      set(this.#_viewport, value);
    }
    get viewport() {
      return signals.viewport ?? this._viewport;
    }
    set viewport(newViewport) {
      if (signals.viewport) {
        signals.viewport = newViewport;
      }
      this._viewport = newViewport;
    }
    #_connection = tag(
      state(
        // _connection is viewport independent and originating from XYHandle
        initialConnection
      ),
      "SvelteFlowStore._connection"
    );
    get _connection() {
      return get(this.#_connection);
    }
    set _connection(value) {
      set(this.#_connection, value);
    }
    #connection = tag(
      user_derived(() => {
        if (!this._connection.inProgress) {
          return this._connection;
        }
        return {
          ...this._connection,
          to: pointToRendererPoint(this._connection.to, [this.viewport.x, this.viewport.y, this.viewport.zoom])
        };
      }),
      "SvelteFlowStore.connection"
    );
    get connection() {
      return get(this.#connection);
    }
    set connection(value) {
      set(this.#connection, value);
    }
    #connectionMode = tag(user_derived(() => signals.props.connectionMode ?? ConnectionMode.Strict), "SvelteFlowStore.connectionMode");
    get connectionMode() {
      return get(this.#connectionMode);
    }
    set connectionMode(value) {
      set(this.#connectionMode, value);
    }
    #connectionRadius = tag(user_derived(() => signals.props.connectionRadius ?? 20), "SvelteFlowStore.connectionRadius");
    get connectionRadius() {
      return get(this.#connectionRadius);
    }
    set connectionRadius(value) {
      set(this.#connectionRadius, value);
    }
    #isValidConnection = tag(user_derived(() => signals.props.isValidConnection ?? (() => true)), "SvelteFlowStore.isValidConnection");
    get isValidConnection() {
      return get(this.#isValidConnection);
    }
    set isValidConnection(value) {
      set(this.#isValidConnection, value);
    }
    #selectNodesOnDrag = tag(user_derived(() => signals.props.selectNodesOnDrag ?? true), "SvelteFlowStore.selectNodesOnDrag");
    get selectNodesOnDrag() {
      return get(this.#selectNodesOnDrag);
    }
    set selectNodesOnDrag(value) {
      set(this.#selectNodesOnDrag, value);
    }
    #defaultMarkerColor = tag(user_derived(() => strict_equals(signals.props.defaultMarkerColor, void 0) ? "#b1b1b7" : signals.props.defaultMarkerColor), "SvelteFlowStore.defaultMarkerColor");
    get defaultMarkerColor() {
      return get(this.#defaultMarkerColor);
    }
    set defaultMarkerColor(value) {
      set(this.#defaultMarkerColor, value);
    }
    #markers = tag(
      user_derived(() => {
        return createMarkerIds(signals.edges, {
          defaultColor: this.defaultMarkerColor,
          id: this.flowId,
          defaultMarkerStart: this.defaultEdgeOptions.markerStart,
          defaultMarkerEnd: this.defaultEdgeOptions.markerEnd
        });
      }),
      "SvelteFlowStore.markers"
    );
    get markers() {
      return get(this.#markers);
    }
    set markers(value) {
      set(this.#markers, value);
    }
    #onlyRenderVisibleElements = tag(user_derived(() => signals.props.onlyRenderVisibleElements ?? false), "SvelteFlowStore.onlyRenderVisibleElements");
    get onlyRenderVisibleElements() {
      return get(this.#onlyRenderVisibleElements);
    }
    set onlyRenderVisibleElements(value) {
      set(this.#onlyRenderVisibleElements, value);
    }
    #onerror = tag(user_derived(() => signals.props.onflowerror ?? devWarn), "SvelteFlowStore.onerror");
    get onerror() {
      return get(this.#onerror);
    }
    set onerror(value) {
      set(this.#onerror, value);
    }
    #ondelete = tag(user_derived(() => signals.props.ondelete), "SvelteFlowStore.ondelete");
    get ondelete() {
      return get(this.#ondelete);
    }
    set ondelete(value) {
      set(this.#ondelete, value);
    }
    #onbeforedelete = tag(user_derived(() => signals.props.onbeforedelete), "SvelteFlowStore.onbeforedelete");
    get onbeforedelete() {
      return get(this.#onbeforedelete);
    }
    set onbeforedelete(value) {
      set(this.#onbeforedelete, value);
    }
    #onbeforeconnect = tag(user_derived(() => signals.props.onbeforeconnect), "SvelteFlowStore.onbeforeconnect");
    get onbeforeconnect() {
      return get(this.#onbeforeconnect);
    }
    set onbeforeconnect(value) {
      set(this.#onbeforeconnect, value);
    }
    #onconnect = tag(user_derived(() => signals.props.onconnect), "SvelteFlowStore.onconnect");
    get onconnect() {
      return get(this.#onconnect);
    }
    set onconnect(value) {
      set(this.#onconnect, value);
    }
    #onconnectstart = tag(user_derived(() => signals.props.onconnectstart), "SvelteFlowStore.onconnectstart");
    get onconnectstart() {
      return get(this.#onconnectstart);
    }
    set onconnectstart(value) {
      set(this.#onconnectstart, value);
    }
    #onconnectend = tag(user_derived(() => signals.props.onconnectend), "SvelteFlowStore.onconnectend");
    get onconnectend() {
      return get(this.#onconnectend);
    }
    set onconnectend(value) {
      set(this.#onconnectend, value);
    }
    #onbeforereconnect = tag(user_derived(() => signals.props.onbeforereconnect), "SvelteFlowStore.onbeforereconnect");
    get onbeforereconnect() {
      return get(this.#onbeforereconnect);
    }
    set onbeforereconnect(value) {
      set(this.#onbeforereconnect, value);
    }
    #onreconnect = tag(user_derived(() => signals.props.onreconnect), "SvelteFlowStore.onreconnect");
    get onreconnect() {
      return get(this.#onreconnect);
    }
    set onreconnect(value) {
      set(this.#onreconnect, value);
    }
    #onreconnectstart = tag(user_derived(() => signals.props.onreconnectstart), "SvelteFlowStore.onreconnectstart");
    get onreconnectstart() {
      return get(this.#onreconnectstart);
    }
    set onreconnectstart(value) {
      set(this.#onreconnectstart, value);
    }
    #onreconnectend = tag(user_derived(() => signals.props.onreconnectend), "SvelteFlowStore.onreconnectend");
    get onreconnectend() {
      return get(this.#onreconnectend);
    }
    set onreconnectend(value) {
      set(this.#onreconnectend, value);
    }
    #clickConnect = tag(user_derived(() => signals.props.clickConnect ?? true), "SvelteFlowStore.clickConnect");
    get clickConnect() {
      return get(this.#clickConnect);
    }
    set clickConnect(value) {
      set(this.#clickConnect, value);
    }
    #onclickconnectstart = tag(user_derived(() => signals.props.onclickconnectstart), "SvelteFlowStore.onclickconnectstart");
    get onclickconnectstart() {
      return get(this.#onclickconnectstart);
    }
    set onclickconnectstart(value) {
      set(this.#onclickconnectstart, value);
    }
    #onclickconnectend = tag(user_derived(() => signals.props.onclickconnectend), "SvelteFlowStore.onclickconnectend");
    get onclickconnectend() {
      return get(this.#onclickconnectend);
    }
    set onclickconnectend(value) {
      set(this.#onclickconnectend, value);
    }
    #clickConnectStartHandle = tag(state(null), "SvelteFlowStore.clickConnectStartHandle");
    get clickConnectStartHandle() {
      return get(this.#clickConnectStartHandle);
    }
    set clickConnectStartHandle(value) {
      set(this.#clickConnectStartHandle, value);
    }
    #onselectiondrag = tag(user_derived(() => signals.props.onselectiondrag), "SvelteFlowStore.onselectiondrag");
    get onselectiondrag() {
      return get(this.#onselectiondrag);
    }
    set onselectiondrag(value) {
      set(this.#onselectiondrag, value);
    }
    #onselectiondragstart = tag(user_derived(() => signals.props.onselectiondragstart), "SvelteFlowStore.onselectiondragstart");
    get onselectiondragstart() {
      return get(this.#onselectiondragstart);
    }
    set onselectiondragstart(value) {
      set(this.#onselectiondragstart, value);
    }
    #onselectiondragstop = tag(user_derived(() => signals.props.onselectiondragstop), "SvelteFlowStore.onselectiondragstop");
    get onselectiondragstop() {
      return get(this.#onselectiondragstop);
    }
    set onselectiondragstop(value) {
      set(this.#onselectiondragstop, value);
    }
    resolveFitView = async () => {
      if (!this.panZoom) {
        return;
      }
      (await track_reactivity_loss(fitViewport(
        {
          nodes: this.nodeLookup,
          width: this.width,
          height: this.height,
          panZoom: this.panZoom,
          minZoom: this.minZoom,
          maxZoom: this.maxZoom
        },
        this.fitViewOptions
      )))();
      this.fitViewResolver?.resolve(true);
      this.fitViewQueued = false;
      this.fitViewOptions = void 0;
      this.fitViewResolver = null;
    };
    _prefersDark = new MediaQuery("(prefers-color-scheme: dark)", strict_equals(signals.props.colorModeSSR, "dark"));
    #colorMode = tag(
      user_derived(() => strict_equals(signals.props.colorMode, "system") ? this._prefersDark.current ? "dark" : "light" : signals.props.colorMode ?? "light"),
      "SvelteFlowStore.colorMode"
    );
    get colorMode() {
      return get(this.#colorMode);
    }
    set colorMode(value) {
      set(this.#colorMode, value);
    }
    constructor() {
      if (strict_equals("development", "development")) {
        warnIfDeeplyReactive(signals.nodes, "nodes");
        warnIfDeeplyReactive(signals.edges, "edges");
      }
    }
    resetStoreValues() {
      this.dragging = false;
      this.selectionRect = null;
      this.selectionRectMode = null;
      this.selectionKeyPressed = false;
      this.multiselectionKeyPressed = false;
      this.deleteKeyPressed = false;
      this.panActivationKeyPressed = false;
      this.zoomActivationKeyPressed = false;
      this._connection = initialConnection;
      this.clickConnectStartHandle = null;
      this.viewport = signals.props.initialViewport ?? { x: 0, y: 0, zoom: 1 };
      this.ariaLiveMessage = "";
    }
  }
  return new SvelteFlowStore();
}
function warnIfDeeplyReactive(array2, name) {
  try {
    if (array2 && array2.length > 0) {
      structuredClone(array2[0]);
    }
  } catch {
    console.warn(`Use $state.raw for ${name} to prevent performance issues.`);
  }
}

// node_modules/@xyflow/svelte/dist/lib/hooks/derivedWarning.svelte.js
function derivedWarning(functionName) {
  const storeContext = getContext(key);
  if (!storeContext) {
    throw new Error(`In order to use ${functionName}() you need to wrap your component in a <SvelteFlowProvider />`);
  }
  if (storeContext.provider && strict_equals(typeof window, "object") && !effect_tracking()) {
    throw new Error(`Use $derived(${functionName}()) to receive updates when values change.`);
  }
}

// node_modules/@xyflow/svelte/dist/lib/hooks/useStore.js
function useStore() {
  const storeContext = getContext(key);
  if (!storeContext) {
    throw new Error("To call useStore outside of <SvelteFlow /> you need to wrap your component in a <SvelteFlowProvider />");
  }
  if (true) {
    derivedWarning("useStore");
  }
  return storeContext.getStore();
}

// node_modules/@xyflow/svelte/dist/lib/store/index.js
var key = Symbol();
function createStore(signals) {
  const store = getInitialStore(signals);
  function setNodeTypes(nodeTypes) {
    store.nodeTypes = {
      ...initialNodeTypes,
      ...nodeTypes
    };
  }
  function setEdgeTypes(edgeTypes) {
    store.edgeTypes = {
      ...initialEdgeTypes,
      ...edgeTypes
    };
  }
  function addEdge2(edgeParams) {
    store.edges = addEdge(edgeParams, store.edges);
  }
  const updateNodePositions = (nodeDragItems, dragging = false) => {
    store.nodes = store.nodes.map((node) => {
      const dragItem = nodeDragItems.get(node.id);
      return dragItem ? { ...node, position: dragItem.position, dragging } : node;
    });
  };
  function updateNodeInternals2(updates) {
    const { changes, updatedInternals } = updateNodeInternals(updates, store.nodeLookup, store.parentLookup, store.domNode, store.nodeOrigin);
    if (!updatedInternals) {
      return;
    }
    updateAbsolutePositions(store.nodeLookup, store.parentLookup, {
      nodeOrigin: store.nodeOrigin,
      nodeExtent: store.nodeExtent
    });
    if (store.fitViewQueued) {
      store.resolveFitView();
    }
    const newNodes = /* @__PURE__ */ new Map();
    for (const change of changes) {
      const userNode = store.nodeLookup.get(change.id)?.internals.userNode;
      if (!userNode) {
        continue;
      }
      const node = { ...userNode };
      switch (change.type) {
        case "dimensions": {
          const measured = { ...node.measured, ...change.dimensions };
          if (change.setAttributes) {
            node.width = change.dimensions?.width ?? node.width;
            node.height = change.dimensions?.height ?? node.height;
          }
          node.measured = measured;
          break;
        }
        case "position":
          node.position = change.position ?? node.position;
          break;
      }
      newNodes.set(change.id, node);
    }
    store.nodes = store.nodes.map((node) => newNodes.get(node.id) ?? node);
  }
  function fitView(options) {
    const fitViewResolver = store.fitViewResolver ?? Promise.withResolvers();
    store.fitViewQueued = true;
    store.fitViewOptions = options;
    store.fitViewResolver = fitViewResolver;
    store.nodes = [...store.nodes];
    return fitViewResolver.promise;
  }
  async function setCenter(x, y, options) {
    const nextZoom = typeof options?.zoom !== "undefined" ? options.zoom : store.maxZoom;
    const currentPanZoom = store.panZoom;
    if (!currentPanZoom) {
      return Promise.resolve(false);
    }
    await currentPanZoom.setViewport({
      x: store.width / 2 - x * nextZoom,
      y: store.height / 2 - y * nextZoom,
      zoom: nextZoom
    }, { duration: options?.duration, ease: options?.ease, interpolate: options?.interpolate });
    return Promise.resolve(true);
  }
  function zoomBy(factor, options) {
    const panZoom = store.panZoom;
    if (!panZoom) {
      return Promise.resolve(false);
    }
    return panZoom.scaleBy(factor, options);
  }
  function zoomIn(options) {
    return zoomBy(1.2, options);
  }
  function zoomOut(options) {
    return zoomBy(1 / 1.2, options);
  }
  function setMinZoom(minZoom) {
    const panZoom = store.panZoom;
    if (panZoom) {
      panZoom.setScaleExtent([minZoom, store.maxZoom]);
      store.minZoom = minZoom;
    }
  }
  function setMaxZoom(maxZoom) {
    const panZoom = store.panZoom;
    if (panZoom) {
      panZoom.setScaleExtent([store.minZoom, maxZoom]);
      store.maxZoom = maxZoom;
    }
  }
  function setTranslateExtent(extent) {
    const panZoom = store.panZoom;
    if (panZoom) {
      panZoom.setTranslateExtent(extent);
      store.translateExtent = extent;
    }
  }
  function deselect(elements, elementsToDeselect = null) {
    let deselected = false;
    const newElements = elements.map((element) => {
      const shouldDeselect = elementsToDeselect ? elementsToDeselect.has(element.id) : true;
      if (shouldDeselect && element.selected) {
        deselected = true;
        return { ...element, selected: false };
      }
      return element;
    });
    return [deselected, newElements];
  }
  function unselectNodesAndEdges(params) {
    const nodesToDeselect = params?.nodes ? new Set(params.nodes.map((node) => node.id)) : null;
    const [nodesDeselected, newNodes] = deselect(store.nodes, nodesToDeselect);
    if (nodesDeselected) {
      store.nodes = newNodes;
    }
    const edgesToDeselect = params?.edges ? new Set(params.edges.map((node) => node.id)) : null;
    const [edgesDeselected, newEdges] = deselect(store.edges, edgesToDeselect);
    if (edgesDeselected) {
      store.edges = newEdges;
    }
  }
  function addSelectedNodes(ids) {
    const isMultiSelection = store.multiselectionKeyPressed;
    store.nodes = store.nodes.map((node) => {
      const nodeWillBeSelected = ids.includes(node.id);
      const selected = isMultiSelection ? node.selected || nodeWillBeSelected : nodeWillBeSelected;
      if (!!node.selected !== selected) {
        return { ...node, selected };
      }
      return node;
    });
    if (!isMultiSelection) {
      unselectNodesAndEdges({ nodes: [] });
    }
  }
  function addSelectedEdges(ids) {
    const isMultiSelection = store.multiselectionKeyPressed;
    store.edges = store.edges.map((edge) => {
      const edgeWillBeSelected = ids.includes(edge.id);
      const selected = isMultiSelection ? edge.selected || edgeWillBeSelected : edgeWillBeSelected;
      if (!!edge.selected !== selected) {
        return { ...edge, selected };
      }
      return edge;
    });
    if (!isMultiSelection) {
      unselectNodesAndEdges({ edges: [] });
    }
  }
  function handleNodeSelection(id2, unselect, nodeRef) {
    const node = store.nodeLookup.get(id2);
    if (!node) {
      console.warn("012", errorMessages["error012"](id2));
      return;
    }
    store.selectionRect = null;
    store.selectionRectMode = null;
    if (!node.selected) {
      addSelectedNodes([id2]);
    } else if (unselect || node.selected && store.multiselectionKeyPressed) {
      unselectNodesAndEdges({ nodes: [node], edges: [] });
      requestAnimationFrame(() => nodeRef?.blur());
    }
  }
  function handleEdgeSelection(id2) {
    const edge = store.edgeLookup.get(id2);
    if (!edge) {
      console.warn("012", errorMessages["error012"](id2));
      return;
    }
    const selectable = edge.selectable || store.elementsSelectable && typeof edge.selectable === "undefined";
    if (selectable) {
      store.selectionRect = null;
      store.selectionRectMode = null;
      if (!edge.selected) {
        addSelectedEdges([id2]);
      } else if (edge.selected && store.multiselectionKeyPressed) {
        unselectNodesAndEdges({ nodes: [], edges: [edge] });
      }
    }
  }
  function moveSelectedNodes(direction, factor) {
    const { nodeExtent, snapGrid, nodeOrigin, nodeLookup, nodesDraggable, onerror } = store;
    const nodeUpdates = /* @__PURE__ */ new Map();
    const xVelo = snapGrid?.[0] ?? 5;
    const yVelo = snapGrid?.[1] ?? 5;
    const xDiff = direction.x * xVelo * factor;
    const yDiff = direction.y * yVelo * factor;
    for (const node of nodeLookup.values()) {
      const isSelected = node.selected && (node.draggable || nodesDraggable && typeof node.draggable === "undefined");
      if (!isSelected) {
        continue;
      }
      let nextPosition = {
        x: node.internals.positionAbsolute.x + xDiff,
        y: node.internals.positionAbsolute.y + yDiff
      };
      if (snapGrid) {
        nextPosition = snapPosition(nextPosition, snapGrid);
      }
      const { position, positionAbsolute } = calculateNodePosition({
        nodeId: node.id,
        nextPosition,
        nodeLookup,
        nodeExtent,
        nodeOrigin,
        onError: onerror
      });
      node.position = position;
      node.internals.positionAbsolute = positionAbsolute;
      nodeUpdates.set(node.id, node);
    }
    updateNodePositions(nodeUpdates);
  }
  function panBy2(delta) {
    return panBy({
      delta,
      panZoom: store.panZoom,
      transform: [store.viewport.x, store.viewport.y, store.viewport.zoom],
      translateExtent: store.translateExtent,
      width: store.width,
      height: store.height
    });
  }
  const updateConnection = (newConnection) => {
    store._connection = { ...newConnection };
  };
  function cancelConnection() {
    store._connection = initialConnection;
  }
  function reset2() {
    store.resetStoreValues();
    unselectNodesAndEdges();
  }
  const storeWithActions = Object.assign(store, {
    setNodeTypes,
    setEdgeTypes,
    addEdge: addEdge2,
    updateNodePositions,
    updateNodeInternals: updateNodeInternals2,
    zoomIn,
    zoomOut,
    fitView,
    setCenter,
    setMinZoom,
    setMaxZoom,
    setTranslateExtent,
    unselectNodesAndEdges,
    addSelectedNodes,
    addSelectedEdges,
    handleNodeSelection,
    handleEdgeSelection,
    moveSelectedNodes,
    panBy: panBy2,
    updateConnection,
    cancelConnection,
    reset: reset2
  });
  return storeWithActions;
}

// node_modules/@xyflow/svelte/dist/lib/actions/zoom/index.js
function zoom(domNode, params) {
  const { minZoom, maxZoom, initialViewport, onPanZoomStart, onPanZoom, onPanZoomEnd, translateExtent, setPanZoomInstance, onDraggingChange, onTransformChange } = params;
  const panZoomInstance = XYPanZoom({
    domNode,
    minZoom,
    maxZoom,
    translateExtent,
    viewport: initialViewport,
    onPanZoom,
    onPanZoomStart,
    onPanZoomEnd,
    onDraggingChange
  });
  const viewport = panZoomInstance.getViewport();
  if (initialViewport.x !== viewport.x || initialViewport.y !== viewport.y || initialViewport.zoom !== viewport.zoom) {
    onTransformChange([viewport.x, viewport.y, viewport.zoom]);
  }
  setPanZoomInstance(panZoomInstance);
  panZoomInstance.update(params);
  return {
    update(params2) {
      panZoomInstance.update(params2);
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/container/Zoom/Zoom.svelte
Zoom[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/container/Zoom/Zoom.svelte";
var root8 = add_locations(from_html(`<div class="svelte-flow__zoom svelte-flow__container"><!></div>`), Zoom[FILENAME], [[42, 0]]);
function Zoom($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Zoom);
  var $$ownership_validator = create_ownership_validator($$props);
  let store = prop($$props, "store", 15);
  let panOnDragActive = tag(user_derived(() => store().panActivationKeyPressed || $$props.panOnDrag), "panOnDragActive");
  let panOnScrollActive = tag(user_derived(() => store().panActivationKeyPressed || $$props.panOnScroll), "panOnScrollActive");
  const { viewport: initialViewport } = store();
  let onInitCalled = false;
  user_effect(() => {
    if (!onInitCalled && store().viewportInitialized) {
      $$props.oninit?.();
      onInitCalled = true;
    }
  });
  var $$exports = { ...legacy_api() };
  var div = root8();
  var node = child(div);
  add_svelte_meta(() => snippet(node, () => $$props.children), "render", Zoom, 80, 2);
  reset(div);
  action(div, ($$node, $$action_arg) => zoom?.($$node, $$action_arg), () => ({
    viewport: store().viewport,
    minZoom: store().minZoom,
    maxZoom: store().maxZoom,
    initialViewport,
    onDraggingChange: (dragging) => {
      $$ownership_validator.mutation("store", ["store", "dragging"], store(store().dragging = dragging, true), 50, 6);
    },
    setPanZoomInstance: (instance) => {
      $$ownership_validator.mutation("store", ["store", "panZoom"], store(store().panZoom = instance, true), 53, 6);
    },
    onPanZoomStart: $$props.onmovestart,
    onPanZoom: $$props.onmove,
    onPanZoomEnd: $$props.onmoveend,
    zoomOnScroll: $$props.zoomOnScroll,
    zoomOnDoubleClick: $$props.zoomOnDoubleClick,
    zoomOnPinch: $$props.zoomOnPinch,
    panOnScroll: get(panOnScrollActive),
    panOnDrag: get(panOnDragActive),
    panOnScrollSpeed: $$props.panOnScrollSpeed,
    panOnScrollMode: $$props.panOnScrollMode,
    zoomActivationKeyPressed: store().zoomActivationKeyPressed,
    preventScrolling: strict_equals(typeof $$props.preventScrolling, "boolean") ? $$props.preventScrolling : true,
    noPanClassName: store().noPanClass,
    noWheelClassName: store().noWheelClass,
    userSelectionActive: !!store().selectionRect,
    translateExtent: store().translateExtent,
    lib: "svelte",
    paneClickDistance: $$props.paneClickDistance,
    selectionOnDrag: $$props.selectionOnDrag,
    onTransformChange: (transform2) => {
      $$ownership_validator.mutation("store", ["store", "viewport"], store(store().viewport = { x: transform2[0], y: transform2[1], zoom: transform2[2] }, true), 75, 6);
    },
    connectionInProgress: store().connection.inProgress
  }));
  append($$anchor, div);
  return pop($$exports);
}
if (import.meta.hot) {
  Zoom = hmr(Zoom, () => Zoom[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Zoom[HMR].source;
    set(Zoom[HMR].source, module.default[HMR].original);
  });
}
var Zoom_default = Zoom;

// node_modules/@xyflow/svelte/dist/lib/container/Pane/Pane.svelte
Pane[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/container/Pane/Pane.svelte";
function wrapHandler(handler, container) {
  return (event2) => {
    if (strict_equals(event2.target, container, false)) {
      return;
    }
    handler?.(event2);
  };
}
function toggleSelected(ids) {
  return (item) => {
    const isSelected = ids.has(item.id);
    if (strict_equals(!!item.selected, isSelected, false)) {
      return { ...item, selected: isSelected };
    }
    return item;
  };
}
function isSetEqual(a, b) {
  if (strict_equals(a.size, b.size, false)) {
    return false;
  }
  for (const item of a) {
    if (!b.has(item)) {
      return false;
    }
  }
  return true;
}
var root9 = add_locations(from_html(`<div><!></div>`), Pane[FILENAME], [[252, 0]]);
function Pane($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Pane);
  var $$ownership_validator = create_ownership_validator($$props);
  let store = prop($$props, "store", 15), panOnDrag = prop($$props, "panOnDrag", 3, true), paneClickDistance = prop($$props, "paneClickDistance", 3, 1);
  let container;
  let containerBounds = null;
  let selectedNodeIds = /* @__PURE__ */ new Set();
  let selectedEdgeIds = /* @__PURE__ */ new Set();
  let panOnDragActive = tag(user_derived(() => store().panActivationKeyPressed || panOnDrag()), "panOnDragActive");
  let isSelecting = tag(user_derived(() => store().selectionKeyPressed || !!store().selectionRect || $$props.selectionOnDrag && strict_equals(get(panOnDragActive), true, false)), "isSelecting");
  let isSelectionEnabled = tag(user_derived(() => store().elementsSelectable && (get(isSelecting) || strict_equals(store().selectionRectMode, "user"))), "isSelectionEnabled");
  let selectionInProgress = false;
  function onPointerDownCapture(event2) {
    containerBounds = container?.getBoundingClientRect();
    if (!containerBounds) return;
    const eventTargetIsContainer = strict_equals(event2.target, container);
    const isNoKeyEvent = !eventTargetIsContainer && !!event2.target.closest(".nokey");
    const isSelectionActive = $$props.selectionOnDrag && eventTargetIsContainer || store().selectionKeyPressed;
    if (isNoKeyEvent || !get(isSelecting) || !isSelectionActive || strict_equals(event2.button, 0, false) || !event2.isPrimary) {
      return;
    }
    event2.target?.setPointerCapture?.(event2.pointerId);
    selectionInProgress = false;
    const { x, y } = getEventPosition(event2, containerBounds);
    $$ownership_validator.mutation("store", ["store", "selectionRect"], store(store().selectionRect = { width: 0, height: 0, startX: x, startY: y, x, y }, true), 110, 4);
    if (!eventTargetIsContainer) {
      event2.stopPropagation();
      event2.preventDefault();
    }
  }
  function onPointerMove(event2) {
    if (!get(isSelecting) || !containerBounds || !store().selectionRect) {
      return;
    }
    const mousePos = getEventPosition(event2, containerBounds);
    const { startX = 0, startY = 0 } = store().selectionRect;
    if (!selectionInProgress) {
      const requiredDistance = store().selectionKeyPressed ? 0 : paneClickDistance();
      const distance2 = Math.hypot(mousePos.x - startX, mousePos.y - startY);
      if (distance2 <= requiredDistance) {
        return;
      }
      store().unselectNodesAndEdges();
      $$props.onselectionstart?.(event2);
    }
    selectionInProgress = true;
    const nextUserSelectRect = {
      ...store().selectionRect,
      x: mousePos.x < startX ? mousePos.x : startX,
      y: mousePos.y < startY ? mousePos.y : startY,
      width: Math.abs(mousePos.x - startX),
      height: Math.abs(mousePos.y - startY)
    };
    const prevSelectedNodeIds = selectedNodeIds;
    const prevSelectedEdgeIds = selectedEdgeIds;
    selectedNodeIds = new Set(getNodesInside(
      store().nodeLookup,
      nextUserSelectRect,
      [
        store().viewport.x,
        store().viewport.y,
        store().viewport.zoom
      ],
      strict_equals(store().selectionMode, SelectionMode.Partial),
      true
    ).map((n) => n.id));
    const edgesSelectable = store().defaultEdgeOptions.selectable ?? true;
    selectedEdgeIds = /* @__PURE__ */ new Set();
    for (const nodeId of selectedNodeIds) {
      const connections = store().connectionLookup.get(nodeId);
      if (!connections) continue;
      for (const { edgeId } of connections.values()) {
        const edge = store().edgeLookup.get(edgeId);
        if (edge && (edge.selectable ?? edgesSelectable)) {
          selectedEdgeIds.add(edgeId);
        }
      }
    }
    if (!isSetEqual(prevSelectedNodeIds, selectedNodeIds)) {
      $$ownership_validator.mutation("store", ["store", "nodes"], store(store().nodes = store().nodes.map(toggleSelected(selectedNodeIds)), true), 183, 6);
    }
    if (!isSetEqual(prevSelectedEdgeIds, selectedEdgeIds)) {
      $$ownership_validator.mutation("store", ["store", "edges"], store(store().edges = store().edges.map(toggleSelected(selectedEdgeIds)), true), 187, 6);
    }
    $$ownership_validator.mutation("store", ["store", "selectionRectMode"], store(store().selectionRectMode = "user", true), 190, 4);
    $$ownership_validator.mutation("store", ["store", "selectionRect"], store(store().selectionRect = nextUserSelectRect, true), 191, 4);
  }
  function onPointerUp(event2) {
    if (strict_equals(event2.button, 0, false)) {
      return;
    }
    event2.target?.releasePointerCapture?.(event2.pointerId);
    if (!selectionInProgress && strict_equals(event2.target, container)) {
      onClick?.(event2);
    }
    $$ownership_validator.mutation("store", ["store", "selectionRect"], store(store().selectionRect = null, true), 208, 4);
    if (selectionInProgress) {
      $$ownership_validator.mutation("store", ["store", "selectionRectMode"], store(store().selectionRectMode = selectedNodeIds.size > 0 ? "nodes" : null, true), 211, 6);
    }
    if (selectionInProgress) {
      $$props.onselectionend?.(event2);
    }
  }
  const onContextMenu = (event2) => {
    if (Array.isArray(get(panOnDragActive)) && get(panOnDragActive).includes(2)) {
      event2.preventDefault();
      return;
    }
    $$props.onpanecontextmenu?.({ event: event2 });
  };
  const onClickCapture = (event2) => {
    if (selectionInProgress) {
      event2.stopPropagation();
      selectionInProgress = false;
    }
  };
  function onClick(event2) {
    if (selectionInProgress || store().connection.inProgress) {
      selectionInProgress = false;
      return;
    }
    $$props.onpaneclick?.({ event: event2 });
    store().unselectNodesAndEdges();
    $$ownership_validator.mutation("store", ["store", "selectionRectMode"], store(store().selectionRectMode = null, true), 245, 4);
    $$ownership_validator.mutation("store", ["store", "selectionRect"], store(store().selectionRect = null, true), 246, 4);
  }
  var $$exports = { ...legacy_api() };
  var div = root9();
  let classes;
  var event_handler = user_derived(() => get(isSelectionEnabled) ? void 0 : wrapHandler(onClick, container));
  div.__click = function(...$$args) {
    apply(() => get(event_handler), this, $$args, Pane, [258, 11]);
  };
  div.__pointermove = function(...$$args) {
    apply(() => get(isSelectionEnabled) ? onPointerMove : void 0, this, $$args, Pane, [260, 17]);
  };
  div.__pointerup = function(...$$args) {
    apply(() => get(isSelectionEnabled) ? onPointerUp : void 0, this, $$args, Pane, [261, 15]);
  };
  var event_handler_1 = user_derived(() => wrapHandler(onContextMenu, container));
  div.__contextmenu = function(...$$args) {
    apply(() => get(event_handler_1), this, $$args, Pane, [262, 17], true);
  };
  var node = child(div);
  add_svelte_meta(() => snippet(node, () => $$props.children), "render", Pane, 265, 2);
  reset(div);
  bind_this(div, ($$value) => container = $$value, () => container);
  template_effect(($0) => classes = set_class(div, 1, "svelte-flow__pane svelte-flow__container", null, classes, $0), [
    () => ({
      draggable: strict_equals(panOnDrag(), true) || Array.isArray(panOnDrag()) && panOnDrag().includes(0),
      dragging: store().dragging,
      selection: get(isSelecting)
    })
  ]);
  event(
    "pointerdown",
    div,
    function(...$$args) {
      apply(() => get(isSelectionEnabled) ? onPointerDownCapture : void 0, this, $$args, Pane, [259, 24]);
    },
    true
  );
  event(
    "click",
    div,
    function(...$$args) {
      apply(() => get(isSelectionEnabled) ? onClickCapture : void 0, this, $$args, Pane, [263, 18]);
    },
    true
  );
  append($$anchor, div);
  return pop($$exports);
}
if (import.meta.hot) {
  Pane = hmr(Pane, () => Pane[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Pane[HMR].source;
    set(Pane[HMR].source, module.default[HMR].original);
  });
}
var Pane_default = Pane;
delegate(["click", "pointermove", "pointerup", "contextmenu"]);

// node_modules/@xyflow/svelte/dist/lib/container/Viewport/Viewport.svelte
Viewport[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/container/Viewport/Viewport.svelte";
var root10 = add_locations(from_html(`<div class="svelte-flow__viewport xyflow__viewport svelte-flow__container"><!></div>`), Viewport[FILENAME], [[12, 0]]);
function Viewport($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Viewport);
  var $$exports = { ...legacy_api() };
  var div = root10();
  let styles;
  var node = child(div);
  add_svelte_meta(() => snippet(node, () => $$props.children), "render", Viewport, 17, 2);
  reset(div);
  template_effect(() => styles = set_style(div, "", styles, {
    transform: `translate(${$$props.store.viewport.x ?? ""}px, ${$$props.store.viewport.y ?? ""}px) scale(${$$props.store.viewport.zoom ?? ""})`
  }));
  append($$anchor, div);
  return pop($$exports);
}
if (import.meta.hot) {
  Viewport = hmr(Viewport, () => Viewport[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Viewport[HMR].source;
    set(Viewport[HMR].source, module.default[HMR].original);
  });
}
var Viewport_default = Viewport;

// node_modules/@xyflow/svelte/dist/lib/actions/drag/index.js
function drag(domNode, params) {
  const { store, onDrag, onDragStart, onDragStop, onNodeMouseDown } = params;
  const dragInstance = XYDrag({
    onDrag,
    onDragStart,
    onDragStop,
    onNodeMouseDown,
    getStoreItems: () => {
      const { snapGrid, viewport } = store;
      return {
        nodes: store.nodes,
        nodeLookup: store.nodeLookup,
        edges: store.edges,
        nodeExtent: store.nodeExtent,
        snapGrid: snapGrid ? snapGrid : [0, 0],
        snapToGrid: !!snapGrid,
        nodeOrigin: store.nodeOrigin,
        multiSelectionActive: store.multiselectionKeyPressed,
        domNode: store.domNode,
        transform: [viewport.x, viewport.y, viewport.zoom],
        autoPanOnNodeDrag: store.autoPanOnNodeDrag,
        nodesDraggable: store.nodesDraggable,
        selectNodesOnDrag: store.selectNodesOnDrag,
        nodeDragThreshold: store.nodeDragThreshold,
        unselectNodesAndEdges: store.unselectNodesAndEdges,
        updateNodePositions: store.updateNodePositions,
        onSelectionDrag: store.onselectiondrag,
        onSelectionDragStart: store.onselectiondragstart,
        onSelectionDragStop: store.onselectiondragstop,
        panBy: store.panBy
      };
    }
  });
  function updateDrag(domNode2, params2) {
    if (params2.disabled) {
      dragInstance.destroy();
      return;
    }
    dragInstance.update({
      domNode: domNode2,
      noDragClassName: params2.noDragClass,
      handleSelector: params2.handleSelector,
      nodeId: params2.nodeId,
      isSelectable: params2.isSelectable,
      nodeClickDistance: params2.nodeClickDistance
    });
  }
  updateDrag(domNode, params);
  return {
    update(params2) {
      updateDrag(domNode, params2);
    },
    destroy() {
      dragInstance.destroy();
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/components/A11yDescriptions/A11yDescriptions.svelte
A11yDescriptions[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/A11yDescriptions/A11yDescriptions.svelte";
var root_12 = add_locations(from_html(`<div aria-live="assertive" aria-atomic="true" class="a11y-live-msg s-uH4WB6CY04Ys"> </div>`), A11yDescriptions[FILENAME], [[19, 2]]);
var root11 = add_locations(from_html(`<div class="a11y-hidden s-uH4WB6CY04Ys"> </div> <div class="a11y-hidden s-uH4WB6CY04Ys"> </div> <!>`, 1), A11yDescriptions[FILENAME], [[9, 0], [14, 0]]);
var $$css2 = {
  hash: "s-uH4WB6CY04Ys",
  code: "\n  .a11y-hidden.s-uH4WB6CY04Ys {\n    display: none;\n  }\n\n  .a11y-live-msg.s-uH4WB6CY04Ys {\n    position: absolute;\n    width: 1px;\n    height: 1px;\n    margin: -1px;\n    border: 0;\n    padding: 0;\n    overflow: hidden;\n    clip: rect(0px, 0px, 0px, 0px);\n    clip-path: inset(100%);\n  }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQTExeURlc2NyaXB0aW9ucy5zdmVsdGUiLCJzb3VyY2VzIjpbIkExMXlEZXNjcmlwdGlvbnMuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQgbGFuZz1cInRzXCIgZ2VuZXJpY3M9XCJOb2RlVHlwZSBleHRlbmRzIE5vZGUgPSBOb2RlLCBFZGdlVHlwZSBleHRlbmRzIEVkZ2UgPSBFZGdlXCI+XG4gIGltcG9ydCB0eXBlIHsgU3ZlbHRlRmxvd1N0b3JlIH0gZnJvbSAnLi4vLi4vc3RvcmUvdHlwZXMnO1xuICBpbXBvcnQgdHlwZSB7IE5vZGUsIEVkZ2UgfSBmcm9tICcuLi8uLi90eXBlcyc7XG4gIGltcG9ydCB7IEFSSUFfRURHRV9ERVNDX0tFWSwgQVJJQV9MSVZFX01FU1NBR0UsIEFSSUFfTk9ERV9ERVNDX0tFWSB9IGZyb20gJy4nO1xuXG4gIGxldCB7IHN0b3JlIH06IHsgc3RvcmU6IFN2ZWx0ZUZsb3dTdG9yZTxOb2RlVHlwZSwgRWRnZVR5cGU+IH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48ZGl2IGlkPXtgJHtBUklBX05PREVfREVTQ19LRVl9LSR7c3RvcmUuZmxvd0lkfWB9IGNsYXNzPVwiYTExeS1oaWRkZW5cIj5cbiAge3N0b3JlLmRpc2FibGVLZXlib2FyZEExMXlcbiAgICA/IHN0b3JlLmFyaWFMYWJlbENvbmZpZ1snbm9kZS5hMTF5RGVzY3JpcHRpb24uZGVmYXVsdCddXG4gICAgOiBzdG9yZS5hcmlhTGFiZWxDb25maWdbJ25vZGUuYTExeURlc2NyaXB0aW9uLmtleWJvYXJkRGlzYWJsZWQnXX1cbjwvZGl2PlxuPGRpdiBpZD17YCR7QVJJQV9FREdFX0RFU0NfS0VZfS0ke3N0b3JlLmZsb3dJZH1gfSBjbGFzcz1cImExMXktaGlkZGVuXCI+XG4gIHtzdG9yZS5hcmlhTGFiZWxDb25maWdbJ2VkZ2UuYTExeURlc2NyaXB0aW9uLmRlZmF1bHQnXX1cbjwvZGl2PlxuXG57I2lmICFzdG9yZS5kaXNhYmxlS2V5Ym9hcmRBMTF5fVxuICA8ZGl2XG4gICAgaWQ9e2Ake0FSSUFfTElWRV9NRVNTQUdFfS0ke3N0b3JlLmZsb3dJZH1gfVxuICAgIGFyaWEtbGl2ZT1cImFzc2VydGl2ZVwiXG4gICAgYXJpYS1hdG9taWM9XCJ0cnVlXCJcbiAgICBjbGFzcz1cImExMXktbGl2ZS1tc2dcIlxuICA+XG4gICAge3N0b3JlLmFyaWFMaXZlTWVzc2FnZX1cbiAgPC9kaXY+XG57L2lmfVxuXG48c3R5bGU+XG4gIC5hMTF5LWhpZGRlbiB7XG4gICAgZGlzcGxheTogbm9uZTtcbiAgfVxuXG4gIC5hMTF5LWxpdmUtbXNnIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgd2lkdGg6IDFweDtcbiAgICBoZWlnaHQ6IDFweDtcbiAgICBtYXJnaW46IC0xcHg7XG4gICAgYm9yZGVyOiAwO1xuICAgIHBhZGRpbmc6IDA7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICBjbGlwOiByZWN0KDBweCwgMHB4LCAwcHgsIDBweCk7XG4gICAgY2xpcC1wYXRoOiBpbnNldCgxMDAlKTtcbiAgfVxuPC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwiaWdub3JlTGlzdCI6W119 */"
};
function A11yDescriptions($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, A11yDescriptions);
  append_styles($$anchor, $$css2);
  var $$exports = { ...legacy_api() };
  var fragment = root11();
  var div = first_child(fragment);
  var text2 = child(div, true);
  reset(div);
  var div_1 = sibling(div, 2);
  var text_1 = child(div_1, true);
  reset(div_1);
  var node = sibling(div_1, 2);
  {
    var consequent = ($$anchor2) => {
      var div_2 = root_12();
      var text_2 = child(div_2, true);
      reset(div_2);
      template_effect(() => {
        set_attribute(div_2, "id", `${ARIA_LIVE_MESSAGE}-${$$props.store.flowId}`);
        set_text(text_2, $$props.store.ariaLiveMessage);
      });
      append($$anchor2, div_2);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (!$$props.store.disableKeyboardA11y) $$render(consequent);
      }),
      "if",
      A11yDescriptions,
      18,
      0
    );
  }
  template_effect(() => {
    set_attribute(div, "id", `${ARIA_NODE_DESC_KEY}-${$$props.store.flowId}`);
    set_text(text2, $$props.store.disableKeyboardA11y ? $$props.store.ariaLabelConfig["node.a11yDescription.default"] : $$props.store.ariaLabelConfig["node.a11yDescription.keyboardDisabled"]);
    set_attribute(div_1, "id", `${ARIA_EDGE_DESC_KEY}-${$$props.store.flowId}`);
    set_text(text_1, $$props.store.ariaLabelConfig["edge.a11yDescription.default"]);
  });
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  A11yDescriptions = hmr(A11yDescriptions, () => A11yDescriptions[HMR].source);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-uH4WB6CY04Ys");
    module.default[HMR].source = A11yDescriptions[HMR].source;
    set(A11yDescriptions[HMR].source, module.default[HMR].original);
  });
}
var A11yDescriptions_default = A11yDescriptions;

// node_modules/@xyflow/svelte/dist/lib/components/A11yDescriptions/index.js
var ARIA_NODE_DESC_KEY = "svelte-flow__node-desc";
var ARIA_EDGE_DESC_KEY = "svelte-flow__edge-desc";
var ARIA_LIVE_MESSAGE = "svelte-flow__aria-live";

// node_modules/@xyflow/svelte/dist/lib/components/NodeWrapper/NodeWrapper.svelte
NodeWrapper[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/NodeWrapper/NodeWrapper.svelte";
var root_13 = add_locations(from_html(`<div><!></div>`), NodeWrapper[FILENAME], [[234, 2]]);
function NodeWrapper($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, NodeWrapper);
  var $$ownership_validator = create_ownership_validator($$props);
  let store = prop($$props, "store", 15);
  let data = tag(user_derived(() => fallback($$props.node.data, () => ({}), true)), "data"), selected = tag(user_derived(() => fallback($$props.node.selected, false)), "selected"), _draggable = tag(user_derived(() => $$props.node.draggable), "_draggable"), _selectable = tag(user_derived(() => $$props.node.selectable), "_selectable"), deletable = tag(user_derived(() => fallback($$props.node.deletable, true)), "deletable"), _connectable = tag(user_derived(() => $$props.node.connectable), "_connectable"), _focusable = tag(user_derived(() => $$props.node.focusable), "_focusable"), hidden = tag(user_derived(() => fallback($$props.node.hidden, false)), "hidden"), dragging = tag(user_derived(() => fallback($$props.node.dragging, false)), "dragging"), style = tag(user_derived(() => fallback($$props.node.style, "")), "style"), className = tag(user_derived(() => $$props.node.class), "className"), type = tag(user_derived(() => fallback($$props.node.type, "default")), "type"), parentId = tag(user_derived(() => $$props.node.parentId), "parentId"), sourcePosition = tag(user_derived(() => $$props.node.sourcePosition), "sourcePosition"), targetPosition = tag(user_derived(() => $$props.node.targetPosition), "targetPosition"), measuredWidth = tag(user_derived(() => fallback($$props.node.measured, () => ({ width: 0, height: 0 }), true).width), "measuredWidth"), measuredHeight = tag(user_derived(() => fallback($$props.node.measured, () => ({ width: 0, height: 0 }), true).height), "measuredHeight"), initialWidth = tag(user_derived(() => $$props.node.initialWidth), "initialWidth"), initialHeight = tag(user_derived(() => $$props.node.initialHeight), "initialHeight"), width = tag(user_derived(() => $$props.node.width), "width"), height = tag(user_derived(() => $$props.node.height), "height"), dragHandle = tag(user_derived(() => $$props.node.dragHandle), "dragHandle"), zIndex = tag(user_derived(() => fallback($$props.node.internals.z, 0)), "zIndex"), positionX = tag(user_derived(() => $$props.node.internals.positionAbsolute.x), "positionX"), positionY = tag(user_derived(() => $$props.node.internals.positionAbsolute.y), "positionY"), userNode = tag(user_derived(() => $$props.node.internals.userNode), "userNode");
  let { id: id2 } = $$props.node;
  let draggable = tag(user_derived(() => get(_draggable) ?? store().nodesDraggable), "draggable");
  let selectable = tag(user_derived(() => get(_selectable) ?? store().elementsSelectable), "selectable");
  let connectable = tag(user_derived(() => get(_connectable) ?? store().nodesConnectable), "connectable");
  let hasDimensions = tag(user_derived(() => nodeHasDimensions($$props.node)), "hasDimensions");
  let hasHandleBounds = tag(user_derived(() => !!$$props.node.internals.handleBounds), "hasHandleBounds");
  let isInitialized = tag(user_derived(() => get(hasDimensions) && get(hasHandleBounds)), "isInitialized");
  let focusable = tag(user_derived(() => get(_focusable) ?? store().nodesFocusable), "focusable");
  function isInParentLookup(id3) {
    return store().parentLookup.has(id3);
  }
  let isParent = tag(user_derived(() => isInParentLookup(id2)), "isParent");
  let nodeRef = tag(state(null), "nodeRef");
  let prevNodeRef = null;
  let prevType = get(type);
  let prevSourcePosition = get(sourcePosition);
  let prevTargetPosition = get(targetPosition);
  let NodeComponent = tag(user_derived(() => store().nodeTypes[get(type)] ?? DefaultNode_default), "NodeComponent");
  let ariaLabelConfig = tag(user_derived(() => store().ariaLabelConfig), "ariaLabelConfig");
  let connectableContext = {
    get value() {
      return get(connectable);
    }
  };
  setContext("svelteflow__node_connectable", connectableContext);
  setContext("svelteflow__node_id", id2);
  if (strict_equals("development", "development")) {
    user_effect(() => {
      const valid = !!store().nodeTypes[get(type)];
      if (!valid) {
        console.warn(...log_if_contains_state("warn", "003", errorMessages["error003"](get(type))));
      }
    });
  }
  let nodeStyle = tag(
    user_derived(() => {
      const w = strict_equals(get(measuredWidth), void 0) ? get(width) ?? get(initialWidth) : get(width);
      const h = strict_equals(get(measuredHeight), void 0) ? get(height) ?? get(initialHeight) : get(height);
      if (strict_equals(w, void 0) && strict_equals(h, void 0) && strict_equals(get(style), void 0)) {
        return void 0;
      }
      return `${get(style)};${w ? `width:${toPxString(w)};` : ""}${h ? `height:${toPxString(h)};` : ""}`;
    }),
    "nodeStyle"
  );
  user_effect(() => {
    const doUpdate = strict_equals(get(type), prevType, false) || strict_equals(get(sourcePosition), prevSourcePosition, false) || strict_equals(get(targetPosition), prevTargetPosition, false);
    if (doUpdate && strict_equals(get(nodeRef), null, false)) {
      requestAnimationFrame(() => {
        if (strict_equals(get(nodeRef), null, false)) {
          store().updateNodeInternals(/* @__PURE__ */ new Map([[id2, { id: id2, nodeElement: get(nodeRef), force: true }]]));
        }
      });
    }
    prevType = get(type);
    prevSourcePosition = get(sourcePosition);
    prevTargetPosition = get(targetPosition);
  });
  user_effect(() => {
    if ($$props.resizeObserver && (!get(isInitialized) || strict_equals(get(nodeRef), prevNodeRef, false))) {
      prevNodeRef && $$props.resizeObserver.unobserve(prevNodeRef);
      get(nodeRef) && $$props.resizeObserver.observe(get(nodeRef));
      prevNodeRef = get(nodeRef);
    }
  });
  onDestroy(() => {
    if (prevNodeRef) {
      $$props.resizeObserver?.unobserve(prevNodeRef);
    }
  });
  function onSelectNodeHandler(event2) {
    if (get(selectable) && (!store().selectNodesOnDrag || !get(draggable) || store().nodeDragThreshold > 0)) {
      store().handleNodeSelection(id2);
    }
    $$props.onnodeclick?.({ node: get(userNode), event: event2 });
  }
  function onKeyDown(event2) {
    if (isInputDOMNode(event2) || store().disableKeyboardA11y) {
      return;
    }
    if (elementSelectionKeys.includes(event2.key) && get(selectable)) {
      const unselect = strict_equals(event2.key, "Escape");
      store().handleNodeSelection(id2, unselect, get(nodeRef));
    } else if (get(draggable) && $$props.node.selected && Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event2.key)) {
      event2.preventDefault();
      $$ownership_validator.mutation(
        "store",
        ["store", "ariaLiveMessage"],
        store(
          store().ariaLiveMessage = get(ariaLabelConfig)["node.a11yDescription.ariaLiveMessage"]({
            direction: event2.key.replace("Arrow", "").toLowerCase(),
            x: ~~$$props.node.internals.positionAbsolute.x,
            y: ~~$$props.node.internals.positionAbsolute.y
          }),
          true
        ),
        195,
        6
      );
      store().moveSelectedNodes(arrowKeyDiffs[event2.key], event2.shiftKey ? 4 : 1);
    }
  }
  const onFocus = () => {
    if (store().disableKeyboardA11y || !store().autoPanOnNodeFocus || !get(nodeRef)?.matches(":focus-visible")) {
      return;
    }
    const { width: width2, height: height2, viewport } = store();
    const withinViewport = getNodesInside(/* @__PURE__ */ new Map([[id2, $$props.node]]), { x: 0, y: 0, width: width2, height: height2 }, [viewport.x, viewport.y, viewport.zoom], true).length > 0;
    if (!withinViewport) {
      store().setCenter($$props.node.position.x + ($$props.node.measured.width ?? 0) / 2, $$props.node.position.y + ($$props.node.measured.height ?? 0) / 2, { zoom: viewport.zoom });
    }
  };
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node_1 = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var div = root_13();
      attribute_effect(div, () => ({
        "data-id": id2,
        class: [
          "svelte-flow__node",
          `svelte-flow__node-${get(type)}`,
          get(className)
        ],
        style: get(nodeStyle),
        onclick: onSelectNodeHandler,
        onpointerenter: $$props.onnodepointerenter ? (event2) => $$props.onnodepointerenter({ node: get(userNode), event: event2 }) : void 0,
        onpointerleave: $$props.onnodepointerleave ? (event2) => $$props.onnodepointerleave({ node: get(userNode), event: event2 }) : void 0,
        onpointermove: $$props.onnodepointermove ? (event2) => $$props.onnodepointermove({ node: get(userNode), event: event2 }) : void 0,
        oncontextmenu: $$props.onnodecontextmenu ? (event2) => $$props.onnodecontextmenu({ node: get(userNode), event: event2 }) : void 0,
        onkeydown: get(focusable) ? onKeyDown : void 0,
        onfocus: get(focusable) ? onFocus : void 0,
        tabIndex: get(focusable) ? 0 : void 0,
        role: $$props.node.ariaRole ?? (get(focusable) ? "group" : void 0),
        "aria-roledescription": "node",
        "aria-describedby": store().disableKeyboardA11y ? void 0 : `${ARIA_NODE_DESC_KEY}-${store().flowId}`,
        ...$$props.node.domAttributes,
        [CLASS]: {
          dragging: get(dragging),
          selected: get(selected),
          draggable: get(draggable),
          connectable: get(connectable),
          selectable: get(selectable),
          nopan: get(draggable),
          parent: get(isParent)
        },
        [STYLE]: {
          "z-index": get(zIndex),
          transform: `translate(${get(positionX) ?? ""}px, ${get(positionY) ?? ""}px)`,
          visibility: get(hasDimensions) ? "visible" : "hidden"
        }
      }));
      var node_2 = child(div);
      add_svelte_meta(
        () => component(node_2, () => get(NodeComponent), ($$anchor3, NodeComponent_1) => {
          NodeComponent_1($$anchor3, {
            get data() {
              return get(data);
            },
            get id() {
              return id2;
            },
            get selected() {
              return get(selected);
            },
            get selectable() {
              return get(selectable);
            },
            get deletable() {
              return get(deletable);
            },
            get sourcePosition() {
              return get(sourcePosition);
            },
            get targetPosition() {
              return get(targetPosition);
            },
            get zIndex() {
              return get(zIndex);
            },
            get dragging() {
              return get(dragging);
            },
            get draggable() {
              return get(draggable);
            },
            get dragHandle() {
              return get(dragHandle);
            },
            get parentId() {
              return get(parentId);
            },
            get type() {
              return get(type);
            },
            get isConnectable() {
              return get(connectable);
            },
            get positionAbsoluteX() {
              return get(positionX);
            },
            get positionAbsoluteY() {
              return get(positionY);
            },
            get width() {
              return get(width);
            },
            get height() {
              return get(height);
            }
          });
        }),
        "component",
        NodeWrapper,
        295,
        4,
        { componentTag: "NodeComponent" }
      );
      reset(div);
      action(div, ($$node, $$action_arg) => drag?.($$node, $$action_arg), () => ({
        nodeId: id2,
        isSelectable: get(selectable),
        disabled: !get(draggable),
        handleSelector: get(dragHandle),
        noDragClass: store().noDragClass,
        nodeClickDistance: $$props.nodeClickDistance,
        onNodeMouseDown: store().handleNodeSelection,
        onDrag: (event2, _, targetNode, nodes) => {
          $$props.onnodedrag?.({ event: event2, targetNode, nodes });
        },
        onDragStart: (event2, _, targetNode, nodes) => {
          $$props.onnodedragstart?.({ event: event2, targetNode, nodes });
        },
        onDragStop: (event2, _, targetNode, nodes) => {
          $$props.onnodedragstop?.({ event: event2, targetNode, nodes });
        },
        store: store()
      }));
      bind_this(div, ($$value) => set(nodeRef, $$value), () => get(nodeRef));
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        if (!get(hidden)) $$render(consequent);
      }),
      "if",
      NodeWrapper,
      233,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  NodeWrapper = hmr(NodeWrapper, () => NodeWrapper[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = NodeWrapper[HMR].source;
    set(NodeWrapper[HMR].source, module.default[HMR].original);
  });
}
var NodeWrapper_default = NodeWrapper;

// node_modules/@xyflow/svelte/dist/lib/container/NodeRenderer/NodeRenderer.svelte
NodeRenderer[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/container/NodeRenderer/NodeRenderer.svelte";
var root12 = add_locations(from_html(`<div class="svelte-flow__nodes"></div>`), NodeRenderer[FILENAME], [[50, 0]]);
function NodeRenderer($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, NodeRenderer);
  var $$ownership_validator = create_ownership_validator($$props);
  let store = prop($$props, "store", 15);
  const resizeObserver = strict_equals(typeof ResizeObserver, "undefined") ? null : new ResizeObserver((entries) => {
    const updates = /* @__PURE__ */ new Map();
    entries.forEach((entry) => {
      const id2 = entry.target.getAttribute("data-id");
      updates.set(id2, { id: id2, nodeElement: entry.target, force: true });
    });
    store().updateNodeInternals(updates);
  });
  onDestroy(() => {
    resizeObserver?.disconnect();
  });
  var $$exports = { ...legacy_api() };
  var div = root12();
  validate_each_keys(() => store().visible.nodes.values(), (node) => node.id);
  add_svelte_meta(
    () => each(div, 21, () => store().visible.nodes.values(), (node) => node.id, ($$anchor2, node) => {
      var fragment = comment();
      var node_1 = first_child(fragment);
      {
        $$ownership_validator.binding("store", NodeWrapper_default, store);
        add_svelte_meta(
          () => NodeWrapper_default(node_1, {
            get node() {
              return get(node);
            },
            get resizeObserver() {
              return resizeObserver;
            },
            get nodeClickDistance() {
              return $$props.nodeClickDistance;
            },
            get onnodeclick() {
              return $$props.onnodeclick;
            },
            get onnodepointerenter() {
              return $$props.onnodepointerenter;
            },
            get onnodepointermove() {
              return $$props.onnodepointermove;
            },
            get onnodepointerleave() {
              return $$props.onnodepointerleave;
            },
            get onnodedrag() {
              return $$props.onnodedrag;
            },
            get onnodedragstart() {
              return $$props.onnodedragstart;
            },
            get onnodedragstop() {
              return $$props.onnodedragstop;
            },
            get onnodecontextmenu() {
              return $$props.onnodecontextmenu;
            },
            get store() {
              return store();
            },
            set store($$value) {
              store($$value);
            }
          }),
          "component",
          NodeRenderer,
          52,
          4,
          { componentTag: "NodeWrapper" }
        );
      }
      append($$anchor2, fragment);
    }),
    "each",
    NodeRenderer,
    51,
    2
  );
  reset(div);
  append($$anchor, div);
  return pop($$exports);
}
if (import.meta.hot) {
  NodeRenderer = hmr(NodeRenderer, () => NodeRenderer[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = NodeRenderer[HMR].source;
    set(NodeRenderer[HMR].source, module.default[HMR].original);
  });
}
var NodeRenderer_default = NodeRenderer;

// node_modules/@xyflow/svelte/dist/lib/components/EdgeWrapper/EdgeWrapper.svelte
EdgeWrapper[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/EdgeWrapper/EdgeWrapper.svelte";
var root_14 = add_locations(from_svg(`<svg class="svelte-flow__edge-wrapper"><g><!></g></svg>`), EdgeWrapper[FILENAME], [[109, 2, [[110, 4]]]]);
function EdgeWrapper($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, EdgeWrapper);
  let source = tag(user_derived(() => $$props.edge.source), "source"), target = tag(user_derived(() => $$props.edge.target), "target"), sourceX = tag(user_derived(() => $$props.edge.sourceX), "sourceX"), sourceY = tag(user_derived(() => $$props.edge.sourceY), "sourceY"), targetX = tag(user_derived(() => $$props.edge.targetX), "targetX"), targetY = tag(user_derived(() => $$props.edge.targetY), "targetY"), sourcePosition = tag(user_derived(() => $$props.edge.sourcePosition), "sourcePosition"), targetPosition = tag(user_derived(() => $$props.edge.targetPosition), "targetPosition"), animated = tag(user_derived(() => fallback($$props.edge.animated, false)), "animated"), selected = tag(user_derived(() => fallback($$props.edge.selected, false)), "selected"), label = tag(user_derived(() => $$props.edge.label), "label"), labelStyle = tag(user_derived(() => $$props.edge.labelStyle), "labelStyle"), data = tag(user_derived(() => fallback($$props.edge.data, () => ({}), true)), "data"), style = tag(user_derived(() => $$props.edge.style), "style"), interactionWidth = tag(user_derived(() => $$props.edge.interactionWidth), "interactionWidth"), type = tag(user_derived(() => fallback($$props.edge.type, "default")), "type"), sourceHandle = tag(user_derived(() => $$props.edge.sourceHandle), "sourceHandle"), targetHandle = tag(user_derived(() => $$props.edge.targetHandle), "targetHandle"), markerStart = tag(user_derived(() => $$props.edge.markerStart), "markerStart"), markerEnd = tag(user_derived(() => $$props.edge.markerEnd), "markerEnd"), _selectable = tag(user_derived(() => $$props.edge.selectable), "_selectable"), _focusable = tag(user_derived(() => $$props.edge.focusable), "_focusable"), deletable = tag(user_derived(() => fallback($$props.edge.deletable, true)), "deletable"), hidden = tag(user_derived(() => $$props.edge.hidden), "hidden"), zIndex = tag(user_derived(() => $$props.edge.zIndex), "zIndex"), className = tag(user_derived(() => $$props.edge.class), "className"), ariaLabel = tag(user_derived(() => $$props.edge.ariaLabel), "ariaLabel");
  let edgeRef = null;
  const { id: id2 } = $$props.edge;
  setContext("svelteflow__edge_id", id2);
  let selectable = tag(user_derived(() => get(_selectable) ?? $$props.store.elementsSelectable), "selectable");
  let focusable = tag(user_derived(() => get(_focusable) ?? $$props.store.edgesFocusable), "focusable");
  let EdgeComponent = tag(user_derived(() => $$props.store.edgeTypes[get(type)] ?? BezierEdge_default), "EdgeComponent");
  let markerStartUrl = tag(
    user_derived(() => get(markerStart) ? `url('#${getMarkerId(get(markerStart), $$props.store.flowId)}')` : void 0),
    "markerStartUrl"
  );
  let markerEndUrl = tag(
    user_derived(() => get(markerEnd) ? `url('#${getMarkerId(get(markerEnd), $$props.store.flowId)}')` : void 0),
    "markerEndUrl"
  );
  function onclick(event2) {
    const edge = $$props.store.edgeLookup.get(id2);
    if (edge) {
      if (get(selectable)) $$props.store.handleEdgeSelection(id2);
      $$props.onedgeclick?.({ event: event2, edge });
    }
  }
  function onmouseevent(event2, callback) {
    const edge = $$props.store.edgeLookup.get(id2);
    if (edge) {
      callback({ event: event2, edge });
    }
  }
  function onkeydown(event2) {
    if (!$$props.store.disableKeyboardA11y && elementSelectionKeys.includes(event2.key) && get(selectable)) {
      const { unselectNodesAndEdges, addSelectedEdges } = $$props.store;
      const unselect = strict_equals(event2.key, "Escape");
      if (unselect) {
        edgeRef?.blur();
        unselectNodesAndEdges({ edges: [$$props.edge] });
      } else {
        addSelectedEdges([id2]);
      }
    }
  }
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var svg = root_14();
      let styles;
      var g = child(svg);
      attribute_effect(g, () => ({
        class: ["svelte-flow__edge", get(className)],
        "data-id": id2,
        onclick,
        oncontextmenu: $$props.onedgecontextmenu ? (e) => {
          onmouseevent(e, $$props.onedgecontextmenu);
        } : void 0,
        onpointerenter: $$props.onedgepointerenter ? (e) => {
          onmouseevent(e, $$props.onedgepointerenter);
        } : void 0,
        onpointerleave: $$props.onedgepointerleave ? (e) => {
          onmouseevent(e, $$props.onedgepointerleave);
        } : void 0,
        "aria-label": strict_equals(get(ariaLabel), null) ? void 0 : get(ariaLabel) ? get(ariaLabel) : `Edge from ${get(source)} to ${get(target)}`,
        "aria-describedby": get(focusable) ? `${ARIA_EDGE_DESC_KEY}-${$$props.store.flowId}` : void 0,
        role: $$props.edge.ariaRole ?? (get(focusable) ? "group" : "img"),
        "aria-roledescription": "edge",
        onkeydown: get(focusable) ? onkeydown : void 0,
        tabindex: get(focusable) ? 0 : void 0,
        ...$$props.edge.domAttributes,
        [CLASS]: {
          animated: get(animated),
          selected: get(selected),
          selectable: get(selectable)
        }
      }));
      var node_1 = child(g);
      add_svelte_meta(
        () => component(node_1, () => get(EdgeComponent), ($$anchor3, EdgeComponent_1) => {
          EdgeComponent_1($$anchor3, {
            get id() {
              return id2;
            },
            get source() {
              return get(source);
            },
            get target() {
              return get(target);
            },
            get sourceX() {
              return get(sourceX);
            },
            get sourceY() {
              return get(sourceY);
            },
            get targetX() {
              return get(targetX);
            },
            get targetY() {
              return get(targetY);
            },
            get sourcePosition() {
              return get(sourcePosition);
            },
            get targetPosition() {
              return get(targetPosition);
            },
            get animated() {
              return get(animated);
            },
            get selected() {
              return get(selected);
            },
            get label() {
              return get(label);
            },
            get labelStyle() {
              return get(labelStyle);
            },
            get data() {
              return get(data);
            },
            get style() {
              return get(style);
            },
            get interactionWidth() {
              return get(interactionWidth);
            },
            get selectable() {
              return get(selectable);
            },
            get deletable() {
              return get(deletable);
            },
            get type() {
              return get(type);
            },
            get sourceHandleId() {
              return get(sourceHandle);
            },
            get targetHandleId() {
              return get(targetHandle);
            },
            get markerStart() {
              return get(markerStartUrl);
            },
            get markerEnd() {
              return get(markerEndUrl);
            }
          });
        }),
        "component",
        EdgeWrapper,
        145,
        6,
        { componentTag: "EdgeComponent" }
      );
      reset(g);
      bind_this(g, ($$value) => edgeRef = $$value, () => edgeRef);
      reset(svg);
      template_effect(() => styles = set_style(svg, "", styles, { "z-index": get(zIndex) }));
      append($$anchor2, svg);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (!get(hidden)) $$render(consequent);
      }),
      "if",
      EdgeWrapper,
      108,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  EdgeWrapper = hmr(EdgeWrapper, () => EdgeWrapper[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = EdgeWrapper[HMR].source;
    set(EdgeWrapper[HMR].source, module.default[HMR].original);
  });
}
var EdgeWrapper_default = EdgeWrapper;

// node_modules/@xyflow/svelte/dist/lib/container/EdgeRenderer/MarkerDefinition/MarkerDefinition.svelte
MarkerDefinition[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/container/EdgeRenderer/MarkerDefinition/MarkerDefinition.svelte";
var root13 = add_locations(from_svg(`<defs></defs>`), MarkerDefinition[FILENAME], [[8, 0]]);
function MarkerDefinition($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, MarkerDefinition);
  const store = useStore();
  var $$exports = { ...legacy_api() };
  init();
  var defs = root13();
  validate_each_keys(() => store.markers, (marker) => marker.id);
  add_svelte_meta(
    () => each(defs, 5, () => store.markers, (marker) => marker.id, ($$anchor2, marker) => {
      var fragment = comment();
      var node = first_child(fragment);
      add_svelte_meta(() => Marker_default(node, spread_props(() => get(marker))), "component", MarkerDefinition, 10, 4, { componentTag: "Marker" });
      append($$anchor2, fragment);
    }),
    "each",
    MarkerDefinition,
    9,
    2
  );
  reset(defs);
  append($$anchor, defs);
  return pop($$exports);
}
if (import.meta.hot) {
  MarkerDefinition = hmr(MarkerDefinition, () => MarkerDefinition[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MarkerDefinition[HMR].source;
    set(MarkerDefinition[HMR].source, module.default[HMR].original);
  });
}
var MarkerDefinition_default = MarkerDefinition;

// node_modules/@xyflow/svelte/dist/lib/container/EdgeRenderer/MarkerDefinition/Marker.svelte
Marker[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/container/EdgeRenderer/MarkerDefinition/Marker.svelte";
var root_15 = add_locations(from_svg(`<polyline class="arrow" fill="none" stroke-linecap="round" stroke-linejoin="round" points="-5,-4 0,0 -5,4"></polyline>`), Marker[FILENAME], [[28, 4]]);
var root_3 = add_locations(from_svg(`<polyline class="arrowclosed" stroke-linecap="round" stroke-linejoin="round" points="-5,-4 0,0 -5,4 -5,-4"></polyline>`), Marker[FILENAME], [[38, 4]]);
var root14 = add_locations(from_svg(`<marker class="svelte-flow__arrowhead" viewBox="-10 -10 20 20" refX="0" refY="0"><!></marker>`), Marker[FILENAME], [[16, 0]]);
function Marker($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Marker);
  let width = prop($$props, "width", 3, 12.5), height = prop($$props, "height", 3, 12.5), markerUnits = prop($$props, "markerUnits", 3, "strokeWidth"), orient = prop($$props, "orient", 3, "auto-start-reverse"), color2 = prop($$props, "color", 3, "none");
  var $$exports = { ...legacy_api() };
  var marker = root14();
  var node = child(marker);
  {
    var consequent = ($$anchor2) => {
      var polyline = root_15();
      let styles;
      template_effect(() => {
        set_attribute(polyline, "stroke-width", $$props.strokeWidth);
        styles = set_style(polyline, "", styles, { stroke: color2() });
      });
      append($$anchor2, polyline);
    };
    var alternate = ($$anchor2) => {
      var fragment = comment();
      var node_1 = first_child(fragment);
      {
        var consequent_1 = ($$anchor3) => {
          var polyline_1 = root_3();
          let styles_1;
          template_effect(() => {
            set_attribute(polyline_1, "stroke-width", $$props.strokeWidth);
            styles_1 = set_style(polyline_1, "", styles_1, { stroke: color2(), fill: color2() });
          });
          append($$anchor3, polyline_1);
        };
        add_svelte_meta(
          () => if_block(
            node_1,
            ($$render) => {
              if (strict_equals($$props.type, MarkerType.ArrowClosed)) $$render(consequent_1);
            },
            true
          ),
          "if",
          Marker,
          37,
          2
        );
      }
      append($$anchor2, fragment);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (strict_equals($$props.type, MarkerType.Arrow)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Marker,
      27,
      2
    );
  }
  reset(marker);
  template_effect(() => {
    set_attribute(marker, "id", $$props.id);
    set_attribute(marker, "markerWidth", `${width()}`);
    set_attribute(marker, "markerHeight", `${height()}`);
    set_attribute(marker, "markerUnits", markerUnits());
    set_attribute(marker, "orient", orient());
  });
  append($$anchor, marker);
  return pop($$exports);
}
if (import.meta.hot) {
  Marker = hmr(Marker, () => Marker[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Marker[HMR].source;
    set(Marker[HMR].source, module.default[HMR].original);
  });
}
var Marker_default = Marker;

// node_modules/@xyflow/svelte/dist/lib/container/EdgeRenderer/EdgeRenderer.svelte
EdgeRenderer[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/container/EdgeRenderer/EdgeRenderer.svelte";
var root15 = add_locations(from_html(`<div class="svelte-flow__edges"><svg class="svelte-flow__marker"><!></svg> <!></div>`), EdgeRenderer[FILENAME], [[16, 0, [[17, 2]]]]);
function EdgeRenderer($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, EdgeRenderer);
  var $$ownership_validator = create_ownership_validator($$props);
  let store = prop($$props, "store", 15);
  var $$exports = { ...legacy_api() };
  var div = root15();
  var svg = child(div);
  var node = child(svg);
  add_svelte_meta(() => MarkerDefinition_default(node, {}), "component", EdgeRenderer, 18, 4, { componentTag: "MarkerDefinition" });
  reset(svg);
  var node_1 = sibling(svg, 2);
  validate_each_keys(() => store().visible.edges.values(), (edge) => edge.id);
  add_svelte_meta(
    () => each(node_1, 17, () => store().visible.edges.values(), (edge) => edge.id, ($$anchor2, edge) => {
      var fragment = comment();
      var node_2 = first_child(fragment);
      {
        $$ownership_validator.binding("store", EdgeWrapper_default, store);
        add_svelte_meta(
          () => EdgeWrapper_default(node_2, {
            get edge() {
              return get(edge);
            },
            get onedgeclick() {
              return $$props.onedgeclick;
            },
            get onedgecontextmenu() {
              return $$props.onedgecontextmenu;
            },
            get onedgepointerenter() {
              return $$props.onedgepointerenter;
            },
            get onedgepointerleave() {
              return $$props.onedgepointerleave;
            },
            get store() {
              return store();
            },
            set store($$value) {
              store($$value);
            }
          }),
          "component",
          EdgeRenderer,
          22,
          4,
          { componentTag: "EdgeWrapper" }
        );
      }
      append($$anchor2, fragment);
    }),
    "each",
    EdgeRenderer,
    21,
    2
  );
  reset(div);
  append($$anchor, div);
  return pop($$exports);
}
if (import.meta.hot) {
  EdgeRenderer = hmr(EdgeRenderer, () => EdgeRenderer[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = EdgeRenderer[HMR].source;
    set(EdgeRenderer[HMR].source, module.default[HMR].original);
  });
}
var EdgeRenderer_default = EdgeRenderer;

// node_modules/@xyflow/svelte/dist/lib/components/Selection/Selection.svelte
Selection3[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/Selection/Selection.svelte";
var root_16 = add_locations(from_html(`<div class="svelte-flow__selection s-oTKPzM3FNot7"></div>`), Selection3[FILENAME], [[20, 2]]);
var $$css3 = {
  hash: "s-oTKPzM3FNot7",
  code: "\n  .svelte-flow__selection.s-oTKPzM3FNot7 {\n    position: absolute;\n    top: 0;\n    left: 0;\n  }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2VsZWN0aW9uLnN2ZWx0ZSIsInNvdXJjZXMiOlsiU2VsZWN0aW9uLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuICBpbXBvcnQgeyB0b1B4U3RyaW5nIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuXG4gIGxldCB7XG4gICAgeCA9IDAsXG4gICAgeSA9IDAsXG4gICAgd2lkdGggPSAwLFxuICAgIGhlaWdodCA9IDAsXG4gICAgaXNWaXNpYmxlID0gdHJ1ZVxuICB9OiB7XG4gICAgeD86IG51bWJlcjtcbiAgICB5PzogbnVtYmVyO1xuICAgIHdpZHRoPzogbnVtYmVyIHwgc3RyaW5nO1xuICAgIGhlaWdodD86IG51bWJlciB8IHN0cmluZztcbiAgICBpc1Zpc2libGU/OiBib29sZWFuO1xuICB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxueyNpZiBpc1Zpc2libGV9XG4gIDxkaXZcbiAgICBjbGFzcz1cInN2ZWx0ZS1mbG93X19zZWxlY3Rpb25cIlxuICAgIHN0eWxlOndpZHRoPXt0eXBlb2Ygd2lkdGggPT09ICdzdHJpbmcnID8gd2lkdGggOiB0b1B4U3RyaW5nKHdpZHRoKX1cbiAgICBzdHlsZTpoZWlnaHQ9e3R5cGVvZiBoZWlnaHQgPT09ICdzdHJpbmcnID8gaGVpZ2h0IDogdG9QeFN0cmluZyhoZWlnaHQpfVxuICAgIHN0eWxlOnRyYW5zZm9ybT17YHRyYW5zbGF0ZSgke3h9cHgsICR7eX1weClgfVxuICA+PC9kaXY+XG57L2lmfVxuXG48c3R5bGU+XG4gIC5zdmVsdGUtZmxvd19fc2VsZWN0aW9uIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdG9wOiAwO1xuICAgIGxlZnQ6IDA7XG4gIH1cbjwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImlnbm9yZUxpc3QiOltdfQ== */"
};
function Selection3($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Selection3);
  append_styles($$anchor, $$css3);
  let x = prop($$props, "x", 3, 0), y = prop($$props, "y", 3, 0), width = prop($$props, "width", 3, 0), height = prop($$props, "height", 3, 0), isVisible = prop($$props, "isVisible", 3, true);
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var div = root_16();
      let styles;
      template_effect(($0) => styles = set_style(div, "", styles, $0), [
        () => ({
          width: strict_equals(typeof width(), "string") ? width() : toPxString(width()),
          height: strict_equals(typeof height(), "string") ? height() : toPxString(height()),
          transform: `translate(${x()}px, ${y()}px)`
        })
      ]);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (isVisible()) $$render(consequent);
      }),
      "if",
      Selection3,
      19,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Selection3 = hmr(Selection3, () => Selection3[HMR].source);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-oTKPzM3FNot7");
    module.default[HMR].source = Selection3[HMR].source;
    set(Selection3[HMR].source, module.default[HMR].original);
  });
}
var Selection_default = Selection3;

// node_modules/@xyflow/svelte/dist/lib/components/NodeSelection/NodeSelection.svelte
NodeSelection[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/NodeSelection/NodeSelection.svelte";
var root_17 = add_locations(from_html(`<div><!></div>`), NodeSelection[FILENAME], [[63, 2]]);
var $$css4 = {
  hash: "s-qptu2oenCdVM",
  code: "\n  .svelte-flow__selection-wrapper.s-qptu2oenCdVM {\n    position: absolute;\n    top: 0;\n    left: 0;\n    z-index: 2000;\n    pointer-events: all;\n  }\n\n  .svelte-flow__selection-wrapper.s-qptu2oenCdVM:focus,\n  .svelte-flow__selection-wrapper.s-qptu2oenCdVM:focus-visible {\n    outline: none;\n  }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTm9kZVNlbGVjdGlvbi5zdmVsdGUiLCJzb3VyY2VzIjpbIk5vZGVTZWxlY3Rpb24uc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQgbGFuZz1cInRzXCIgZ2VuZXJpY3M9XCJOb2RlVHlwZSBleHRlbmRzIE5vZGUgPSBOb2RlLCBFZGdlVHlwZSBleHRlbmRzIEVkZ2UgPSBFZGdlXCI+XG4gIGltcG9ydCB7IGdldEludGVybmFsTm9kZXNCb3VuZHMsIGlzTnVtZXJpYywgdHlwZSBSZWN0IH0gZnJvbSAnQHh5Zmxvdy9zeXN0ZW0nO1xuXG4gIGltcG9ydCB7IFNlbGVjdGlvbiB9IGZyb20gJy4uL1NlbGVjdGlvbic7XG4gIGltcG9ydCBkcmFnIGZyb20gJy4uLy4uL2FjdGlvbnMvZHJhZyc7XG5cbiAgaW1wb3J0IHR5cGUgeyBOb2RlU2VsZWN0aW9uUHJvcHMgfSBmcm9tICcuL3R5cGVzJztcbiAgaW1wb3J0IHsgYXJyb3dLZXlEaWZmcywgdG9QeFN0cmluZyB9IGZyb20gJy4uLy4uL3V0aWxzJztcbiAgaW1wb3J0IHR5cGUgeyBOb2RlLCBFZGdlIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuXG4gIGxldCB7XG4gICAgc3RvcmUgPSAkYmluZGFibGUoKSxcbiAgICBvbm5vZGVkcmFnLFxuICAgIG9ubm9kZWRyYWdzdGFydCxcbiAgICBvbm5vZGVkcmFnc3RvcCxcbiAgICBvbnNlbGVjdGlvbmNsaWNrLFxuICAgIG9uc2VsZWN0aW9uY29udGV4dG1lbnVcbiAgfTogTm9kZVNlbGVjdGlvblByb3BzPE5vZGVUeXBlLCBFZGdlVHlwZT4gPSAkcHJvcHMoKTtcblxuICBsZXQgcmVmID0gJHN0YXRlPEhUTUxEaXZFbGVtZW50PigpO1xuXG4gICRlZmZlY3QoKCkgPT4ge1xuICAgIGlmICghc3RvcmUuZGlzYWJsZUtleWJvYXJkQTExeSkge1xuICAgICAgcmVmPy5mb2N1cyh7XG4gICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgbGV0IGJvdW5kczogUmVjdCB8IG51bGwgPSAkZGVyaXZlZC5ieSgoKSA9PiB7XG4gICAgaWYgKHN0b3JlLnNlbGVjdGlvblJlY3RNb2RlID09PSAnbm9kZXMnKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC1leHByZXNzaW9uc1xuICAgICAgc3RvcmUubm9kZXM7XG4gICAgICBjb25zdCBub2RlQm91bmRzID0gZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcyhzdG9yZS5ub2RlTG9va3VwLCB7XG4gICAgICAgIGZpbHRlcjogKG5vZGUpID0+ICEhbm9kZS5zZWxlY3RlZFxuICAgICAgfSk7XG4gICAgICBpZiAobm9kZUJvdW5kcy53aWR0aCA+IDAgJiYgbm9kZUJvdW5kcy5oZWlnaHQgPiAwKSB7XG4gICAgICAgIHJldHVybiBub2RlQm91bmRzO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gb25jb250ZXh0bWVudShldmVudDogTW91c2VFdmVudCkge1xuICAgIGNvbnN0IHNlbGVjdGVkTm9kZXMgPSBzdG9yZS5ub2Rlcy5maWx0ZXIoKG4pID0+IG4uc2VsZWN0ZWQpO1xuICAgIG9uc2VsZWN0aW9uY29udGV4dG1lbnU/Lih7IG5vZGVzOiBzZWxlY3RlZE5vZGVzLCBldmVudCB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uY2xpY2soZXZlbnQ6IE1vdXNlRXZlbnQpIHtcbiAgICBjb25zdCBzZWxlY3RlZE5vZGVzID0gc3RvcmUubm9kZXMuZmlsdGVyKChuKSA9PiBuLnNlbGVjdGVkKTtcbiAgICBvbnNlbGVjdGlvbmNsaWNrPy4oeyBub2Rlczogc2VsZWN0ZWROb2RlcywgZXZlbnQgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBvbmtleWRvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFycm93S2V5RGlmZnMsIGV2ZW50LmtleSkpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBzdG9yZS5tb3ZlU2VsZWN0ZWROb2RlcyhhcnJvd0tleURpZmZzW2V2ZW50LmtleV0sIGV2ZW50LnNoaWZ0S2V5ID8gNCA6IDEpO1xuICAgIH1cbiAgfVxuPC9zY3JpcHQ+XG5cbnsjaWYgc3RvcmUuc2VsZWN0aW9uUmVjdE1vZGUgPT09ICdub2RlcycgJiYgYm91bmRzICYmIGlzTnVtZXJpYyhib3VuZHMueCkgJiYgaXNOdW1lcmljKGJvdW5kcy55KX1cbiAgPGRpdlxuICAgIGNsYXNzPXtbJ3N2ZWx0ZS1mbG93X19zZWxlY3Rpb24td3JhcHBlcicsIHN0b3JlLm5vUGFuQ2xhc3NdfVxuICAgIHN0eWxlOndpZHRoPXt0b1B4U3RyaW5nKGJvdW5kcy53aWR0aCl9XG4gICAgc3R5bGU6aGVpZ2h0PXt0b1B4U3RyaW5nKGJvdW5kcy5oZWlnaHQpfVxuICAgIHN0eWxlOnRyYW5zZm9ybT1cInRyYW5zbGF0ZSh7Ym91bmRzLnh9cHgsIHtib3VuZHMueX1weClcIlxuICAgIHVzZTpkcmFnPXt7XG4gICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICBzdG9yZSxcbiAgICAgIG9uRHJhZzogKGV2ZW50LCBfLCBfXywgbm9kZXMpID0+IHtcbiAgICAgICAgb25ub2RlZHJhZz8uKHsgZXZlbnQsIHRhcmdldE5vZGU6IG51bGwsIG5vZGVzOiBub2RlcyBhcyBOb2RlVHlwZVtdIH0pO1xuICAgICAgfSxcbiAgICAgIG9uRHJhZ1N0YXJ0OiAoZXZlbnQsIF8sIF9fLCBub2RlcykgPT4ge1xuICAgICAgICBvbm5vZGVkcmFnc3RhcnQ/Lih7IGV2ZW50LCB0YXJnZXROb2RlOiBudWxsLCBub2Rlczogbm9kZXMgYXMgTm9kZVR5cGVbXSB9KTtcbiAgICAgIH0sXG4gICAgICBvbkRyYWdTdG9wOiAoZXZlbnQsIF8sIF9fLCBub2RlcykgPT4ge1xuICAgICAgICBvbm5vZGVkcmFnc3RvcD8uKHsgZXZlbnQsIHRhcmdldE5vZGU6IG51bGwsIG5vZGVzOiBub2RlcyBhcyBOb2RlVHlwZVtdIH0pO1xuICAgICAgfVxuICAgIH19XG4gICAge29uY29udGV4dG1lbnV9XG4gICAge29uY2xpY2t9XG4gICAgcm9sZT17c3RvcmUuZGlzYWJsZUtleWJvYXJkQTExeSA/IHVuZGVmaW5lZCA6ICdidXR0b24nfVxuICAgIHRhYkluZGV4PXtzdG9yZS5kaXNhYmxlS2V5Ym9hcmRBMTF5ID8gdW5kZWZpbmVkIDogLTF9XG4gICAgb25rZXlkb3duPXtzdG9yZS5kaXNhYmxlS2V5Ym9hcmRBMTF5ID8gdW5kZWZpbmVkIDogb25rZXlkb3dufVxuICAgIGJpbmQ6dGhpcz17cmVmfVxuICA+XG4gICAgPFNlbGVjdGlvbiB3aWR0aD1cIjEwMCVcIiBoZWlnaHQ9XCIxMDAlXCIgeD17MH0geT17MH0gLz5cbiAgPC9kaXY+XG57L2lmfVxuXG48c3R5bGU+XG4gIC5zdmVsdGUtZmxvd19fc2VsZWN0aW9uLXdyYXBwZXIge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDA7XG4gICAgbGVmdDogMDtcbiAgICB6LWluZGV4OiAyMDAwO1xuICAgIHBvaW50ZXItZXZlbnRzOiBhbGw7XG4gIH1cblxuICAuc3ZlbHRlLWZsb3dfX3NlbGVjdGlvbi13cmFwcGVyOmZvY3VzLFxuICAuc3ZlbHRlLWZsb3dfX3NlbGVjdGlvbi13cmFwcGVyOmZvY3VzLXZpc2libGUge1xuICAgIG91dGxpbmU6IG5vbmU7XG4gIH1cbjwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImlnbm9yZUxpc3QiOltdfQ== */"
};
function NodeSelection($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, NodeSelection);
  append_styles($$anchor, $$css4);
  let ref = tag(state(void 0), "ref");
  user_effect(() => {
    if (!$$props.store.disableKeyboardA11y) {
      get(ref)?.focus({ preventScroll: true });
    }
  });
  let bounds = tag(
    user_derived(() => {
      if (strict_equals($$props.store.selectionRectMode, "nodes")) {
        $$props.store.nodes;
        const nodeBounds = getInternalNodesBounds($$props.store.nodeLookup, { filter: (node) => !!node.selected });
        if (nodeBounds.width > 0 && nodeBounds.height > 0) {
          return nodeBounds;
        }
      }
      return null;
    }),
    "bounds"
  );
  function oncontextmenu(event2) {
    const selectedNodes = $$props.store.nodes.filter((n) => n.selected);
    $$props.onselectioncontextmenu?.({ nodes: selectedNodes, event: event2 });
  }
  function onclick(event2) {
    const selectedNodes = $$props.store.nodes.filter((n) => n.selected);
    $$props.onselectionclick?.({ nodes: selectedNodes, event: event2 });
  }
  function onkeydown(event2) {
    if (Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event2.key)) {
      event2.preventDefault();
      $$props.store.moveSelectedNodes(arrowKeyDiffs[event2.key], event2.shiftKey ? 4 : 1);
    }
  }
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node_1 = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var div = root_17();
      div.__contextmenu = oncontextmenu;
      div.__click = onclick;
      div.__keydown = function(...$$args) {
        apply(() => $$props.store.disableKeyboardA11y ? void 0 : onkeydown, this, $$args, NodeSelection, [85, 15]);
      };
      let styles;
      var node_2 = child(div);
      add_svelte_meta(() => Selection_default(node_2, { width: "100%", height: "100%", x: 0, y: 0 }), "component", NodeSelection, 88, 4, { componentTag: "Selection" });
      reset(div);
      action(div, ($$node, $$action_arg) => drag?.($$node, $$action_arg), () => ({
        disabled: false,
        store: $$props.store,
        onDrag: (event2, _, __, nodes) => {
          $$props.onnodedrag?.({ event: event2, targetNode: null, nodes });
        },
        onDragStart: (event2, _, __, nodes) => {
          $$props.onnodedragstart?.({ event: event2, targetNode: null, nodes });
        },
        onDragStop: (event2, _, __, nodes) => {
          $$props.onnodedragstop?.({ event: event2, targetNode: null, nodes });
        }
      }));
      bind_this(div, ($$value) => set(ref, $$value), () => get(ref));
      template_effect(
        ($0) => {
          set_class(div, 1, clsx(["svelte-flow__selection-wrapper", $$props.store.noPanClass]), "s-qptu2oenCdVM");
          set_attribute(div, "role", $$props.store.disableKeyboardA11y ? void 0 : "button");
          set_attribute(div, "tabindex", $$props.store.disableKeyboardA11y ? void 0 : -1);
          styles = set_style(div, "", styles, $0);
        },
        [
          () => ({
            width: toPxString(get(bounds).width),
            height: toPxString(get(bounds).height),
            transform: `translate(${get(bounds).x ?? ""}px, ${get(bounds).y ?? ""}px)`
          })
        ]
      );
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        if (strict_equals($$props.store.selectionRectMode, "nodes") && get(bounds) && isNumeric(get(bounds).x) && isNumeric(get(bounds).y)) $$render(consequent);
      }),
      "if",
      NodeSelection,
      62,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  NodeSelection = hmr(NodeSelection, () => NodeSelection[HMR].source);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-qptu2oenCdVM");
    module.default[HMR].source = NodeSelection[HMR].source;
    set(NodeSelection[HMR].source, module.default[HMR].original);
  });
}
var NodeSelection_default = NodeSelection;
delegate(["contextmenu", "click", "keydown"]);

// node_modules/@svelte-put/shortcut/src/shortcut.js
function mapModifierToBitMask(def) {
  switch (def) {
    case "ctrl":
      return 8;
    case "shift":
      return 4;
    case "alt":
      return 2;
    case "meta":
      return 1;
  }
}
function shortcut(node, param) {
  let { enabled = true, trigger, type = "keydown" } = param;
  function handler(event2) {
    const normalizedTriggers = Array.isArray(trigger) ? trigger : [trigger];
    const modifierMask = [event2.metaKey, event2.altKey, event2.shiftKey, event2.ctrlKey].reduce(
      (acc, value, index) => {
        if (value) {
          return acc | 1 << index;
        }
        return acc;
      },
      0
    );
    for (const trigger2 of normalizedTriggers) {
      const mergedTrigger = {
        preventDefault: false,
        enabled: true,
        ...trigger2
      };
      const { modifier, key: key2, callback, preventDefault, enabled: triggerEnabled } = mergedTrigger;
      if (triggerEnabled) {
        if (event2.key !== key2) continue;
        if (modifier === null || modifier === false) {
          if (modifierMask !== 0) continue;
        } else if (modifier !== void 0 && modifier?.[0]?.length > 0) {
          const orDefs = Array.isArray(modifier) ? modifier : [modifier];
          let modified = false;
          for (const orDef of orDefs) {
            const mask = (Array.isArray(orDef) ? orDef : [orDef]).reduce(
              (acc, def) => acc | mapModifierToBitMask(def),
              0
            );
            if (mask === modifierMask) {
              modified = true;
              break;
            }
          }
          if (!modified) continue;
        }
        if (preventDefault) event2.preventDefault();
        const detail = {
          node,
          trigger: mergedTrigger,
          originalEvent: event2
        };
        node.dispatchEvent(new CustomEvent("shortcut", { detail }));
        callback?.(detail);
      }
    }
  }
  let off;
  if (enabled) {
    off = on(node, type, handler);
  }
  return {
    update: (update) => {
      const { enabled: newEnabled = true, type: newType = "keydown" } = update;
      if (enabled && (!newEnabled || type !== newType)) {
        off?.();
      } else if (!enabled && newEnabled) {
        off = on(node, newType, handler);
      }
      enabled = newEnabled;
      type = newType;
      trigger = update.trigger;
    },
    destroy: () => {
      off?.();
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/hooks/useSvelteFlow.svelte.js
function useSvelteFlow() {
  const store = tag(user_derived(useStore), "store");
  const getNodeRect = (node) => {
    const nodeToUse = isNode(node) ? node : get(store).nodeLookup.get(node.id);
    const position = nodeToUse.parentId ? evaluateAbsolutePosition(nodeToUse.position, nodeToUse.measured, nodeToUse.parentId, get(store).nodeLookup, get(store).nodeOrigin) : nodeToUse.position;
    const nodeWithPosition = {
      ...nodeToUse,
      position,
      width: nodeToUse.measured?.width ?? nodeToUse.width,
      height: nodeToUse.measured?.height ?? nodeToUse.height
    };
    return nodeToRect(nodeWithPosition);
  };
  function updateNode(id2, nodeUpdate, options = { replace: false }) {
    get(store).nodes = untrack(() => get(store).nodes).map((node) => {
      if (strict_equals(node.id, id2)) {
        const nextNode = strict_equals(typeof nodeUpdate, "function") ? nodeUpdate(node) : nodeUpdate;
        return options?.replace && isNode(nextNode) ? nextNode : { ...node, ...nextNode };
      }
      return node;
    });
  }
  function updateEdge(id2, edgeUpdate, options = { replace: false }) {
    get(store).edges = untrack(() => get(store).edges).map((edge) => {
      if (strict_equals(edge.id, id2)) {
        const nextEdge = strict_equals(typeof edgeUpdate, "function") ? edgeUpdate(edge) : edgeUpdate;
        return options.replace && isEdge(nextEdge) ? nextEdge : { ...edge, ...nextEdge };
      }
      return edge;
    });
  }
  const getInternalNode = (id2) => get(store).nodeLookup.get(id2);
  return {
    zoomIn: get(store).zoomIn,
    zoomOut: get(store).zoomOut,
    getInternalNode,
    getNode: (id2) => getInternalNode(id2)?.internals.userNode,
    getNodes: (ids) => strict_equals(ids, void 0) ? get(store).nodes : getElements(get(store).nodeLookup, ids),
    getEdge: (id2) => get(store).edgeLookup.get(id2),
    getEdges: (ids) => strict_equals(ids, void 0) ? get(store).edges : getElements(get(store).edgeLookup, ids),
    setZoom: (zoomLevel, options) => {
      const panZoom = get(store).panZoom;
      return panZoom ? panZoom.scaleTo(zoomLevel, { duration: options?.duration }) : Promise.resolve(false);
    },
    getZoom: () => get(store).viewport.zoom,
    setViewport: async (nextViewport, options) => {
      const currentViewport = get(store).viewport;
      if (!get(store).panZoom) {
        return Promise.resolve(false);
      }
      (await track_reactivity_loss(get(store).panZoom.setViewport(
        {
          x: nextViewport.x ?? currentViewport.x,
          y: nextViewport.y ?? currentViewport.y,
          zoom: nextViewport.zoom ?? currentViewport.zoom
        },
        options
      )))();
      return Promise.resolve(true);
    },
    getViewport: () => snapshot(get(store).viewport),
    setCenter: async (x, y, options) => get(store).setCenter(x, y, options),
    fitView: (options) => get(store).fitView(options),
    fitBounds: async (bounds, options) => {
      if (!get(store).panZoom) {
        return Promise.resolve(false);
      }
      const viewport = getViewportForBounds(bounds, get(store).width, get(store).height, get(store).minZoom, get(store).maxZoom, options?.padding ?? 0.1);
      (await track_reactivity_loss(get(store).panZoom.setViewport(viewport, {
        duration: options?.duration,
        ease: options?.ease,
        interpolate: options?.interpolate
      })))();
      return Promise.resolve(true);
    },
    /**
     * Partial is defined as "the 2 nodes/areas are intersecting partially".
     * If a is contained in b or b is contained in a, they are both
     * considered fully intersecting.
     */
    getIntersectingNodes: (nodeOrRect, partially = true, nodesToIntersect) => {
      const isRect = isRectObject(nodeOrRect);
      const nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect);
      if (!nodeRect) {
        return [];
      }
      return (nodesToIntersect || get(store).nodes).filter((n) => {
        const internalNode = get(store).nodeLookup.get(n.id);
        if (!internalNode || !isRect && strict_equals(n.id, nodeOrRect.id)) {
          return false;
        }
        const currNodeRect = nodeToRect(internalNode);
        const overlappingArea = getOverlappingArea(currNodeRect, nodeRect);
        const partiallyVisible = partially && overlappingArea > 0;
        return partiallyVisible || overlappingArea >= currNodeRect.width * currNodeRect.height || overlappingArea >= nodeRect.width * nodeRect.height;
      });
    },
    isNodeIntersecting: (nodeOrRect, area, partially = true) => {
      const isRect = isRectObject(nodeOrRect);
      const nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect);
      if (!nodeRect) {
        return false;
      }
      const overlappingArea = getOverlappingArea(nodeRect, area);
      const partiallyVisible = partially && overlappingArea > 0;
      return partiallyVisible || overlappingArea >= area.width * area.height || overlappingArea >= nodeRect.width * nodeRect.height;
    },
    deleteElements: async ({ nodes: nodesToRemove = [], edges: edgesToRemove = [] }) => {
      const { nodes: matchingNodes, edges: matchingEdges } = (await track_reactivity_loss(getElementsToRemove({
        nodesToRemove,
        edgesToRemove,
        nodes: get(store).nodes,
        edges: get(store).edges,
        onBeforeDelete: get(store).onbeforedelete
      })))();
      if (matchingNodes) {
        get(store).nodes = untrack(() => get(store).nodes).filter((node) => !matchingNodes.some(({ id: id2 }) => strict_equals(id2, node.id)));
      }
      if (matchingEdges) {
        get(store).edges = untrack(() => get(store).edges).filter((edge) => !matchingEdges.some(({ id: id2 }) => strict_equals(id2, edge.id)));
      }
      if (matchingNodes.length > 0 || matchingEdges.length > 0) {
        get(store).ondelete?.({ nodes: matchingNodes, edges: matchingEdges });
      }
      return { deletedNodes: matchingNodes, deletedEdges: matchingEdges };
    },
    screenToFlowPosition: (position, options = { snapToGrid: true }) => {
      if (!get(store).domNode) {
        return position;
      }
      const _snapGrid = options.snapToGrid ? get(store).snapGrid : false;
      const { x, y, zoom: zoom2 } = get(store).viewport;
      const { x: domX, y: domY } = get(store).domNode.getBoundingClientRect();
      const correctedPosition = { x: position.x - domX, y: position.y - domY };
      return pointToRendererPoint(correctedPosition, [x, y, zoom2], strict_equals(_snapGrid, null, false), _snapGrid || [1, 1]);
    },
    /**
     *
     * @param position
     * @returns
     */
    flowToScreenPosition: (position) => {
      if (!get(store).domNode) {
        return position;
      }
      const { x, y, zoom: zoom2 } = get(store).viewport;
      const { x: domX, y: domY } = get(store).domNode.getBoundingClientRect();
      const rendererPosition = rendererPointToPoint(position, [x, y, zoom2]);
      return { x: rendererPosition.x + domX, y: rendererPosition.y + domY };
    },
    toObject: () => {
      return structuredClone({
        nodes: [...get(store).nodes],
        edges: [...get(store).edges],
        viewport: { ...get(store).viewport }
      });
    },
    updateNode,
    updateNodeData: (id2, dataUpdate, options) => {
      const node = get(store).nodeLookup.get(id2)?.internals.userNode;
      if (!node) {
        return;
      }
      const nextData = strict_equals(typeof dataUpdate, "function") ? dataUpdate(node) : dataUpdate;
      updateNode(id2, (node2) => ({
        ...node2,
        data: options?.replace ? nextData : { ...node2.data, ...nextData }
      }));
    },
    updateEdge,
    getNodesBounds: (nodes) => {
      return getNodesBounds(nodes, {
        nodeLookup: get(store).nodeLookup,
        nodeOrigin: get(store).nodeOrigin
      });
    },
    getHandleConnections: ({ type, id: id2, nodeId }) => Array.from(get(store).connectionLookup.get(`${nodeId}-${type}-${id2 ?? null}`)?.values() ?? [])
  };
}
function getElements(lookup, ids) {
  const result = [];
  for (const id2 of ids) {
    const item = lookup.get(id2);
    if (item) {
      const element = "internals" in item ? item.internals?.userNode : item;
      result.push(element);
    }
  }
  return result;
}

// node_modules/@xyflow/svelte/dist/lib/components/KeyHandler/KeyHandler.svelte
KeyHandler[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/KeyHandler/KeyHandler.svelte";
function KeyHandler($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, KeyHandler);
  var $$ownership_validator = create_ownership_validator($$props);
  let store = prop($$props, "store", 15), selectionKey = prop($$props, "selectionKey", 3, "Shift"), multiSelectionKey = prop($$props, "multiSelectionKey", 19, () => isMacOs() ? "Meta" : "Control"), deleteKey = prop($$props, "deleteKey", 3, "Backspace"), panActivationKey = prop($$props, "panActivationKey", 3, " "), zoomActivationKey = prop($$props, "zoomActivationKey", 19, () => isMacOs() ? "Meta" : "Control");
  let { deleteElements } = useSvelteFlow();
  function isKeyObject(key2) {
    return strict_equals(key2, null, false) && strict_equals(typeof key2, "object");
  }
  function getModifier(key2) {
    return isKeyObject(key2) ? key2.modifier || [] : [];
  }
  function getKeyString(key2) {
    if (strict_equals(key2, null) || strict_equals(key2, void 0)) {
      return "";
    }
    return isKeyObject(key2) ? key2.key : key2;
  }
  function getShortcutTrigger(key2, callback) {
    const keys = Array.isArray(key2) ? key2 : [key2];
    return keys.map((_key) => {
      const keyString = getKeyString(_key);
      return {
        key: keyString,
        modifier: getModifier(_key),
        enabled: strict_equals(keyString, null, false),
        callback
      };
    });
  }
  function resetKeysAndSelection() {
    $$ownership_validator.mutation("store", ["store", "selectionRect"], store(store().selectionRect = null, true), 59, 4);
    $$ownership_validator.mutation("store", ["store", "selectionKeyPressed"], store(store().selectionKeyPressed = false, true), 60, 4);
    $$ownership_validator.mutation("store", ["store", "multiselectionKeyPressed"], store(store().multiselectionKeyPressed = false, true), 61, 4);
    $$ownership_validator.mutation("store", ["store", "deleteKeyPressed"], store(store().deleteKeyPressed = false, true), 62, 4);
    $$ownership_validator.mutation("store", ["store", "panActivationKeyPressed"], store(store().panActivationKeyPressed = false, true), 63, 4);
    $$ownership_validator.mutation("store", ["store", "zoomActivationKeyPressed"], store(store().zoomActivationKeyPressed = false, true), 64, 4);
  }
  function handleDelete() {
    const selectedNodes = store().nodes.filter((node) => node.selected);
    const selectedEdges = store().edges.filter((edge) => edge.selected);
    deleteElements({ nodes: selectedNodes, edges: selectedEdges });
  }
  var $$exports = { ...legacy_api() };
  event("blur", $window, resetKeysAndSelection);
  event("contextmenu", $window, resetKeysAndSelection);
  action($window, ($$node, $$action_arg) => shortcut?.($$node, $$action_arg), () => ({
    trigger: getShortcutTrigger(selectionKey(), () => $$ownership_validator.mutation("store", ["store", "selectionKeyPressed"], store(store().selectionKeyPressed = true, true), 82, 53)),
    type: "keydown"
  }));
  action($window, ($$node, $$action_arg) => shortcut?.($$node, $$action_arg), () => ({
    trigger: getShortcutTrigger(selectionKey(), () => $$ownership_validator.mutation("store", ["store", "selectionKeyPressed"], store(store().selectionKeyPressed = false, true), 86, 53)),
    type: "keyup"
  }));
  action($window, ($$node, $$action_arg) => shortcut?.($$node, $$action_arg), () => ({
    trigger: getShortcutTrigger(multiSelectionKey(), () => {
      $$ownership_validator.mutation("store", ["store", "multiselectionKeyPressed"], store(store().multiselectionKeyPressed = true, true), 91, 6);
    }),
    type: "keydown"
  }));
  action($window, ($$node, $$action_arg) => shortcut?.($$node, $$action_arg), () => ({
    trigger: getShortcutTrigger(multiSelectionKey(), () => $$ownership_validator.mutation("store", ["store", "multiselectionKeyPressed"], store(store().multiselectionKeyPressed = false, true), 96, 58)),
    type: "keyup"
  }));
  action($window, ($$node, $$action_arg) => shortcut?.($$node, $$action_arg), () => ({
    trigger: getShortcutTrigger(deleteKey(), (detail) => {
      const isModifierKey = detail.originalEvent.ctrlKey || detail.originalEvent.metaKey || detail.originalEvent.shiftKey;
      if (!isModifierKey && !isInputDOMNode(detail.originalEvent)) {
        $$ownership_validator.mutation("store", ["store", "deleteKeyPressed"], store(store().deleteKeyPressed = true, true), 106, 8);
        handleDelete();
      }
    }),
    type: "keydown"
  }));
  action($window, ($$node, $$action_arg) => shortcut?.($$node, $$action_arg), () => ({
    trigger: getShortcutTrigger(deleteKey(), () => $$ownership_validator.mutation("store", ["store", "deleteKeyPressed"], store(store().deleteKeyPressed = false, true), 113, 50)),
    type: "keyup"
  }));
  action($window, ($$node, $$action_arg) => shortcut?.($$node, $$action_arg), () => ({
    trigger: getShortcutTrigger(panActivationKey(), () => $$ownership_validator.mutation("store", ["store", "panActivationKeyPressed"], store(store().panActivationKeyPressed = true, true), 117, 57)),
    type: "keydown"
  }));
  action($window, ($$node, $$action_arg) => shortcut?.($$node, $$action_arg), () => ({
    trigger: getShortcutTrigger(panActivationKey(), () => $$ownership_validator.mutation("store", ["store", "panActivationKeyPressed"], store(store().panActivationKeyPressed = false, true), 121, 57)),
    type: "keyup"
  }));
  action($window, ($$node, $$action_arg) => shortcut?.($$node, $$action_arg), () => ({
    trigger: getShortcutTrigger(zoomActivationKey(), () => $$ownership_validator.mutation("store", ["store", "zoomActivationKeyPressed"], store(store().zoomActivationKeyPressed = true, true), 125, 58)),
    type: "keydown"
  }));
  action($window, ($$node, $$action_arg) => shortcut?.($$node, $$action_arg), () => ({
    trigger: getShortcutTrigger(zoomActivationKey(), () => $$ownership_validator.mutation("store", ["store", "zoomActivationKeyPressed"], store(store().zoomActivationKeyPressed = false, true), 129, 58)),
    type: "keyup"
  }));
  return pop($$exports);
}
if (import.meta.hot) {
  KeyHandler = hmr(KeyHandler, () => KeyHandler[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = KeyHandler[HMR].source;
    set(KeyHandler[HMR].source, module.default[HMR].original);
  });
}
var KeyHandler_default = KeyHandler;

// node_modules/@xyflow/svelte/dist/lib/components/ConnectionLine/ConnectionLine.svelte
ConnectionLine[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/ConnectionLine/ConnectionLine.svelte";
var root_32 = add_locations(from_svg(`<path fill="none" class="svelte-flow__connection-path"></path>`), ConnectionLine[FILENAME], [[74, 8]]);
var root_18 = add_locations(from_svg(`<svg class="svelte-flow__connectionline"><g><!></g></svg>`), ConnectionLine[FILENAME], [[64, 2, [[70, 4]]]]);
function ConnectionLine($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, ConnectionLine);
  let path = tag(
    user_derived(() => {
      if (!$$props.store.connection.inProgress) {
        return "";
      }
      const pathParams = {
        sourceX: $$props.store.connection.from.x,
        sourceY: $$props.store.connection.from.y,
        sourcePosition: $$props.store.connection.fromPosition,
        targetX: $$props.store.connection.to.x,
        targetY: $$props.store.connection.to.y,
        targetPosition: $$props.store.connection.toPosition
      };
      switch ($$props.type) {
        case ConnectionLineType.Bezier: {
          const [path2] = getBezierPath(pathParams);
          return path2;
        }
        case ConnectionLineType.Straight: {
          const [path2] = getStraightPath(pathParams);
          return path2;
        }
        case ConnectionLineType.Step:
        case ConnectionLineType.SmoothStep: {
          const [path2] = getSmoothStepPath({
            ...pathParams,
            borderRadius: strict_equals($$props.type, ConnectionLineType.Step) ? 0 : void 0
          });
          return path2;
        }
      }
    }),
    "path"
  );
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var svg = root_18();
      var g = child(svg);
      var node_1 = child(g);
      {
        var consequent = ($$anchor3) => {
          var fragment_1 = comment();
          var node_2 = first_child(fragment_1);
          add_svelte_meta(
            () => component(node_2, () => $$props.LineComponent, ($$anchor4, LineComponent_1) => {
              LineComponent_1($$anchor4, {});
            }),
            "component",
            ConnectionLine,
            72,
            8,
            { componentTag: "LineComponent" }
          );
          append($$anchor3, fragment_1);
        };
        var alternate = ($$anchor3) => {
          var path_1 = root_32();
          template_effect(() => {
            set_attribute(path_1, "d", get(path));
            set_style(path_1, $$props.style);
          });
          append($$anchor3, path_1);
        };
        add_svelte_meta(
          () => if_block(node_1, ($$render) => {
            if ($$props.LineComponent) $$render(consequent);
            else $$render(alternate, false);
          }),
          "if",
          ConnectionLine,
          71,
          6
        );
      }
      reset(g);
      reset(svg);
      template_effect(
        ($0) => {
          set_attribute(svg, "width", $$props.store.width);
          set_attribute(svg, "height", $$props.store.height);
          set_style(svg, $$props.containerStyle);
          set_class(g, 0, $0);
        },
        [
          () => clsx([
            "svelte-flow__connection",
            getConnectionStatus($$props.store.connection.isValid)
          ])
        ]
      );
      append($$anchor2, svg);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.store.connection.inProgress) $$render(consequent_1);
      }),
      "if",
      ConnectionLine,
      63,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  ConnectionLine = hmr(ConnectionLine, () => ConnectionLine[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ConnectionLine[HMR].source;
    set(ConnectionLine[HMR].source, module.default[HMR].original);
  });
}
var ConnectionLine_default = ConnectionLine;

// node_modules/@xyflow/svelte/dist/lib/container/Panel/Panel.svelte
Panel[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/container/Panel/Panel.svelte";
var root16 = add_locations(from_html(`<div><!></div>`), Panel[FILENAME], [[9, 0]]);
function Panel($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Panel);
  let position = prop($$props, "position", 3, "top-right"), rest = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "position",
      "style",
      "class",
      "children"
    ],
    "rest"
  );
  let positionClasses = tag(user_derived(() => `${position()}`.split("-")), "positionClasses");
  var $$exports = { ...legacy_api() };
  var div = root16();
  attribute_effect(div, ($0) => ({ class: $0, style: $$props.style, ...rest }), [
    () => [
      "svelte-flow__panel",
      $$props.class,
      ...get(positionClasses)
    ]
  ]);
  var node = child(div);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop), "render", Panel, 10, 2);
  reset(div);
  append($$anchor, div);
  return pop($$exports);
}
if (import.meta.hot) {
  Panel = hmr(Panel, () => Panel[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Panel[HMR].source;
    set(Panel[HMR].source, module.default[HMR].original);
  });
}
var Panel_default = Panel;

// node_modules/@xyflow/svelte/dist/lib/components/Attribution/Attribution.svelte
Attribution[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/Attribution/Attribution.svelte";
var root_2 = add_locations(from_html(`<a href="https://svelteflow.dev" target="_blank" rel="noopener noreferrer" aria-label="Svelte Flow attribution">Svelte Flow</a>`), Attribution[FILENAME], [[14, 4]]);
function Attribution($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Attribution);
  let position = prop($$props, "position", 3, "bottom-right");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(
        () => Panel_default(node_1, {
          get position() {
            return position();
          },
          class: "svelte-flow__attribution",
          "data-message": "Feel free to remove the attribution or check out how you could support us: https://svelteflow.dev/support-us",
          children: wrap_snippet(Attribution, ($$anchor3, $$slotProps) => {
            var a = root_2();
            append($$anchor3, a);
          }),
          $$slots: { default: true }
        }),
        "component",
        Attribution,
        9,
        2,
        { componentTag: "Panel" }
      );
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (!$$props.proOptions?.hideAttribution) $$render(consequent);
      }),
      "if",
      Attribution,
      8,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Attribution = hmr(Attribution, () => Attribution[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Attribution[HMR].source;
    set(Attribution[HMR].source, module.default[HMR].original);
  });
}
var Attribution_default = Attribution;

// node_modules/@xyflow/svelte/dist/lib/container/SvelteFlow/Wrapper.svelte
Wrapper[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/container/SvelteFlow/Wrapper.svelte";
var root17 = add_locations(from_html(`<div><!></div>`), Wrapper[FILENAME], [[118, 0]]);
var $$css5 = {
  hash: "s-02z9KUhAEKFM",
  code: "\n  .svelte-flow.s-02z9KUhAEKFM {\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    position: relative;\n    z-index: 0;\n\n    background-color: var(--background-color, var(--background-color-default));\n  }\n\n  :root {\n    --background-color-default: #fff;\n    --background-pattern-color-default: #ddd;\n\n    --minimap-mask-color-default: rgb(240, 240, 240, 0.6);\n    --minimap-mask-stroke-color-default: none;\n    --minimap-mask-stroke-width-default: 1;\n\n    --controls-button-background-color-default: #fefefe;\n    --controls-button-background-color-hover-default: #f4f4f4;\n    --controls-button-color-default: inherit;\n    --controls-button-color-hover-default: inherit;\n    --controls-button-border-color-default: #eee;\n  }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiV3JhcHBlci5zdmVsdGUiLCJzb3VyY2VzIjpbIldyYXBwZXIuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQgbGFuZz1cInRzXCIgZ2VuZXJpY3M9XCJOb2RlVHlwZSBleHRlbmRzIE5vZGUgPSBOb2RlLCBFZGdlVHlwZSBleHRlbmRzIEVkZ2UgPSBFZGdlXCI+XG4gIGltcG9ydCB0eXBlIHsgSFRNTEF0dHJpYnV0ZXMgfSBmcm9tICdzdmVsdGUvZWxlbWVudHMnO1xuICBpbXBvcnQgdHlwZSB7IFNuaXBwZXQgfSBmcm9tICdzdmVsdGUnO1xuICBpbXBvcnQgeyB0eXBlIFN2ZWx0ZUZsb3dSZXN0UHJvcHMgfSBmcm9tICcuLi8uLi9zdG9yZS90eXBlcyc7XG4gIGltcG9ydCB7IHRvUHhTdHJpbmcgfSBmcm9tICcuLi8uLi91dGlscyc7XG4gIGltcG9ydCB0eXBlIHsgTm9kZSwgRWRnZSB9IGZyb20gJy4uLy4uL3R5cGVzJztcblxuICBsZXQge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBjb2xvck1vZGUsXG4gICAgZG9tTm9kZSA9ICRiaW5kYWJsZSgpLFxuICAgIGNsaWVudFdpZHRoID0gJGJpbmRhYmxlKCksXG4gICAgY2xpZW50SGVpZ2h0ID0gJGJpbmRhYmxlKCksXG4gICAgY2hpbGRyZW4sXG4gICAgcmVzdFxuICB9OiB7XG4gICAgd2lkdGg/OiBudW1iZXI7XG4gICAgaGVpZ2h0PzogbnVtYmVyO1xuICAgIGNvbG9yTW9kZT86IHN0cmluZztcbiAgICBkb21Ob2RlOiBIVE1MRGl2RWxlbWVudCB8IG51bGw7XG4gICAgY2xpZW50V2lkdGg/OiBudW1iZXI7XG4gICAgY2xpZW50SGVpZ2h0PzogbnVtYmVyO1xuICAgIGNoaWxkcmVuPzogU25pcHBldDtcbiAgICByZXN0OiBTdmVsdGVGbG93UmVzdFByb3BzPE5vZGVUeXBlLCBFZGdlVHlwZT4gJlxuICAgICAgT21pdDxIVE1MQXR0cmlidXRlczxIVE1MRGl2RWxlbWVudD4sICdvbnNlbGVjdGlvbmNoYW5nZSc+O1xuICB9ID0gJHByb3BzKCk7XG5cbiAgLy8gVW5mb3J0dW5hdGVseSB3ZSBoYXZlIHRvIGRlc3RydWN0dXJlIHRoZSBwcm9wcyBoZXJlIHRoaXMgd2F5LFxuICAvLyBzbyB3ZSBkb24ndCBwYXNzIGFsbCB0aGUgcHJvcHMgYXMgYXR0cmlidXRlcyB0byB0aGUgZGl2IGVsZW1lbnRcbiAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG4gIGxldCB7XG4gICAgaWQsXG4gICAgY2xhc3M6IGNsYXNzTmFtZSxcbiAgICBub2RlVHlwZXMsXG4gICAgZWRnZVR5cGVzLFxuICAgIGNvbG9yTW9kZTogX2NvbG9yTW9kZSxcbiAgICBpc1ZhbGlkQ29ubmVjdGlvbixcbiAgICBvbm1vdmUsXG4gICAgb25tb3Zlc3RhcnQsXG4gICAgb25tb3ZlZW5kLFxuICAgIG9uZmxvd2Vycm9yLFxuICAgIG9uZGVsZXRlLFxuICAgIG9uYmVmb3JlZGVsZXRlLFxuICAgIG9uYmVmb3JlY29ubmVjdCxcbiAgICBvbmNvbm5lY3QsXG4gICAgb25jb25uZWN0c3RhcnQsXG4gICAgb25jb25uZWN0ZW5kLFxuICAgIG9uYmVmb3JlcmVjb25uZWN0LFxuICAgIG9ucmVjb25uZWN0LFxuICAgIG9ucmVjb25uZWN0c3RhcnQsXG4gICAgb25yZWNvbm5lY3RlbmQsXG4gICAgb25jbGlja2Nvbm5lY3RzdGFydCxcbiAgICBvbmNsaWNrY29ubmVjdGVuZCxcbiAgICBvbmluaXQsXG4gICAgb25zZWxlY3Rpb25jaGFuZ2UsXG4gICAgb25zZWxlY3Rpb25kcmFnc3RhcnQsXG4gICAgb25zZWxlY3Rpb25kcmFnLFxuICAgIG9uc2VsZWN0aW9uZHJhZ3N0b3AsXG4gICAgb25zZWxlY3Rpb25zdGFydCxcbiAgICBvbnNlbGVjdGlvbmVuZCxcbiAgICBjbGlja0Nvbm5lY3QsXG4gICAgZml0VmlldyxcbiAgICBmaXRWaWV3T3B0aW9ucyxcbiAgICBub2RlT3JpZ2luLFxuICAgIG5vZGVEcmFnVGhyZXNob2xkLFxuICAgIGNvbm5lY3Rpb25EcmFnVGhyZXNob2xkLFxuICAgIG1pblpvb20sXG4gICAgbWF4Wm9vbSxcbiAgICBpbml0aWFsVmlld3BvcnQsXG4gICAgY29ubmVjdGlvblJhZGl1cyxcbiAgICBjb25uZWN0aW9uTW9kZSxcbiAgICBzZWxlY3Rpb25Nb2RlLFxuICAgIHNlbGVjdE5vZGVzT25EcmFnLFxuICAgIHNuYXBHcmlkLFxuICAgIGRlZmF1bHRNYXJrZXJDb2xvcixcbiAgICB0cmFuc2xhdGVFeHRlbnQsXG4gICAgbm9kZUV4dGVudCxcbiAgICBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzLFxuICAgIGF1dG9QYW5PbkNvbm5lY3QsXG4gICAgYXV0b1Bhbk9uTm9kZURyYWcsXG4gICAgY29sb3JNb2RlU1NSLFxuICAgIGRlZmF1bHRFZGdlT3B0aW9ucyxcbiAgICBlbGV2YXRlTm9kZXNPblNlbGVjdCxcbiAgICBlbGV2YXRlRWRnZXNPblNlbGVjdCxcbiAgICBub2Rlc0RyYWdnYWJsZSxcbiAgICBhdXRvUGFuT25Ob2RlRm9jdXMsXG4gICAgbm9kZXNDb25uZWN0YWJsZSxcbiAgICBlbGVtZW50c1NlbGVjdGFibGUsXG4gICAgbm9kZXNGb2N1c2FibGUsXG4gICAgZWRnZXNGb2N1c2FibGUsXG4gICAgZGlzYWJsZUtleWJvYXJkQTExeSxcbiAgICBub0RyYWdDbGFzcyxcbiAgICBub1BhbkNsYXNzLFxuICAgIG5vV2hlZWxDbGFzcyxcbiAgICBhcmlhTGFiZWxDb25maWcsXG4gICAgYXV0b1BhblNwZWVkLFxuICAgIHBhbk9uU2Nyb2xsU3BlZWQsXG4gICAgLi4uZGl2QXR0cmlidXRlc1xuICB9ID0gJGRlcml2ZWQocmVzdCk7XG4gIC8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG5cbiAgdHlwZSBPbmx5RGl2QXR0cmlidXRlczxUPiA9IHtcbiAgICBbSyBpbiBrZXlvZiBUXTogSyBleHRlbmRzIGtleW9mIEhUTUxBdHRyaWJ1dGVzPEhUTUxEaXZFbGVtZW50PiA/IFRbS10gOiBuZXZlcjtcbiAgfTtcblxuICAvLyBVbmRvIHNjcm9sbCBldmVudHMsIHByZXZlbnRpbmcgdmlld3BvcnQgZnJvbSBzaGlmdGluZyB3aGVuIG5vZGVzIG91dHNpZGUgb2YgaXQgYXJlIGZvY3VzZWRcbiAgZnVuY3Rpb24gd3JhcHBlck9uU2Nyb2xsKGU6IFVJRXZlbnQgJiB7IGN1cnJlbnRUYXJnZXQ6IEV2ZW50VGFyZ2V0ICYgSFRNTERpdkVsZW1lbnQgfSkge1xuICAgIGUuY3VycmVudFRhcmdldC5zY3JvbGxUbyh7IHRvcDogMCwgbGVmdDogMCwgYmVoYXZpb3I6ICdhdXRvJyB9KTtcblxuICAgIC8vIEZvcndhcmQgdGhlIGV2ZW50IHRvIGFueSBleGlzdGluZyBvbnNjcm9sbCBoYW5kbGVyIGlmIG5lZWRlZFxuICAgIGlmIChyZXN0Lm9uc2Nyb2xsKSB7XG4gICAgICByZXN0Lm9uc2Nyb2xsKGUpO1xuICAgIH1cbiAgfVxuPC9zY3JpcHQ+XG5cbjxkaXZcbiAgYmluZDp0aGlzPXtkb21Ob2RlfVxuICBiaW5kOmNsaWVudEhlaWdodFxuICBiaW5kOmNsaWVudFdpZHRoXG4gIHN0eWxlOndpZHRoPXt0b1B4U3RyaW5nKHdpZHRoKX1cbiAgc3R5bGU6aGVpZ2h0PXt0b1B4U3RyaW5nKGhlaWdodCl9XG4gIGNsYXNzPXtbJ3N2ZWx0ZS1mbG93JywgJ3N2ZWx0ZS1mbG93X19jb250YWluZXInLCBjbGFzc05hbWUsIGNvbG9yTW9kZV19XG4gIGRhdGEtdGVzdGlkPVwic3ZlbHRlLWZsb3dfX3dyYXBwZXJcIlxuICByb2xlPVwiYXBwbGljYXRpb25cIlxuICBvbnNjcm9sbD17d3JhcHBlck9uU2Nyb2xsfVxuICB7Li4uZGl2QXR0cmlidXRlcyBzYXRpc2ZpZXMgT25seURpdkF0dHJpYnV0ZXM8dHlwZW9mIGRpdkF0dHJpYnV0ZXM+fVxuPlxuICB7QHJlbmRlciBjaGlsZHJlbj8uKCl9XG48L2Rpdj5cblxuPHN0eWxlPlxuICAuc3ZlbHRlLWZsb3cge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICB6LWluZGV4OiAwO1xuXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYmFja2dyb3VuZC1jb2xvciwgdmFyKC0tYmFja2dyb3VuZC1jb2xvci1kZWZhdWx0KSk7XG4gIH1cblxuICA6cm9vdCB7XG4gICAgLS1iYWNrZ3JvdW5kLWNvbG9yLWRlZmF1bHQ6ICNmZmY7XG4gICAgLS1iYWNrZ3JvdW5kLXBhdHRlcm4tY29sb3ItZGVmYXVsdDogI2RkZDtcblxuICAgIC0tbWluaW1hcC1tYXNrLWNvbG9yLWRlZmF1bHQ6IHJnYigyNDAsIDI0MCwgMjQwLCAwLjYpO1xuICAgIC0tbWluaW1hcC1tYXNrLXN0cm9rZS1jb2xvci1kZWZhdWx0OiBub25lO1xuICAgIC0tbWluaW1hcC1tYXNrLXN0cm9rZS13aWR0aC1kZWZhdWx0OiAxO1xuXG4gICAgLS1jb250cm9scy1idXR0b24tYmFja2dyb3VuZC1jb2xvci1kZWZhdWx0OiAjZmVmZWZlO1xuICAgIC0tY29udHJvbHMtYnV0dG9uLWJhY2tncm91bmQtY29sb3ItaG92ZXItZGVmYXVsdDogI2Y0ZjRmNDtcbiAgICAtLWNvbnRyb2xzLWJ1dHRvbi1jb2xvci1kZWZhdWx0OiBpbmhlcml0O1xuICAgIC0tY29udHJvbHMtYnV0dG9uLWNvbG9yLWhvdmVyLWRlZmF1bHQ6IGluaGVyaXQ7XG4gICAgLS1jb250cm9scy1idXR0b24tYm9yZGVyLWNvbG9yLWRlZmF1bHQ6ICNlZWU7XG4gIH1cbjwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImlnbm9yZUxpc3QiOltdfQ== */"
};
function Wrapper($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Wrapper);
  append_styles($$anchor, $$css5);
  let domNode = prop($$props, "domNode", 15), clientWidth = prop($$props, "clientWidth", 15), clientHeight = prop($$props, "clientHeight", 15);
  let id2 = tag(user_derived(() => $$props.rest.id), "id"), className = tag(user_derived(() => $$props.rest.class), "className"), nodeTypes = tag(user_derived(() => $$props.rest.nodeTypes), "nodeTypes"), edgeTypes = tag(user_derived(() => $$props.rest.edgeTypes), "edgeTypes"), _colorMode = tag(user_derived(() => $$props.rest.colorMode), "_colorMode"), isValidConnection = tag(user_derived(() => $$props.rest.isValidConnection), "isValidConnection"), onmove = tag(user_derived(() => $$props.rest.onmove), "onmove"), onmovestart = tag(user_derived(() => $$props.rest.onmovestart), "onmovestart"), onmoveend = tag(user_derived(() => $$props.rest.onmoveend), "onmoveend"), onflowerror = tag(user_derived(() => $$props.rest.onflowerror), "onflowerror"), ondelete = tag(user_derived(() => $$props.rest.ondelete), "ondelete"), onbeforedelete = tag(user_derived(() => $$props.rest.onbeforedelete), "onbeforedelete"), onbeforeconnect = tag(user_derived(() => $$props.rest.onbeforeconnect), "onbeforeconnect"), onconnect = tag(user_derived(() => $$props.rest.onconnect), "onconnect"), onconnectstart = tag(user_derived(() => $$props.rest.onconnectstart), "onconnectstart"), onconnectend = tag(user_derived(() => $$props.rest.onconnectend), "onconnectend"), onbeforereconnect = tag(user_derived(() => $$props.rest.onbeforereconnect), "onbeforereconnect"), onreconnect = tag(user_derived(() => $$props.rest.onreconnect), "onreconnect"), onreconnectstart = tag(user_derived(() => $$props.rest.onreconnectstart), "onreconnectstart"), onreconnectend = tag(user_derived(() => $$props.rest.onreconnectend), "onreconnectend"), onclickconnectstart = tag(user_derived(() => $$props.rest.onclickconnectstart), "onclickconnectstart"), onclickconnectend = tag(user_derived(() => $$props.rest.onclickconnectend), "onclickconnectend"), oninit = tag(user_derived(() => $$props.rest.oninit), "oninit"), onselectionchange = tag(user_derived(() => $$props.rest.onselectionchange), "onselectionchange"), onselectiondragstart = tag(user_derived(() => $$props.rest.onselectiondragstart), "onselectiondragstart"), onselectiondrag = tag(user_derived(() => $$props.rest.onselectiondrag), "onselectiondrag"), onselectiondragstop = tag(user_derived(() => $$props.rest.onselectiondragstop), "onselectiondragstop"), onselectionstart = tag(user_derived(() => $$props.rest.onselectionstart), "onselectionstart"), onselectionend = tag(user_derived(() => $$props.rest.onselectionend), "onselectionend"), clickConnect = tag(user_derived(() => $$props.rest.clickConnect), "clickConnect"), fitView = tag(user_derived(() => $$props.rest.fitView), "fitView"), fitViewOptions = tag(user_derived(() => $$props.rest.fitViewOptions), "fitViewOptions"), nodeOrigin = tag(user_derived(() => $$props.rest.nodeOrigin), "nodeOrigin"), nodeDragThreshold = tag(user_derived(() => $$props.rest.nodeDragThreshold), "nodeDragThreshold"), connectionDragThreshold = tag(user_derived(() => $$props.rest.connectionDragThreshold), "connectionDragThreshold"), minZoom = tag(user_derived(() => $$props.rest.minZoom), "minZoom"), maxZoom = tag(user_derived(() => $$props.rest.maxZoom), "maxZoom"), initialViewport = tag(user_derived(() => $$props.rest.initialViewport), "initialViewport"), connectionRadius = tag(user_derived(() => $$props.rest.connectionRadius), "connectionRadius"), connectionMode = tag(user_derived(() => $$props.rest.connectionMode), "connectionMode"), selectionMode = tag(user_derived(() => $$props.rest.selectionMode), "selectionMode"), selectNodesOnDrag = tag(user_derived(() => $$props.rest.selectNodesOnDrag), "selectNodesOnDrag"), snapGrid = tag(user_derived(() => $$props.rest.snapGrid), "snapGrid"), defaultMarkerColor = tag(user_derived(() => $$props.rest.defaultMarkerColor), "defaultMarkerColor"), translateExtent = tag(user_derived(() => $$props.rest.translateExtent), "translateExtent"), nodeExtent = tag(user_derived(() => $$props.rest.nodeExtent), "nodeExtent"), onlyRenderVisibleElements = tag(user_derived(() => $$props.rest.onlyRenderVisibleElements), "onlyRenderVisibleElements"), autoPanOnConnect = tag(user_derived(() => $$props.rest.autoPanOnConnect), "autoPanOnConnect"), autoPanOnNodeDrag = tag(user_derived(() => $$props.rest.autoPanOnNodeDrag), "autoPanOnNodeDrag"), colorModeSSR = tag(user_derived(() => $$props.rest.colorModeSSR), "colorModeSSR"), defaultEdgeOptions = tag(user_derived(() => $$props.rest.defaultEdgeOptions), "defaultEdgeOptions"), elevateNodesOnSelect = tag(user_derived(() => $$props.rest.elevateNodesOnSelect), "elevateNodesOnSelect"), elevateEdgesOnSelect = tag(user_derived(() => $$props.rest.elevateEdgesOnSelect), "elevateEdgesOnSelect"), nodesDraggable = tag(user_derived(() => $$props.rest.nodesDraggable), "nodesDraggable"), autoPanOnNodeFocus = tag(user_derived(() => $$props.rest.autoPanOnNodeFocus), "autoPanOnNodeFocus"), nodesConnectable = tag(user_derived(() => $$props.rest.nodesConnectable), "nodesConnectable"), elementsSelectable = tag(user_derived(() => $$props.rest.elementsSelectable), "elementsSelectable"), nodesFocusable = tag(user_derived(() => $$props.rest.nodesFocusable), "nodesFocusable"), edgesFocusable = tag(user_derived(() => $$props.rest.edgesFocusable), "edgesFocusable"), disableKeyboardA11y = tag(user_derived(() => $$props.rest.disableKeyboardA11y), "disableKeyboardA11y"), noDragClass = tag(user_derived(() => $$props.rest.noDragClass), "noDragClass"), noPanClass = tag(user_derived(() => $$props.rest.noPanClass), "noPanClass"), noWheelClass = tag(user_derived(() => $$props.rest.noWheelClass), "noWheelClass"), ariaLabelConfig = tag(user_derived(() => $$props.rest.ariaLabelConfig), "ariaLabelConfig"), autoPanSpeed = tag(user_derived(() => $$props.rest.autoPanSpeed), "autoPanSpeed"), panOnScrollSpeed = tag(user_derived(() => $$props.rest.panOnScrollSpeed), "panOnScrollSpeed"), divAttributes = tag(
    user_derived(() => exclude_from_object($$props.rest, [
      "id",
      "class",
      "nodeTypes",
      "edgeTypes",
      "colorMode",
      "isValidConnection",
      "onmove",
      "onmovestart",
      "onmoveend",
      "onflowerror",
      "ondelete",
      "onbeforedelete",
      "onbeforeconnect",
      "onconnect",
      "onconnectstart",
      "onconnectend",
      "onbeforereconnect",
      "onreconnect",
      "onreconnectstart",
      "onreconnectend",
      "onclickconnectstart",
      "onclickconnectend",
      "oninit",
      "onselectionchange",
      "onselectiondragstart",
      "onselectiondrag",
      "onselectiondragstop",
      "onselectionstart",
      "onselectionend",
      "clickConnect",
      "fitView",
      "fitViewOptions",
      "nodeOrigin",
      "nodeDragThreshold",
      "connectionDragThreshold",
      "minZoom",
      "maxZoom",
      "initialViewport",
      "connectionRadius",
      "connectionMode",
      "selectionMode",
      "selectNodesOnDrag",
      "snapGrid",
      "defaultMarkerColor",
      "translateExtent",
      "nodeExtent",
      "onlyRenderVisibleElements",
      "autoPanOnConnect",
      "autoPanOnNodeDrag",
      "colorModeSSR",
      "defaultEdgeOptions",
      "elevateNodesOnSelect",
      "elevateEdgesOnSelect",
      "nodesDraggable",
      "autoPanOnNodeFocus",
      "nodesConnectable",
      "elementsSelectable",
      "nodesFocusable",
      "edgesFocusable",
      "disableKeyboardA11y",
      "noDragClass",
      "noPanClass",
      "noWheelClass",
      "ariaLabelConfig",
      "autoPanSpeed",
      "panOnScrollSpeed"
    ])),
    "divAttributes"
  );
  function wrapperOnScroll(e) {
    e.currentTarget.scrollTo({ top: 0, left: 0, behavior: "auto" });
    if ($$props.rest.onscroll) {
      $$props.rest.onscroll(e);
    }
  }
  var $$exports = { ...legacy_api() };
  var div = root17();
  attribute_effect(
    div,
    ($0) => ({
      class: [
        "svelte-flow",
        "svelte-flow__container",
        get(className),
        $$props.colorMode
      ],
      "data-testid": "svelte-flow__wrapper",
      role: "application",
      onscroll: wrapperOnScroll,
      ...get(divAttributes),
      [STYLE]: $0
    }),
    [
      () => ({
        width: toPxString($$props.width),
        height: toPxString($$props.height)
      })
    ],
    void 0,
    void 0,
    "s-02z9KUhAEKFM"
  );
  var node = child(div);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop), "render", Wrapper, 130, 2);
  reset(div);
  bind_this(div, ($$value) => domNode($$value), () => domNode());
  bind_element_size(div, "clientHeight", clientHeight);
  bind_element_size(div, "clientWidth", clientWidth);
  append($$anchor, div);
  return pop($$exports);
}
if (import.meta.hot) {
  Wrapper = hmr(Wrapper, () => Wrapper[HMR].source);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-02z9KUhAEKFM");
    module.default[HMR].source = Wrapper[HMR].source;
    set(Wrapper[HMR].source, module.default[HMR].original);
  });
}
var Wrapper_default = Wrapper;

// node_modules/@xyflow/svelte/dist/lib/container/SvelteFlow/SvelteFlow.svelte
SvelteFlow[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/container/SvelteFlow/SvelteFlow.svelte";
var root_4 = add_locations(from_html(`<div class="svelte-flow__viewport-back svelte-flow__container"></div> <!> <div class="svelte-flow__edge-labels svelte-flow__container"></div> <!> <!> <!> <div class="svelte-flow__viewport-front svelte-flow__container"></div>`, 1), SvelteFlow[FILENAME], [[176, 8], [184, 8], [212, 8]]);
var root_33 = add_locations(from_html(`<!> <!>`, 1), SvelteFlow[FILENAME], []);
var root_19 = add_locations(from_html(`<!> <!> <!> <!> <!>`, 1), SvelteFlow[FILENAME], []);
function SvelteFlow($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, SvelteFlow);
  let paneClickDistance = prop($$props, "paneClickDistance", 3, 1), nodeClickDistance = prop($$props, "nodeClickDistance", 3, 1), panOnScrollMode = prop($$props, "panOnScrollMode", 19, () => PanOnScrollMode.Free), preventScrolling = prop($$props, "preventScrolling", 3, true), zoomOnScroll = prop($$props, "zoomOnScroll", 3, true), zoomOnDoubleClick = prop($$props, "zoomOnDoubleClick", 3, true), zoomOnPinch = prop($$props, "zoomOnPinch", 3, true), panOnScroll = prop($$props, "panOnScroll", 3, false), panOnScrollSpeed = prop($$props, "panOnScrollSpeed", 3, 0.5), panOnDrag = prop($$props, "panOnDrag", 3, true), selectionOnDrag = prop($$props, "selectionOnDrag", 3, false), connectionLineType = prop($$props, "connectionLineType", 19, () => ConnectionLineType.Bezier), nodes = prop($$props, "nodes", 31, () => tag_proxy(proxy([]), "nodes")), edges = prop($$props, "edges", 31, () => tag_proxy(proxy([]), "edges")), viewport = prop($$props, "viewport", 15, void 0), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "width",
      "height",
      "proOptions",
      "selectionKey",
      "deleteKey",
      "panActivationKey",
      "multiSelectionKey",
      "zoomActivationKey",
      "paneClickDistance",
      "nodeClickDistance",
      "onmovestart",
      "onmoveend",
      "onmove",
      "oninit",
      "onnodeclick",
      "onnodecontextmenu",
      "onnodedrag",
      "onnodedragstart",
      "onnodedragstop",
      "onnodepointerenter",
      "onnodepointermove",
      "onnodepointerleave",
      "onselectionclick",
      "onselectioncontextmenu",
      "onselectionstart",
      "onselectionend",
      "onedgeclick",
      "onedgecontextmenu",
      "onedgepointerenter",
      "onedgepointerleave",
      "onpaneclick",
      "onpanecontextmenu",
      "panOnScrollMode",
      "preventScrolling",
      "zoomOnScroll",
      "zoomOnDoubleClick",
      "zoomOnPinch",
      "panOnScroll",
      "panOnScrollSpeed",
      "panOnDrag",
      "selectionOnDrag",
      "connectionLineComponent",
      "connectionLineStyle",
      "connectionLineContainerStyle",
      "connectionLineType",
      "attributionPosition",
      "children",
      "nodes",
      "edges",
      "viewport"
    ],
    "props"
  );
  let store = createStore({
    props,
    width: $$props.width,
    height: $$props.height,
    get nodes() {
      return nodes();
    },
    set nodes(newNodes) {
      nodes(newNodes);
    },
    get edges() {
      return edges();
    },
    set edges(newEdges) {
      edges(newEdges);
    },
    get viewport() {
      return viewport();
    },
    set viewport(newViewport) {
      viewport(newViewport);
    }
  });
  const providerContext = getContext(key);
  if (providerContext && providerContext.setStore) {
    providerContext.setStore(store);
  }
  setContext(key, {
    provider: false,
    getStore() {
      return store;
    }
  });
  user_effect(() => {
    const params = { nodes: store.selectedNodes, edges: store.selectedEdges };
    untrack(() => $$props.onselectionchange)?.(params);
    for (const handler of store.selectionChangeHandlers.values()) {
      handler(params);
    }
  });
  onDestroy(() => {
    store.reset();
  });
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  validate_binding("bind:domNode={store.domNode}", [], () => store, () => "domNode", 132, 2);
  validate_binding("bind:clientWidth={store.width}", [], () => store, () => "width", 133, 2);
  validate_binding("bind:clientHeight={store.height}", [], () => store, () => "height", 134, 2);
  add_svelte_meta(
    () => Wrapper_default(node, {
      get colorMode() {
        return store.colorMode;
      },
      get width() {
        return $$props.width;
      },
      get height() {
        return $$props.height;
      },
      get rest() {
        return props;
      },
      get domNode() {
        return store.domNode;
      },
      set domNode($$value) {
        store.domNode = $$value;
      },
      get clientWidth() {
        return store.width;
      },
      set clientWidth($$value) {
        store.width = $$value;
      },
      get clientHeight() {
        return store.height;
      },
      set clientHeight($$value) {
        store.height = $$value;
      },
      children: wrap_snippet(SvelteFlow, ($$anchor2, $$slotProps) => {
        var fragment_1 = root_19();
        var node_1 = first_child(fragment_1);
        add_svelte_meta(
          () => KeyHandler_default(node_1, {
            get selectionKey() {
              return $$props.selectionKey;
            },
            get deleteKey() {
              return $$props.deleteKey;
            },
            get panActivationKey() {
              return $$props.panActivationKey;
            },
            get multiSelectionKey() {
              return $$props.multiSelectionKey;
            },
            get zoomActivationKey() {
              return $$props.zoomActivationKey;
            },
            get store() {
              return store;
            },
            set store($$value) {
              store = $$value;
            }
          }),
          "component",
          SvelteFlow,
          140,
          2,
          { componentTag: "KeyHandler" }
        );
        var node_2 = sibling(node_1, 2);
        add_svelte_meta(
          () => Zoom_default(node_2, {
            get panOnScrollMode() {
              return panOnScrollMode();
            },
            get preventScrolling() {
              return preventScrolling();
            },
            get zoomOnScroll() {
              return zoomOnScroll();
            },
            get zoomOnDoubleClick() {
              return zoomOnDoubleClick();
            },
            get zoomOnPinch() {
              return zoomOnPinch();
            },
            get panOnScroll() {
              return panOnScroll();
            },
            get panOnScrollSpeed() {
              return panOnScrollSpeed();
            },
            get panOnDrag() {
              return panOnDrag();
            },
            get paneClickDistance() {
              return paneClickDistance();
            },
            get selectionOnDrag() {
              return selectionOnDrag();
            },
            get onmovestart() {
              return $$props.onmovestart;
            },
            get onmove() {
              return $$props.onmove;
            },
            get onmoveend() {
              return $$props.onmoveend;
            },
            get oninit() {
              return $$props.oninit;
            },
            get store() {
              return store;
            },
            set store($$value) {
              store = $$value;
            },
            children: wrap_snippet(SvelteFlow, ($$anchor3, $$slotProps2) => {
              var fragment_2 = comment();
              var node_3 = first_child(fragment_2);
              add_svelte_meta(
                () => Pane_default(node_3, {
                  get onpaneclick() {
                    return $$props.onpaneclick;
                  },
                  get onpanecontextmenu() {
                    return $$props.onpanecontextmenu;
                  },
                  get onselectionstart() {
                    return $$props.onselectionstart;
                  },
                  get onselectionend() {
                    return $$props.onselectionend;
                  },
                  get panOnDrag() {
                    return panOnDrag();
                  },
                  get paneClickDistance() {
                    return paneClickDistance();
                  },
                  get selectionOnDrag() {
                    return selectionOnDrag();
                  },
                  get store() {
                    return store;
                  },
                  set store($$value) {
                    store = $$value;
                  },
                  children: wrap_snippet(SvelteFlow, ($$anchor4, $$slotProps3) => {
                    var fragment_3 = root_33();
                    var node_4 = first_child(fragment_3);
                    add_svelte_meta(
                      () => Viewport_default(node_4, {
                        get store() {
                          return store;
                        },
                        set store($$value) {
                          store = $$value;
                        },
                        children: wrap_snippet(SvelteFlow, ($$anchor5, $$slotProps4) => {
                          var fragment_4 = root_4();
                          var node_5 = sibling(first_child(fragment_4), 2);
                          add_svelte_meta(
                            () => EdgeRenderer_default(node_5, {
                              get onedgeclick() {
                                return $$props.onedgeclick;
                              },
                              get onedgecontextmenu() {
                                return $$props.onedgecontextmenu;
                              },
                              get onedgepointerenter() {
                                return $$props.onedgepointerenter;
                              },
                              get onedgepointerleave() {
                                return $$props.onedgepointerleave;
                              },
                              get store() {
                                return store;
                              },
                              set store($$value) {
                                store = $$value;
                              }
                            }),
                            "component",
                            SvelteFlow,
                            177,
                            8,
                            { componentTag: "EdgeRenderer" }
                          );
                          var node_6 = sibling(node_5, 4);
                          add_svelte_meta(
                            () => ConnectionLine_default(node_6, {
                              get type() {
                                return connectionLineType();
                              },
                              get LineComponent() {
                                return $$props.connectionLineComponent;
                              },
                              get containerStyle() {
                                return $$props.connectionLineContainerStyle;
                              },
                              get style() {
                                return $$props.connectionLineStyle;
                              },
                              get store() {
                                return store;
                              },
                              set store($$value) {
                                store = $$value;
                              }
                            }),
                            "component",
                            SvelteFlow,
                            185,
                            8,
                            { componentTag: "ConnectionLine" }
                          );
                          var node_7 = sibling(node_6, 2);
                          add_svelte_meta(
                            () => NodeRenderer_default(node_7, {
                              get nodeClickDistance() {
                                return nodeClickDistance();
                              },
                              get onnodeclick() {
                                return $$props.onnodeclick;
                              },
                              get onnodecontextmenu() {
                                return $$props.onnodecontextmenu;
                              },
                              get onnodepointerenter() {
                                return $$props.onnodepointerenter;
                              },
                              get onnodepointermove() {
                                return $$props.onnodepointermove;
                              },
                              get onnodepointerleave() {
                                return $$props.onnodepointerleave;
                              },
                              get onnodedrag() {
                                return $$props.onnodedrag;
                              },
                              get onnodedragstart() {
                                return $$props.onnodedragstart;
                              },
                              get onnodedragstop() {
                                return $$props.onnodedragstop;
                              },
                              get store() {
                                return store;
                              },
                              set store($$value) {
                                store = $$value;
                              }
                            }),
                            "component",
                            SvelteFlow,
                            192,
                            8,
                            { componentTag: "NodeRenderer" }
                          );
                          var node_8 = sibling(node_7, 2);
                          add_svelte_meta(
                            () => NodeSelection_default(node_8, {
                              get onselectionclick() {
                                return $$props.onselectionclick;
                              },
                              get onselectioncontextmenu() {
                                return $$props.onselectioncontextmenu;
                              },
                              get onnodedrag() {
                                return $$props.onnodedrag;
                              },
                              get onnodedragstart() {
                                return $$props.onnodedragstart;
                              },
                              get onnodedragstop() {
                                return $$props.onnodedragstop;
                              },
                              get store() {
                                return store;
                              },
                              set store($$value) {
                                store = $$value;
                              }
                            }),
                            "component",
                            SvelteFlow,
                            204,
                            8,
                            { componentTag: "NodeSelection" }
                          );
                          next(2);
                          append($$anchor5, fragment_4);
                        }),
                        $$slots: { default: true }
                      }),
                      "component",
                      SvelteFlow,
                      175,
                      6,
                      { componentTag: "ViewportComponent" }
                    );
                    var node_9 = sibling(node_4, 2);
                    {
                      let $0 = user_derived(() => !!(store.selectionRect && strict_equals(store.selectionRectMode, "user")));
                      let $1 = user_derived(() => store.selectionRect?.width);
                      let $2 = user_derived(() => store.selectionRect?.height);
                      let $3 = user_derived(() => store.selectionRect?.x);
                      let $4 = user_derived(() => store.selectionRect?.y);
                      add_svelte_meta(
                        () => Selection_default(node_9, {
                          get isVisible() {
                            return get($0);
                          },
                          get width() {
                            return get($1);
                          },
                          get height() {
                            return get($2);
                          },
                          get x() {
                            return get($3);
                          },
                          get y() {
                            return get($4);
                          }
                        }),
                        "component",
                        SvelteFlow,
                        214,
                        6,
                        { componentTag: "Selection" }
                      );
                    }
                    append($$anchor4, fragment_3);
                  }),
                  $$slots: { default: true }
                }),
                "component",
                SvelteFlow,
                165,
                4,
                { componentTag: "Pane" }
              );
              append($$anchor3, fragment_2);
            }),
            $$slots: { default: true }
          }),
          "component",
          SvelteFlow,
          148,
          2,
          { componentTag: "Zoom" }
        );
        var node_10 = sibling(node_2, 2);
        add_svelte_meta(
          () => Attribution_default(node_10, {
            get proOptions() {
              return $$props.proOptions;
            },
            get position() {
              return $$props.attributionPosition;
            }
          }),
          "component",
          SvelteFlow,
          223,
          2,
          { componentTag: "Attribution" }
        );
        var node_11 = sibling(node_10, 2);
        add_svelte_meta(
          () => A11yDescriptions_default(node_11, {
            get store() {
              return store;
            }
          }),
          "component",
          SvelteFlow,
          224,
          2,
          { componentTag: "A11yDescriptions" }
        );
        var node_12 = sibling(node_11, 2);
        add_svelte_meta(() => snippet(node_12, () => $$props.children ?? noop), "render", SvelteFlow, 225, 2);
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }),
    "component",
    SvelteFlow,
    131,
    0,
    { componentTag: "Wrapper" }
  );
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  SvelteFlow = hmr(SvelteFlow, () => SvelteFlow[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SvelteFlow[HMR].source;
    set(SvelteFlow[HMR].source, module.default[HMR].original);
  });
}
var SvelteFlow_default = SvelteFlow;

// node_modules/@xyflow/svelte/dist/lib/components/SvelteFlowProvider/SvelteFlowProvider.svelte
SvelteFlowProvider[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/SvelteFlowProvider/SvelteFlowProvider.svelte";
function SvelteFlowProvider($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, SvelteFlowProvider);
  let store = tag(state(createStore({ props: {}, nodes: [], edges: [] })), "store");
  setContext(key, {
    provider: true,
    getStore() {
      return get(store);
    },
    setStore: (newStore) => {
      set(store, newStore);
    }
  });
  onDestroy(() => {
    get(store).reset();
  });
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop), "render", SvelteFlowProvider, 34, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  SvelteFlowProvider = hmr(SvelteFlowProvider, () => SvelteFlowProvider[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SvelteFlowProvider[HMR].source;
    set(SvelteFlowProvider[HMR].source, module.default[HMR].original);
  });
}
var SvelteFlowProvider_default = SvelteFlowProvider;

// node_modules/@xyflow/svelte/dist/lib/components/ViewportPortal/ViewportPortal.svelte
ViewportPortal[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/ViewportPortal/ViewportPortal.svelte";
var root18 = add_locations(from_html(`<div><!></div>`), ViewportPortal[FILENAME], [[8, 0]]);
function ViewportPortal($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, ViewportPortal);
  let target = prop($$props, "target", 3, "front"), rest = rest_props($$props, ["$$slots", "$$events", "$$legacy", "target", "children"], "rest");
  var $$exports = { ...legacy_api() };
  var div = root18();
  attribute_effect(div, ($0) => ({ ...rest, [STYLE]: $0 }), [() => ({ display: hideOnSSR().value ? "none" : void 0 })]);
  var node = child(div);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop), "render", ViewportPortal, 13, 2);
  reset(div);
  action(div, ($$node, $$action_arg) => portal?.($$node, $$action_arg), () => `viewport-${target()}`);
  append($$anchor, div);
  return pop($$exports);
}
if (import.meta.hot) {
  ViewportPortal = hmr(ViewportPortal, () => ViewportPortal[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ViewportPortal[HMR].source;
    set(ViewportPortal[HMR].source, module.default[HMR].original);
  });
}
var ViewportPortal_default = ViewportPortal;

// node_modules/@xyflow/svelte/dist/lib/components/EdgeReconnectAnchor/EdgeReconnectAnchor.svelte
EdgeReconnectAnchor[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/EdgeReconnectAnchor/EdgeReconnectAnchor.svelte";
function EdgeReconnectAnchor($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, EdgeReconnectAnchor);
  let reconnecting = prop($$props, "reconnecting", 15, false), size = prop($$props, "size", 3, 25), dragThreshold = prop($$props, "dragThreshold", 3, 1), rest = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "type",
      "reconnecting",
      "position",
      "class",
      "size",
      "dragThreshold",
      "children"
    ],
    "rest"
  );
  const store = useStore();
  let edgeId = getContext("svelteflow__edge_id");
  if (!edgeId) {
    throw new Error("EdgeReconnectAnchor must be used within an Edge component");
  }
  const onPointerDown2 = (event2) => {
    if (strict_equals(event2.button, 0, false)) {
      return;
    }
    const {
      autoPanOnConnect,
      domNode,
      isValidConnection,
      connectionMode,
      connectionRadius,
      onconnectstart,
      onconnectend,
      onreconnect,
      onreconnectstart,
      onreconnectend,
      onbeforereconnect,
      cancelConnection,
      nodeLookup,
      flowId,
      panBy: panBy2,
      updateConnection,
      edgeLookup
    } = store;
    let edge = edgeLookup.get(edgeId);
    const _onConnectStart = (evt, params) => {
      reconnecting(true);
      onreconnectstart?.(event2, edge, $$props.type);
      onconnectstart?.(evt, params);
    };
    const opposite = strict_equals($$props.type, "target") ? {
      nodeId: edge.source,
      handleId: edge.sourceHandle ?? null,
      type: "source"
    } : {
      nodeId: edge.target,
      handleId: edge.targetHandle ?? null,
      type: "target"
    };
    XYHandle.onPointerDown(event2, {
      autoPanOnConnect,
      connectionMode,
      connectionRadius,
      domNode,
      handleId: opposite.handleId,
      nodeId: opposite.nodeId,
      nodeLookup,
      isTarget: strict_equals(opposite.type, "target"),
      edgeUpdaterType: opposite.type,
      lib: "svelte",
      flowId,
      cancelConnection,
      panBy: panBy2,
      isValidConnection,
      onConnectStart: _onConnectStart,
      onConnectEnd: onconnectend,
      onConnect: (connection) => {
        const reconnectedEdge = { ...edge, ...connection };
        const newEdge = onbeforereconnect ? onbeforereconnect(reconnectedEdge, edge) : reconnectedEdge;
        if (!newEdge) {
          return;
        }
        store.edges = store.edges.map((e) => strict_equals(e.id, edge.id) ? newEdge : e);
        onreconnect?.(edge, connection);
      },
      onReconnectEnd: (event3, connectionState) => {
        reconnecting(false);
        onreconnectend?.(event3, edge, opposite.type, connectionState);
      },
      updateConnection,
      getTransform: () => [store.viewport.x, store.viewport.y, store.viewport.zoom],
      getFromHandle: () => store.connection.fromHandle,
      dragThreshold: dragThreshold() ?? store.connectionDragThreshold,
      handleDomNode: event2.currentTarget
    });
  };
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    let $0 = user_derived(() => $$props.position?.x);
    let $1 = user_derived(() => $$props.position?.y);
    let $2 = user_derived(() => [
      "svelte-flow__edgeupdater",
      `svelte-flow__edgeupdater-${$$props.type}`,
      store.noPanClass,
      $$props.class
    ]);
    add_svelte_meta(
      () => EdgeLabel_default(node, spread_props(
        {
          get x() {
            return get($0);
          },
          get y() {
            return get($1);
          },
          get width() {
            return size();
          },
          get height() {
            return size();
          },
          get class() {
            return get($2);
          },
          onpointerdown: onPointerDown2,
          transparent: true
        },
        () => rest,
        {
          children: wrap_snippet(EdgeReconnectAnchor, ($$anchor2, $$slotProps) => {
            var fragment_1 = comment();
            var node_1 = first_child(fragment_1);
            {
              var consequent = ($$anchor3) => {
                var fragment_2 = comment();
                var node_2 = first_child(fragment_2);
                add_svelte_meta(() => snippet(node_2, () => $$props.children), "render", EdgeReconnectAnchor, 129, 4);
                append($$anchor3, fragment_2);
              };
              add_svelte_meta(
                () => if_block(node_1, ($$render) => {
                  if (!reconnecting() && $$props.children) $$render(consequent);
                }),
                "if",
                EdgeReconnectAnchor,
                128,
                2
              );
            }
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      EdgeReconnectAnchor,
      113,
      0,
      { componentTag: "EdgeLabel" }
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  EdgeReconnectAnchor = hmr(EdgeReconnectAnchor, () => EdgeReconnectAnchor[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = EdgeReconnectAnchor[HMR].source;
    set(EdgeReconnectAnchor[HMR].source, module.default[HMR].original);
  });
}
var EdgeReconnectAnchor_default = EdgeReconnectAnchor;

// node_modules/@xyflow/svelte/dist/lib/plugins/Controls/ControlButton.svelte
ControlButton[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/plugins/Controls/ControlButton.svelte";
var root19 = add_locations(from_html(`<button><!></button>`), ControlButton[FILENAME], [[17, 0]]);
function ControlButton($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, ControlButton);
  let restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "class",
      "bgColor",
      "bgColorHover",
      "color",
      "colorHover",
      "borderColor",
      "onclick",
      "children"
    ],
    "restProps"
  );
  var $$exports = { ...legacy_api() };
  var button = root19();
  attribute_effect(button, () => ({
    type: "button",
    onclick: $$props.onclick,
    class: ["svelte-flow__controls-button", $$props.class],
    ...restProps,
    [STYLE]: {
      "--xy-controls-button-background-color-props": $$props.bgColor,
      "--xy-controls-button-background-color-hover-props": $$props.bgColorHover,
      "--xy-controls-button-color-props": $$props.color,
      "--xy-controls-button-color-hover-props": $$props.colorHover,
      "--xy-controls-button-border-color-props": $$props.borderColor
    }
  }));
  var node = child(button);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop), "render", ControlButton, 28, 2);
  reset(button);
  append($$anchor, button);
  return pop($$exports);
}
if (import.meta.hot) {
  ControlButton = hmr(ControlButton, () => ControlButton[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ControlButton[HMR].source;
    set(ControlButton[HMR].source, module.default[HMR].original);
  });
}
var ControlButton_default = ControlButton;

// node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Plus.svelte
Plus[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Plus.svelte";
var root20 = add_locations(from_svg(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z"></path></svg>`), Plus[FILENAME], [[1, 0, [[2, 2]]]]);
function Plus($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Plus);
  var $$exports = { ...legacy_api() };
  var svg = root20();
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  Plus = hmr(Plus, () => Plus[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Plus[HMR].source;
    set(Plus[HMR].source, module.default[HMR].original);
  });
}
var Plus_default = Plus;

// node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Minus.svelte
Minus[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Minus.svelte";
var root21 = add_locations(from_svg(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 5"><path d="M0 0h32v4.2H0z"></path></svg>`), Minus[FILENAME], [[1, 0, [[2, 2]]]]);
function Minus($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Minus);
  var $$exports = { ...legacy_api() };
  var svg = root21();
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  Minus = hmr(Minus, () => Minus[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Minus[HMR].source;
    set(Minus[HMR].source, module.default[HMR].original);
  });
}
var Minus_default = Minus;

// node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Fit.svelte
Fit[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Fit.svelte";
var root22 = add_locations(from_svg(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 30"><path d="M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z"></path></svg>`), Fit[FILENAME], [[1, 0, [[2, 2]]]]);
function Fit($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Fit);
  var $$exports = { ...legacy_api() };
  var svg = root22();
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  Fit = hmr(Fit, () => Fit[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Fit[HMR].source;
    set(Fit[HMR].source, module.default[HMR].original);
  });
}
var Fit_default = Fit;

// node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Lock.svelte
Lock[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Lock.svelte";
var root23 = add_locations(from_svg(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 25 32"><path d="M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z"></path></svg>`), Lock[FILENAME], [[1, 0, [[2, 2]]]]);
function Lock($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Lock);
  var $$exports = { ...legacy_api() };
  var svg = root23();
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  Lock = hmr(Lock, () => Lock[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Lock[HMR].source;
    set(Lock[HMR].source, module.default[HMR].original);
  });
}
var Lock_default = Lock;

// node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Unlock.svelte
Unlock[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Unlock.svelte";
var root24 = add_locations(from_svg(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 25 32"><path d="M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z"></path></svg>`), Unlock[FILENAME], [[1, 0, [[2, 2]]]]);
function Unlock($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Unlock);
  var $$exports = { ...legacy_api() };
  var svg = root24();
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  Unlock = hmr(Unlock, () => Unlock[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Unlock[HMR].source;
    set(Unlock[HMR].source, module.default[HMR].original);
  });
}
var Unlock_default = Unlock;

// node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Controls.svelte
Controls[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Controls.svelte";
var root_34 = add_locations(from_html(`<!> <!>`, 1), Controls[FILENAME], []);
var root_110 = add_locations(from_html(`<!> <!> <!> <!> <!> <!>`, 1), Controls[FILENAME], []);
function Controls($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Controls);
  let position = prop($$props, "position", 3, "bottom-left"), orientation = prop($$props, "orientation", 3, "vertical"), showZoom = prop($$props, "showZoom", 3, true), showFitView = prop($$props, "showFitView", 3, true), showLock = prop($$props, "showLock", 3, true), rest = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "position",
      "orientation",
      "showZoom",
      "showFitView",
      "showLock",
      "style",
      "class",
      "buttonBgColor",
      "buttonBgColorHover",
      "buttonColor",
      "buttonColorHover",
      "buttonBorderColor",
      "fitViewOptions",
      "children",
      "before",
      "after"
    ],
    "rest"
  );
  let store = tag(user_derived(useStore), "store");
  const buttonProps = {
    bgColor: $$props.buttonBgColor,
    bgColorHover: $$props.buttonBgColorHover,
    color: $$props.buttonColor,
    colorHover: $$props.buttonColorHover,
    borderColor: $$props.buttonBorderColor
  };
  let isInteractive = tag(user_derived(() => get(store).nodesDraggable || get(store).nodesConnectable || get(store).elementsSelectable), "isInteractive");
  let minZoomReached = tag(user_derived(() => get(store).viewport.zoom <= get(store).minZoom), "minZoomReached");
  let maxZoomReached = tag(user_derived(() => get(store).viewport.zoom >= get(store).maxZoom), "maxZoomReached");
  let ariaLabelConfig = tag(user_derived(() => get(store).ariaLabelConfig), "ariaLabelConfig");
  let orientationClass = tag(user_derived(() => strict_equals(orientation(), "horizontal") ? "horizontal" : "vertical"), "orientationClass");
  const onZoomInHandler = () => {
    get(store).zoomIn();
  };
  const onZoomOutHandler = () => {
    get(store).zoomOut();
  };
  const onFitViewHandler = () => {
    get(store).fitView($$props.fitViewOptions);
  };
  const onToggleInteractivity = () => {
    let interactive2 = !get(isInteractive);
    get(store).nodesDraggable = interactive2;
    get(store).nodesConnectable = interactive2;
    get(store).elementsSelectable = interactive2;
  };
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    let $0 = user_derived(() => [
      "svelte-flow__controls",
      get(orientationClass),
      $$props.class
    ]);
    add_svelte_meta(
      () => Panel_default(node, spread_props(
        {
          get class() {
            return get($0);
          },
          get position() {
            return position();
          },
          "data-testid": "svelte-flow__controls",
          get "aria-label"() {
            return get(ariaLabelConfig)["controls.ariaLabel"];
          },
          get style() {
            return $$props.style;
          }
        },
        () => rest,
        {
          children: wrap_snippet(Controls, ($$anchor2, $$slotProps) => {
            var fragment_1 = root_110();
            var node_1 = first_child(fragment_1);
            {
              var consequent = ($$anchor3) => {
                var fragment_2 = comment();
                var node_2 = first_child(fragment_2);
                add_svelte_meta(() => snippet(node_2, () => $$props.before), "render", Controls, 80, 4);
                append($$anchor3, fragment_2);
              };
              add_svelte_meta(
                () => if_block(node_1, ($$render) => {
                  if ($$props.before) $$render(consequent);
                }),
                "if",
                Controls,
                79,
                2
              );
            }
            var node_3 = sibling(node_1, 2);
            {
              var consequent_1 = ($$anchor3) => {
                var fragment_3 = root_34();
                var node_4 = first_child(fragment_3);
                add_svelte_meta(
                  () => ControlButton_default(node_4, spread_props(
                    {
                      onclick: onZoomInHandler,
                      class: "svelte-flow__controls-zoomin",
                      get title() {
                        return get(ariaLabelConfig)["controls.zoomIn.ariaLabel"];
                      },
                      get "aria-label"() {
                        return get(ariaLabelConfig)["controls.zoomIn.ariaLabel"];
                      },
                      get disabled() {
                        return get(maxZoomReached);
                      }
                    },
                    () => buttonProps,
                    {
                      children: wrap_snippet(Controls, ($$anchor4, $$slotProps2) => {
                        var fragment_4 = comment();
                        var node_5 = first_child(fragment_4);
                        add_svelte_meta(() => Plus_default(node_5, {}), "component", Controls, 91, 6, { componentTag: "PlusIcon" });
                        append($$anchor4, fragment_4);
                      }),
                      $$slots: { default: true }
                    }
                  )),
                  "component",
                  Controls,
                  83,
                  4,
                  { componentTag: "ControlButton" }
                );
                var node_6 = sibling(node_4, 2);
                add_svelte_meta(
                  () => ControlButton_default(node_6, spread_props(
                    {
                      onclick: onZoomOutHandler,
                      class: "svelte-flow__controls-zoomout",
                      get title() {
                        return get(ariaLabelConfig)["controls.zoomOut.ariaLabel"];
                      },
                      get "aria-label"() {
                        return get(ariaLabelConfig)["controls.zoomOut.ariaLabel"];
                      },
                      get disabled() {
                        return get(minZoomReached);
                      }
                    },
                    () => buttonProps,
                    {
                      children: wrap_snippet(Controls, ($$anchor4, $$slotProps2) => {
                        var fragment_5 = comment();
                        var node_7 = first_child(fragment_5);
                        add_svelte_meta(() => Minus_default(node_7, {}), "component", Controls, 101, 6, { componentTag: "MinusIcon" });
                        append($$anchor4, fragment_5);
                      }),
                      $$slots: { default: true }
                    }
                  )),
                  "component",
                  Controls,
                  93,
                  4,
                  { componentTag: "ControlButton" }
                );
                append($$anchor3, fragment_3);
              };
              add_svelte_meta(
                () => if_block(node_3, ($$render) => {
                  if (showZoom()) $$render(consequent_1);
                }),
                "if",
                Controls,
                82,
                2
              );
            }
            var node_8 = sibling(node_3, 2);
            {
              var consequent_2 = ($$anchor3) => {
                var fragment_6 = comment();
                var node_9 = first_child(fragment_6);
                add_svelte_meta(
                  () => ControlButton_default(node_9, spread_props(
                    {
                      class: "svelte-flow__controls-fitview",
                      onclick: onFitViewHandler,
                      get title() {
                        return get(ariaLabelConfig)["controls.fitView.ariaLabel"];
                      },
                      get "aria-label"() {
                        return get(ariaLabelConfig)["controls.fitView.ariaLabel"];
                      }
                    },
                    () => buttonProps,
                    {
                      children: wrap_snippet(Controls, ($$anchor4, $$slotProps2) => {
                        var fragment_7 = comment();
                        var node_10 = first_child(fragment_7);
                        add_svelte_meta(() => Fit_default(node_10, {}), "component", Controls, 112, 6, { componentTag: "FitViewIcon" });
                        append($$anchor4, fragment_7);
                      }),
                      $$slots: { default: true }
                    }
                  )),
                  "component",
                  Controls,
                  105,
                  4,
                  { componentTag: "ControlButton" }
                );
                append($$anchor3, fragment_6);
              };
              add_svelte_meta(
                () => if_block(node_8, ($$render) => {
                  if (showFitView()) $$render(consequent_2);
                }),
                "if",
                Controls,
                104,
                2
              );
            }
            var node_11 = sibling(node_8, 2);
            {
              var consequent_4 = ($$anchor3) => {
                var fragment_8 = comment();
                var node_12 = first_child(fragment_8);
                add_svelte_meta(
                  () => ControlButton_default(node_12, spread_props(
                    {
                      class: "svelte-flow__controls-interactive",
                      onclick: onToggleInteractivity,
                      get title() {
                        return get(ariaLabelConfig)["controls.interactive.ariaLabel"];
                      },
                      get "aria-label"() {
                        return get(ariaLabelConfig)["controls.interactive.ariaLabel"];
                      }
                    },
                    () => buttonProps,
                    {
                      children: wrap_snippet(Controls, ($$anchor4, $$slotProps2) => {
                        var fragment_9 = comment();
                        var node_13 = first_child(fragment_9);
                        {
                          var consequent_3 = ($$anchor5) => {
                            var fragment_10 = comment();
                            var node_14 = first_child(fragment_10);
                            add_svelte_meta(() => Unlock_default(node_14, {}), "component", Controls, 123, 25, { componentTag: "UnlockIcon" });
                            append($$anchor5, fragment_10);
                          };
                          var alternate = ($$anchor5) => {
                            var fragment_11 = comment();
                            var node_15 = first_child(fragment_11);
                            add_svelte_meta(() => Lock_default(node_15, {}), "component", Controls, 123, 46, { componentTag: "LockIcon" });
                            append($$anchor5, fragment_11);
                          };
                          add_svelte_meta(
                            () => if_block(node_13, ($$render) => {
                              if (get(isInteractive)) $$render(consequent_3);
                              else $$render(alternate, false);
                            }),
                            "if",
                            Controls,
                            123,
                            6
                          );
                        }
                        append($$anchor4, fragment_9);
                      }),
                      $$slots: { default: true }
                    }
                  )),
                  "component",
                  Controls,
                  116,
                  4,
                  { componentTag: "ControlButton" }
                );
                append($$anchor3, fragment_8);
              };
              add_svelte_meta(
                () => if_block(node_11, ($$render) => {
                  if (showLock()) $$render(consequent_4);
                }),
                "if",
                Controls,
                115,
                2
              );
            }
            var node_16 = sibling(node_11, 2);
            {
              var consequent_5 = ($$anchor3) => {
                var fragment_12 = comment();
                var node_17 = first_child(fragment_12);
                add_svelte_meta(() => snippet(node_17, () => $$props.children), "render", Controls, 127, 4);
                append($$anchor3, fragment_12);
              };
              add_svelte_meta(
                () => if_block(node_16, ($$render) => {
                  if ($$props.children) $$render(consequent_5);
                }),
                "if",
                Controls,
                126,
                2
              );
            }
            var node_18 = sibling(node_16, 2);
            {
              var consequent_6 = ($$anchor3) => {
                var fragment_13 = comment();
                var node_19 = first_child(fragment_13);
                add_svelte_meta(() => snippet(node_19, () => $$props.after), "render", Controls, 130, 4);
                append($$anchor3, fragment_13);
              };
              add_svelte_meta(
                () => if_block(node_18, ($$render) => {
                  if ($$props.after) $$render(consequent_6);
                }),
                "if",
                Controls,
                129,
                2
              );
            }
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      Controls,
      71,
      0,
      { componentTag: "Panel" }
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Controls = hmr(Controls, () => Controls[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Controls[HMR].source;
    set(Controls[HMR].source, module.default[HMR].original);
  });
}
var Controls_default = Controls;

// node_modules/@xyflow/svelte/dist/lib/plugins/Background/types.js
var BackgroundVariant;
(function(BackgroundVariant2) {
  BackgroundVariant2["Lines"] = "lines";
  BackgroundVariant2["Dots"] = "dots";
  BackgroundVariant2["Cross"] = "cross";
})(BackgroundVariant || (BackgroundVariant = {}));

// node_modules/@xyflow/svelte/dist/lib/plugins/Background/DotPattern.svelte
DotPattern[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/plugins/Background/DotPattern.svelte";
var root25 = add_locations(from_svg(`<circle></circle>`), DotPattern[FILENAME], [[7, 0]]);
function DotPattern($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, DotPattern);
  var $$exports = { ...legacy_api() };
  var circle = root25();
  template_effect(() => {
    set_attribute(circle, "cx", $$props.radius);
    set_attribute(circle, "cy", $$props.radius);
    set_attribute(circle, "r", $$props.radius);
    set_class(circle, 0, clsx(["svelte-flow__background-pattern", "dots", $$props.class]));
  });
  append($$anchor, circle);
  return pop($$exports);
}
if (import.meta.hot) {
  DotPattern = hmr(DotPattern, () => DotPattern[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DotPattern[HMR].source;
    set(DotPattern[HMR].source, module.default[HMR].original);
  });
}
var DotPattern_default = DotPattern;

// node_modules/@xyflow/svelte/dist/lib/plugins/Background/LinePattern.svelte
LinePattern[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/plugins/Background/LinePattern.svelte";
var root26 = add_locations(from_svg(`<path></path>`), LinePattern[FILENAME], [[18, 0]]);
function LinePattern($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, LinePattern);
  var $$exports = { ...legacy_api() };
  var path = root26();
  template_effect(() => {
    set_attribute(path, "stroke-width", $$props.lineWidth);
    set_attribute(path, "d", `M${$$props.dimensions[0] / 2} 0 V${$$props.dimensions[1]} M0 ${$$props.dimensions[1] / 2} H${$$props.dimensions[0]}`);
    set_class(path, 0, clsx([
      "svelte-flow__background-pattern",
      $$props.variant,
      $$props.class
    ]));
  });
  append($$anchor, path);
  return pop($$exports);
}
if (import.meta.hot) {
  LinePattern = hmr(LinePattern, () => LinePattern[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LinePattern[HMR].source;
    set(LinePattern[HMR].source, module.default[HMR].original);
  });
}
var LinePattern_default = LinePattern;

// node_modules/@xyflow/svelte/dist/lib/plugins/Background/Background.svelte
Background[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/plugins/Background/Background.svelte";
var defaultSize = {
  [BackgroundVariant.Dots]: 1,
  [BackgroundVariant.Lines]: 1,
  [BackgroundVariant.Cross]: 6
};
var root27 = add_locations(from_svg(`<svg data-testid="svelte-flow__background"><pattern patternUnits="userSpaceOnUse"><!></pattern><rect x="0" y="0" width="100%" height="100%"></rect></svg>`), Background[FILENAME], [[49, 0, [[55, 2], [70, 2]]]]);
function Background($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Background);
  let variant = prop($$props, "variant", 19, () => BackgroundVariant.Dots), gap = prop($$props, "gap", 3, 20), lineWidth = prop($$props, "lineWidth", 3, 1);
  let store = tag(user_derived(useStore), "store");
  let isDots = tag(user_derived(() => strict_equals(variant(), BackgroundVariant.Dots)), "isDots");
  let isCross = tag(user_derived(() => strict_equals(variant(), BackgroundVariant.Cross)), "isCross");
  let gapXY = tag(user_derived(() => Array.isArray(gap()) ? gap() : [gap(), gap()]), "gapXY");
  let patternId = tag(user_derived(() => `background-pattern-${get(store).flowId}-${$$props.id ?? ""}`), "patternId");
  let scaledGap = tag(
    user_derived(() => [
      get(gapXY)[0] * get(store).viewport.zoom || 1,
      get(gapXY)[1] * get(store).viewport.zoom || 1
    ]),
    "scaledGap"
  );
  let scaledSize = tag(user_derived(() => ($$props.size ?? defaultSize[variant()]) * get(store).viewport.zoom), "scaledSize");
  let patternDimensions = tag(
    user_derived(() => get(isCross) ? [get(scaledSize), get(scaledSize)] : get(scaledGap)),
    "patternDimensions"
  );
  let patternOffset = tag(
    user_derived(() => get(isDots) ? [get(scaledSize) / 2, get(scaledSize) / 2] : [
      get(patternDimensions)[0] / 2,
      get(patternDimensions)[1] / 2
    ]),
    "patternOffset"
  );
  var $$exports = { ...legacy_api() };
  var svg = root27();
  let styles;
  var pattern = child(svg);
  var node = child(pattern);
  {
    var consequent = ($$anchor2) => {
      var fragment = comment();
      var node_1 = first_child(fragment);
      {
        let $0 = user_derived(() => get(scaledSize) / 2);
        add_svelte_meta(
          () => DotPattern_default(node_1, {
            get radius() {
              return get($0);
            },
            get class() {
              return $$props.patternClass;
            }
          }),
          "component",
          Background,
          65,
          6,
          { componentTag: "DotPattern" }
        );
      }
      append($$anchor2, fragment);
    };
    var alternate = ($$anchor2) => {
      var fragment_1 = comment();
      var node_2 = first_child(fragment_1);
      add_svelte_meta(
        () => LinePattern_default(node_2, {
          get dimensions() {
            return get(patternDimensions);
          },
          get variant() {
            return variant();
          },
          get lineWidth() {
            return lineWidth();
          },
          get class() {
            return $$props.patternClass;
          }
        }),
        "component",
        Background,
        67,
        6,
        { componentTag: "LinePattern" }
      );
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(isDots)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Background,
      64,
      4
    );
  }
  reset(pattern);
  var rect = sibling(pattern);
  reset(svg);
  template_effect(() => {
    set_class(svg, 0, clsx([
      "svelte-flow__background",
      "svelte-flow__container",
      $$props.class
    ]));
    styles = set_style(svg, "", styles, {
      "--xy-background-color-props": $$props.bgColor,
      "--xy-background-pattern-color-props": $$props.patternColor
    });
    set_attribute(pattern, "id", get(patternId));
    set_attribute(pattern, "x", get(store).viewport.x % get(scaledGap)[0]);
    set_attribute(pattern, "y", get(store).viewport.y % get(scaledGap)[1]);
    set_attribute(pattern, "width", get(scaledGap)[0]);
    set_attribute(pattern, "height", get(scaledGap)[1]);
    set_attribute(pattern, "patternTransform", `translate(-${get(patternOffset)[0]},-${get(patternOffset)[1]})`);
    set_attribute(rect, "fill", `url(#${get(patternId)})`);
  });
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  Background = hmr(Background, () => Background[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Background[HMR].source;
    set(Background[HMR].source, module.default[HMR].original);
  });
}
var Background_default = Background;

// node_modules/@xyflow/svelte/dist/lib/plugins/Minimap/MinimapNode.svelte
MinimapNode[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/plugins/Minimap/MinimapNode.svelte";
var root_22 = add_locations(from_svg(`<rect></rect>`), MinimapNode[FILENAME], [[55, 2]]);
function MinimapNode($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, MinimapNode);
  let borderRadius = prop($$props, "borderRadius", 3, 5), strokeWidth = prop($$props, "strokeWidth", 3, 2);
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      const CustomComponent = tag(user_derived(() => $$props.nodeComponent), "CustomComponent");
      get(CustomComponent);
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(
        () => component(node_1, () => get(CustomComponent), ($$anchor3, CustomComponent_1) => {
          CustomComponent_1($$anchor3, {
            get id() {
              return $$props.id;
            },
            get x() {
              return $$props.x;
            },
            get y() {
              return $$props.y;
            },
            get width() {
              return $$props.width;
            },
            get height() {
              return $$props.height;
            },
            get borderRadius() {
              return borderRadius();
            },
            get class() {
              return $$props.class;
            },
            get color() {
              return $$props.color;
            },
            get shapeRendering() {
              return $$props.shapeRendering;
            },
            get strokeColor() {
              return $$props.strokeColor;
            },
            get strokeWidth() {
              return strokeWidth();
            },
            get selected() {
              return $$props.selected;
            }
          });
        }),
        "component",
        MinimapNode,
        40,
        2,
        { componentTag: "CustomComponent" }
      );
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var rect = root_22();
      let classes;
      let styles;
      template_effect(() => {
        classes = set_class(rect, 0, clsx(["svelte-flow__minimap-node", $$props.class]), null, classes, { selected: $$props.selected });
        set_attribute(rect, "x", $$props.x);
        set_attribute(rect, "y", $$props.y);
        set_attribute(rect, "rx", borderRadius());
        set_attribute(rect, "ry", borderRadius());
        set_attribute(rect, "width", $$props.width);
        set_attribute(rect, "height", $$props.height);
        set_attribute(rect, "shape-rendering", $$props.shapeRendering);
        styles = set_style(rect, "", styles, {
          fill: $$props.color,
          stroke: $$props.strokeColor,
          "stroke-width": strokeWidth()
        });
      });
      append($$anchor2, rect);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.nodeComponent) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      MinimapNode,
      37,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  MinimapNode = hmr(MinimapNode, () => MinimapNode[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MinimapNode[HMR].source;
    set(MinimapNode[HMR].source, module.default[HMR].original);
  });
}
var MinimapNode_default = MinimapNode;

// node_modules/@xyflow/svelte/dist/lib/plugins/Minimap/interactive.js
function interactive(domNode, params) {
  const minimap = XYMinimap({
    domNode,
    panZoom: params.panZoom,
    getTransform: () => {
      const { viewport } = params.store;
      return [viewport.x, viewport.y, viewport.zoom];
    },
    getViewScale: params.getViewScale
  });
  minimap.update({
    translateExtent: params.translateExtent,
    width: params.width,
    height: params.height,
    inversePan: params.inversePan,
    zoomStep: params.zoomStep,
    pannable: params.pannable,
    zoomable: params.zoomable
  });
  function update(params2) {
    minimap.update({
      translateExtent: params2.translateExtent,
      width: params2.width,
      height: params2.height,
      inversePan: params2.inversePan,
      zoomStep: params2.zoomStep,
      pannable: params2.pannable,
      zoomable: params2.zoomable
    });
  }
  return {
    update,
    destroy() {
      minimap.destroy();
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/plugins/Minimap/Minimap.svelte
Minimap[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/plugins/Minimap/Minimap.svelte";
var getAttrFunction = (func) => func instanceof Function ? func : () => func;
var root_35 = add_locations(from_svg(`<title> </title>`), Minimap[FILENAME], [[116, 8]]);
var root_23 = add_locations(from_svg(`<svg class="svelte-flow__minimap-svg" role="img"><!><!><path class="svelte-flow__minimap-mask" fill-rule="evenodd" pointer-events="none"></path></svg>`), Minimap[FILENAME], [[90, 4, [[139, 6]]]]);
var root28 = add_locations(from_html(`<svelte-css-wrapper style="display: contents"><!></svelte-css-wrapper>`, 1), Minimap[FILENAME], [[82, 0]]);
function Minimap($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Minimap);
  let position = prop($$props, "position", 3, "bottom-right"), nodeStrokeColor = prop($$props, "nodeStrokeColor", 3, "transparent"), nodeClass = prop($$props, "nodeClass", 3, ""), nodeBorderRadius = prop($$props, "nodeBorderRadius", 3, 5), nodeStrokeWidth = prop($$props, "nodeStrokeWidth", 3, 2), width = prop($$props, "width", 3, 200), height = prop($$props, "height", 3, 150), pannable = prop($$props, "pannable", 3, true), zoomable = prop($$props, "zoomable", 3, true), rest = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "position",
      "ariaLabel",
      "nodeStrokeColor",
      "nodeColor",
      "nodeClass",
      "nodeBorderRadius",
      "nodeStrokeWidth",
      "nodeComponent",
      "bgColor",
      "maskColor",
      "maskStrokeColor",
      "maskStrokeWidth",
      "width",
      "height",
      "pannable",
      "zoomable",
      "inversePan",
      "zoomStep",
      "class"
    ],
    "rest"
  );
  let store = tag(user_derived(useStore), "store");
  let ariaLabelConfig = tag(user_derived(() => get(store).ariaLabelConfig), "ariaLabelConfig");
  const nodeColorFunc = strict_equals($$props.nodeColor, void 0) ? void 0 : getAttrFunction($$props.nodeColor);
  const nodeStrokeColorFunc = getAttrFunction(nodeStrokeColor());
  const nodeClassFunc = getAttrFunction(nodeClass());
  const shapeRendering = (
    // @ts-expect-error - TS doesn't know about chrome
    strict_equals(typeof window, "undefined") || !!window.chrome ? "crispEdges" : "geometricPrecision"
  );
  let labelledBy = tag(user_derived(() => `svelte-flow__minimap-desc-${get(store).flowId}`), "labelledBy");
  let viewBB = tag(
    user_derived(() => ({
      x: -get(store).viewport.x / get(store).viewport.zoom,
      y: -get(store).viewport.y / get(store).viewport.zoom,
      width: get(store).width / get(store).viewport.zoom,
      height: get(store).height / get(store).viewport.zoom
    })),
    "viewBB"
  );
  let boundingRect = tag(user_derived(() => getBoundsOfRects(getInternalNodesBounds(get(store).nodeLookup, { filter: (n) => !n.hidden }), get(viewBB))), "boundingRect");
  let scaledWidth = tag(user_derived(() => get(boundingRect).width / width()), "scaledWidth");
  let scaledHeight = tag(user_derived(() => get(boundingRect).height / height()), "scaledHeight");
  let viewScale = tag(user_derived(() => Math.max(get(scaledWidth), get(scaledHeight))), "viewScale");
  let viewWidth = tag(user_derived(() => get(viewScale) * width()), "viewWidth");
  let viewHeight = tag(user_derived(() => get(viewScale) * height()), "viewHeight");
  let offset = tag(user_derived(() => 5 * get(viewScale)), "offset");
  let x = tag(user_derived(() => get(boundingRect).x - (get(viewWidth) - get(boundingRect).width) / 2 - get(offset)), "x");
  let y = tag(user_derived(() => get(boundingRect).y - (get(viewHeight) - get(boundingRect).height) / 2 - get(offset)), "y");
  let viewboxWidth = tag(user_derived(() => get(viewWidth) + get(offset) * 2), "viewboxWidth");
  let viewboxHeight = tag(user_derived(() => get(viewHeight) + get(offset) * 2), "viewboxHeight");
  const getViewScale = () => get(viewScale);
  var $$exports = { ...legacy_api() };
  var fragment = root28();
  var node_1 = first_child(fragment);
  {
    let $0 = user_derived(() => ["svelte-flow__minimap", $$props.class]);
    css_props(node_1, () => ({ "--xy-minimap-background-color-props": $$props.bgColor }));
    Panel_default(node_1.lastChild, spread_props(
      {
        get position() {
          return position();
        },
        get class() {
          return get($0);
        },
        "data-testid": "svelte-flow__minimap"
      },
      () => rest,
      {
        children: wrap_snippet(Minimap, ($$anchor2, $$slotProps) => {
          var fragment_1 = comment();
          var node_2 = first_child(fragment_1);
          {
            var consequent_2 = ($$anchor3) => {
              var svg = root_23();
              let styles;
              var node_3 = child(svg);
              {
                var consequent = ($$anchor4) => {
                  var title = root_35();
                  var text2 = child(title, true);
                  reset(title);
                  template_effect(() => {
                    set_attribute(title, "id", get(labelledBy));
                    set_text(text2, $$props.ariaLabel ?? get(ariaLabelConfig)["minimap.ariaLabel"]);
                  });
                  append($$anchor4, title);
                };
                add_svelte_meta(
                  () => if_block(node_3, ($$render) => {
                    if ($$props.ariaLabel ?? get(ariaLabelConfig)["minimap.ariaLabel"]) $$render(consequent);
                  }),
                  "if",
                  Minimap,
                  115,
                  6
                );
              }
              var node_4 = sibling(node_3);
              validate_each_keys(() => get(store).nodes, (userNode) => userNode.id);
              add_svelte_meta(
                () => each(node_4, 17, () => get(store).nodes, (userNode) => userNode.id, ($$anchor4, userNode) => {
                  const node = tag(user_derived(() => get(store).nodeLookup.get(get(userNode).id)), "node");
                  get(node);
                  var fragment_2 = comment();
                  var node_5 = first_child(fragment_2);
                  {
                    var consequent_1 = ($$anchor5) => {
                      const nodeDimesions = tag(user_derived(() => getNodeDimensions(get(node))), "nodeDimesions");
                      get(nodeDimesions);
                      var fragment_3 = comment();
                      var node_6 = first_child(fragment_3);
                      {
                        let $02 = user_derived(() => nodeColorFunc?.(get(node)));
                        let $1 = user_derived(() => nodeStrokeColorFunc(get(node)));
                        let $2 = user_derived(() => nodeClassFunc(get(node)));
                        add_svelte_meta(
                          () => MinimapNode_default(node_6, spread_props(
                            {
                              get id() {
                                return get(node).id;
                              },
                              get x() {
                                return get(node).internals.positionAbsolute.x;
                              },
                              get y() {
                                return get(node).internals.positionAbsolute.y;
                              }
                            },
                            () => get(nodeDimesions),
                            {
                              get selected() {
                                return get(node).selected;
                              },
                              get nodeComponent() {
                                return $$props.nodeComponent;
                              },
                              get color() {
                                return get($02);
                              },
                              get borderRadius() {
                                return nodeBorderRadius();
                              },
                              get strokeColor() {
                                return get($1);
                              },
                              get strokeWidth() {
                                return nodeStrokeWidth();
                              },
                              get shapeRendering() {
                                return shapeRendering;
                              },
                              get class() {
                                return get($2);
                              }
                            }
                          )),
                          "component",
                          Minimap,
                          123,
                          10,
                          { componentTag: "MinimapNode" }
                        );
                      }
                      append($$anchor5, fragment_3);
                    };
                    add_svelte_meta(
                      () => if_block(node_5, ($$render) => {
                        if (get(node) && nodeHasDimensions(get(node)) && !get(node).hidden) $$render(consequent_1);
                      }),
                      "if",
                      Minimap,
                      121,
                      8
                    );
                  }
                  append($$anchor4, fragment_2);
                }),
                "each",
                Minimap,
                119,
                6
              );
              var path = sibling(node_4);
              reset(svg);
              action(svg, ($$node, $$action_arg) => interactive?.($$node, $$action_arg), () => ({
                store: get(store),
                panZoom: get(store).panZoom,
                getViewScale,
                translateExtent: get(store).translateExtent,
                width: get(store).width,
                height: get(store).height,
                inversePan: $$props.inversePan,
                zoomStep: $$props.zoomStep,
                pannable: pannable(),
                zoomable: zoomable()
              }));
              template_effect(() => {
                set_attribute(svg, "width", width());
                set_attribute(svg, "height", height());
                set_attribute(svg, "viewBox", `${get(x) ?? ""} ${get(y) ?? ""} ${get(viewboxWidth) ?? ""} ${get(viewboxHeight) ?? ""}`);
                set_attribute(svg, "aria-labelledby", get(labelledBy));
                styles = set_style(svg, "", styles, {
                  "--xy-minimap-mask-background-color-props": $$props.maskColor,
                  "--xy-minimap-mask-stroke-color-props": $$props.maskStrokeColor,
                  "--xy-minimap-mask-stroke-width-props": $$props.maskStrokeWidth ? $$props.maskStrokeWidth * get(viewScale) : void 0
                });
                set_attribute(path, "d", `M${get(x) - get(offset)},${get(y) - get(offset)}h${get(viewboxWidth) + get(offset) * 2}v${get(viewboxHeight) + get(offset) * 2}h${-get(viewboxWidth) - get(offset) * 2}z
      M${get(viewBB).x ?? ""},${get(viewBB).y ?? ""}h${get(viewBB).width ?? ""}v${get(viewBB).height ?? ""}h${-get(viewBB).width}z`);
              });
              append($$anchor3, svg);
            };
            add_svelte_meta(
              () => if_block(node_2, ($$render) => {
                if (get(store).panZoom) $$render(consequent_2);
              }),
              "if",
              Minimap,
              89,
              2
            );
          }
          append($$anchor2, fragment_1);
        }),
        $$slots: { default: true }
      }
    ));
    reset(node_1);
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Minimap = hmr(Minimap, () => Minimap[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Minimap[HMR].source;
    set(Minimap[HMR].source, module.default[HMR].original);
  });
}
var Minimap_default = Minimap;

// node_modules/@xyflow/svelte/dist/lib/plugins/NodeToolbar/NodeToolbar.svelte
NodeToolbar[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/plugins/NodeToolbar/NodeToolbar.svelte";
var root_111 = add_locations(from_html(`<div><!></div>`), NodeToolbar[FILENAME], [[69, 2]]);
function NodeToolbar($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, NodeToolbar);
  let position = prop($$props, "position", 19, () => Position.Top), align = prop($$props, "align", 3, "center"), offset = prop($$props, "offset", 3, 10), rest = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "nodeId",
      "position",
      "align",
      "offset",
      "isVisible",
      "children"
    ],
    "rest"
  );
  const store = useStore();
  const { getNodesBounds: getNodesBounds2 } = useSvelteFlow();
  const contextNodeId = getContext("svelteflow__node_id");
  let toolbarNodes = tag(
    user_derived(() => {
      store.nodes;
      const nodeIds = Array.isArray($$props.nodeId) ? $$props.nodeId : [$$props.nodeId ?? contextNodeId];
      return nodeIds.reduce(
        (res, nodeId) => {
          const node = store.nodeLookup.get(nodeId);
          if (node) {
            res.push(node);
          }
          return res;
        },
        []
      );
    }),
    "toolbarNodes"
  );
  let transform2 = tag(
    user_derived(() => {
      const nodeRect = getNodesBounds2(get(toolbarNodes));
      if (nodeRect) {
        return getNodeToolbarTransform(nodeRect, store.viewport, position(), offset(), align());
      }
      return "";
    }),
    "transform"
  );
  let zIndex = tag(
    user_derived(() => strict_equals(get(toolbarNodes).length, 0) ? 1 : Math.max(...get(toolbarNodes).map((node) => (node.internals.z || 5) + 1))),
    "zIndex"
  );
  let selectedNodesCount = tag(user_derived(() => store.nodes.filter((node) => node.selected).length), "selectedNodesCount");
  let isActive = tag(
    user_derived(() => strict_equals(typeof $$props.isVisible, "boolean") ? $$props.isVisible : strict_equals(get(toolbarNodes).length, 1) && get(toolbarNodes)[0].selected && strict_equals(get(selectedNodesCount), 1)),
    "isActive"
  );
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node_1 = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var div = root_111();
      attribute_effect(
        div,
        ($0, $1) => ({
          class: "svelte-flow__node-toolbar",
          "data-id": $0,
          ...rest,
          [STYLE]: $1
        }),
        [
          () => get(toolbarNodes).reduce((acc, node) => `${acc}${node.id} `, "").trim(),
          () => ({
            display: hideOnSSR().value ? "none" : void 0,
            position: "absolute",
            transform: get(transform2),
            "z-index": get(zIndex)
          })
        ]
      );
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", NodeToolbar, 79, 4);
      reset(div);
      action(div, ($$node, $$action_arg) => portal?.($$node, $$action_arg), () => "root");
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        if (store.domNode && get(isActive) && get(toolbarNodes)) $$render(consequent);
      }),
      "if",
      NodeToolbar,
      68,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  NodeToolbar = hmr(NodeToolbar, () => NodeToolbar[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = NodeToolbar[HMR].source;
    set(NodeToolbar[HMR].source, module.default[HMR].original);
  });
}
var NodeToolbar_default = NodeToolbar;

// node_modules/@xyflow/svelte/dist/lib/plugins/EdgeToolbar/EdgeToolbar.svelte
EdgeToolbar[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/plugins/EdgeToolbar/EdgeToolbar.svelte";
var root_24 = add_locations(from_html(`<div><!></div>`), EdgeToolbar[FILENAME], [[36, 4]]);
function EdgeToolbar($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, EdgeToolbar);
  let alignX = prop($$props, "alignX", 3, "center"), alignY = prop($$props, "alignY", 3, "center"), rest = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "x",
      "y",
      "alignX",
      "alignY",
      "isVisible",
      "selectEdgeOnClick",
      "class",
      "children"
    ],
    "rest"
  );
  const store = useStore();
  const edgeId = getContext("svelteflow__edge_id");
  if (!edgeId) {
    throw new Error("EdgeToolbar must be used within an edge");
  }
  const isActive = tag(
    user_derived(() => strict_equals(typeof $$props.isVisible, "boolean") ? $$props.isVisible : store.edgeLookup.get(edgeId)?.selected),
    "isActive"
  );
  const transform2 = tag(user_derived(() => getEdgeToolbarTransform($$props.x, $$props.y, store.viewport.zoom, alignX(), alignY())), "transform");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(
        () => EdgeLabel_default(node_1, {
          get selectEdgeOnClick() {
            return $$props.selectEdgeOnClick;
          },
          transparent: true,
          children: wrap_snippet(EdgeToolbar, ($$anchor3, $$slotProps) => {
            var div = root_24();
            attribute_effect(div, () => ({
              class: ["svelte-flow__edge-toolbar", $$props.class],
              "data-id": edgeId,
              ...rest,
              [STYLE]: {
                position: "absolute",
                transform: get(transform2),
                "transform-origin": "0 0"
              }
            }));
            var node_2 = child(div);
            add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", EdgeToolbar, 44, 6);
            reset(div);
            append($$anchor3, div);
          }),
          $$slots: { default: true }
        }),
        "component",
        EdgeToolbar,
        35,
        2,
        { componentTag: "EdgeLabel" }
      );
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(isActive)) $$render(consequent);
      }),
      "if",
      EdgeToolbar,
      34,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  EdgeToolbar = hmr(EdgeToolbar, () => EdgeToolbar[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = EdgeToolbar[HMR].source;
    set(EdgeToolbar[HMR].source, module.default[HMR].original);
  });
}
var EdgeToolbar_default = EdgeToolbar;

// node_modules/@xyflow/svelte/dist/lib/plugins/NodeResizer/ResizeControl.svelte
ResizeControl[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/plugins/NodeResizer/ResizeControl.svelte";
var root29 = add_locations(from_html(`<div><!></div>`), ResizeControl[FILENAME], [[123, 0]]);
function ResizeControl($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, ResizeControl);
  let variant = prop($$props, "variant", 19, () => ResizeControlVariant.Handle), minWidth = prop($$props, "minWidth", 3, 10), minHeight = prop($$props, "minHeight", 3, 10), maxWidth = prop($$props, "maxWidth", 19, () => Number.MAX_VALUE), maxHeight = prop($$props, "maxHeight", 19, () => Number.MAX_VALUE), keepAspectRatio = prop($$props, "keepAspectRatio", 3, false), autoScale = prop($$props, "autoScale", 3, true), rest = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "nodeId",
      "position",
      "variant",
      "color",
      "minWidth",
      "minHeight",
      "maxWidth",
      "maxHeight",
      "keepAspectRatio",
      "resizeDirection",
      "autoScale",
      "shouldResize",
      "onResizeStart",
      "onResize",
      "onResizeEnd",
      "class",
      "children"
    ],
    "rest"
  );
  const store = useStore();
  let id2 = tag(user_derived(() => strict_equals(typeof $$props.nodeId, "string") ? $$props.nodeId : getContext("svelteflow__node_id")), "id");
  let resizeControlRef;
  let resizer = tag(state(null), "resizer");
  let isLineVariant = tag(user_derived(() => strict_equals(variant(), ResizeControlVariant.Line)), "isLineVariant");
  let controlPosition = tag(
    user_derived(() => {
      let defaultPosition = get(isLineVariant) ? "right" : "bottom-right";
      return $$props.position ?? defaultPosition;
    }),
    "controlPosition"
  );
  let positionClasses = tag(user_derived(() => get(controlPosition).split("-")), "positionClasses");
  onMount(() => {
    if (resizeControlRef) {
      set(
        resizer,
        XYResizer({
          domNode: resizeControlRef,
          nodeId: get(id2),
          getStoreItems: () => {
            return {
              nodeLookup: store.nodeLookup,
              transform: [store.viewport.x, store.viewport.y, store.viewport.zoom],
              snapGrid: store.snapGrid ?? void 0,
              snapToGrid: !!store.snapGrid,
              nodeOrigin: store.nodeOrigin,
              paneDomNode: store.domNode
            };
          },
          onChange: (change, childChanges) => {
            const changes = /* @__PURE__ */ new Map();
            changes.set(get(id2), change);
            for (const childChange of childChanges) {
              changes.set(childChange.id, { x: childChange.position.x, y: childChange.position.y });
            }
            store.nodes = store.nodes.map((node) => {
              const change2 = changes.get(node.id);
              const horizontal = !$$props.resizeDirection || strict_equals($$props.resizeDirection, "horizontal");
              const vertical = !$$props.resizeDirection || strict_equals($$props.resizeDirection, "vertical");
              if (change2) {
                return {
                  ...node,
                  position: {
                    x: horizontal ? change2.x ?? node.position.x : node.position.x,
                    y: vertical ? change2.y ?? node.position.y : node.position.y
                  },
                  width: horizontal ? change2.width ?? node.width : node.width,
                  height: vertical ? change2.height ?? node.height : node.height
                };
              }
              return node;
            });
          }
        }),
        true
      );
    }
    return () => {
      get(resizer)?.destroy();
    };
  });
  user_pre_effect(() => {
    get(resizer)?.update({
      controlPosition: get(controlPosition),
      boundaries: {
        minWidth: minWidth(),
        minHeight: minHeight(),
        maxWidth: maxWidth(),
        maxHeight: maxHeight()
      },
      keepAspectRatio: !!keepAspectRatio(),
      resizeDirection: $$props.resizeDirection,
      onResizeStart: $$props.onResizeStart,
      onResize: $$props.onResize,
      onResizeEnd: $$props.onResizeEnd,
      shouldResize: $$props.shouldResize
    });
  });
  var $$exports = { ...legacy_api() };
  var div = root29();
  attribute_effect(div, ($0, $1) => ({ class: $0, ...rest, [STYLE]: $1 }), [
    () => [
      "svelte-flow__resize-control",
      store.noDragClass,
      ...get(positionClasses),
      variant(),
      $$props.class
    ],
    () => ({
      "border-color": get(isLineVariant) ? $$props.color : void 0,
      "background-color": get(isLineVariant) ? void 0 : $$props.color,
      scale: get(isLineVariant) || !autoScale() ? void 0 : Math.max(1 / store.viewport.zoom, 1)
    })
  ]);
  var node_1 = child(div);
  add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop), "render", ResizeControl, 131, 2);
  reset(div);
  bind_this(div, ($$value) => resizeControlRef = $$value, () => resizeControlRef);
  append($$anchor, div);
  return pop($$exports);
}
if (import.meta.hot) {
  ResizeControl = hmr(ResizeControl, () => ResizeControl[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ResizeControl[HMR].source;
    set(ResizeControl[HMR].source, module.default[HMR].original);
  });
}
var ResizeControl_default = ResizeControl;

// node_modules/@xyflow/svelte/dist/lib/plugins/NodeResizer/NodeResizer.svelte
NodeResizer[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/plugins/NodeResizer/NodeResizer.svelte";
var root_112 = add_locations(from_html(`<!> <!>`, 1), NodeResizer[FILENAME], []);
function NodeResizer($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, NodeResizer);
  let isVisible = prop($$props, "isVisible", 3, true), autoScale = prop($$props, "autoScale", 3, true), rest = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "isVisible",
      "nodeId",
      "handleClass",
      "handleStyle",
      "lineClass",
      "lineStyle",
      "autoScale"
    ],
    "rest"
  );
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = root_112();
      var node_1 = first_child(fragment_1);
      validate_each_keys(() => XY_RESIZER_LINE_POSITIONS, (position) => position);
      add_svelte_meta(
        () => each(node_1, 16, () => XY_RESIZER_LINE_POSITIONS, (position) => position, ($$anchor3, position) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          add_svelte_meta(
            () => ResizeControl_default(node_2, spread_props(
              {
                get class() {
                  return $$props.lineClass;
                },
                get style() {
                  return $$props.lineStyle;
                },
                get nodeId() {
                  return $$props.nodeId;
                },
                get position() {
                  return position;
                },
                get autoScale() {
                  return autoScale();
                },
                get variant() {
                  return ResizeControlVariant.Line;
                }
              },
              () => rest
            )),
            "component",
            NodeResizer,
            24,
            4,
            { componentTag: "ResizeControl" }
          );
          append($$anchor3, fragment_2);
        }),
        "each",
        NodeResizer,
        23,
        2
      );
      var node_3 = sibling(node_1, 2);
      validate_each_keys(() => XY_RESIZER_HANDLE_POSITIONS, (position) => position);
      add_svelte_meta(
        () => each(node_3, 16, () => XY_RESIZER_HANDLE_POSITIONS, (position) => position, ($$anchor3, position) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          add_svelte_meta(
            () => ResizeControl_default(node_4, spread_props(
              {
                get class() {
                  return $$props.handleClass;
                },
                get style() {
                  return $$props.handleStyle;
                },
                get nodeId() {
                  return $$props.nodeId;
                },
                get position() {
                  return position;
                },
                get autoScale() {
                  return autoScale();
                }
              },
              () => rest
            )),
            "component",
            NodeResizer,
            35,
            4,
            { componentTag: "ResizeControl" }
          );
          append($$anchor3, fragment_3);
        }),
        "each",
        NodeResizer,
        34,
        2
      );
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (isVisible()) $$render(consequent);
      }),
      "if",
      NodeResizer,
      22,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  NodeResizer = hmr(NodeResizer, () => NodeResizer[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = NodeResizer[HMR].source;
    set(NodeResizer[HMR].source, module.default[HMR].original);
  });
}
var NodeResizer_default = NodeResizer;

// node_modules/@xyflow/svelte/dist/lib/hooks/useUpdateNodeInternals.svelte.js
function useUpdateNodeInternals() {
  const $$d = tag(user_derived(useStore), "[$derived object]"), domNode = tag(user_derived(() => get($$d).domNode), "domNode"), updateNodeInternals2 = tag(user_derived(() => get($$d).updateNodeInternals), "updateNodeInternals");
  const nodeId = getContext("svelteflow__node_id");
  const updateInternals = (id2) => {
    if (!id2 && !nodeId) {
      throw new Error("When using outside of a node, you must provide an id.");
    }
    const updateIds = id2 ? Array.isArray(id2) ? id2 : [id2] : [nodeId];
    const updates = /* @__PURE__ */ new Map();
    updateIds.forEach((updateId) => {
      const nodeElement = get(domNode)?.querySelector(`.svelte-flow__node[data-id="${updateId}"]`);
      if (nodeElement) {
        updates.set(updateId, { id: updateId, nodeElement, force: true });
      }
    });
    requestAnimationFrame(() => get(updateNodeInternals2)(updates));
  };
  return updateInternals;
}

// node_modules/@xyflow/svelte/dist/lib/hooks/useConnection.svelte.js
function useConnection() {
  const $$d = tag(user_derived(useStore), "[$derived object]"), connection = tag(user_derived(() => get($$d).connection), "connection");
  return {
    get current() {
      return get(connection);
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/hooks/useNodesEdgesViewport.svelte.js
function useNodes() {
  const store = tag(user_derived(useStore), "store");
  return {
    get current() {
      return get(store).nodes;
    },
    set current(nodes) {
      get(store).nodes = nodes;
    },
    update(updateFn) {
      get(store).nodes = updateFn(get(store).nodes);
    },
    set(nodes) {
      get(store).nodes = nodes;
    }
  };
}
function useEdges() {
  const store = tag(user_derived(useStore), "store");
  return {
    get current() {
      return get(store).edges;
    },
    set current(edges) {
      get(store).edges = edges;
    },
    update(updateFn) {
      get(store).edges = updateFn(get(store).edges);
    },
    set(edges) {
      get(store).edges = edges;
    }
  };
}
function useViewport() {
  const store = tag(user_derived(useStore), "store");
  return {
    get current() {
      return get(store).viewport;
    },
    set current(viewport) {
      get(store).viewport = viewport;
    },
    update(updateFn) {
      get(store).viewport = updateFn(get(store).viewport);
    },
    set(viewport) {
      get(store).viewport = viewport;
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/hooks/useNodeConnections.svelte.js
var initialConnections = [];
function useNodeConnections({ id: id2, handleType, handleId, onConnect, onDisconnect } = {}) {
  const $$d = tag(user_derived(useStore), "[$derived object]"), edges = tag(user_derived(() => get($$d).edges), "edges"), connectionLookup = tag(user_derived(() => get($$d).connectionLookup), "connectionLookup");
  const contextNodeId = getContext("svelteflow__node_id");
  const nodeId = id2 ?? contextNodeId;
  let connectionMaps = { previous: /* @__PURE__ */ new Map(), next: /* @__PURE__ */ new Map() };
  let connectionsArray = initialConnections;
  const connections = tag(
    user_derived(() => {
      get(edges);
      const prevConnections = connectionMaps.next;
      const nextConnections = get(connectionLookup).get(`${nodeId}${handleType ? handleId ? `-${handleType}-${handleId}` : `-${handleType}` : ""}`) ?? /* @__PURE__ */ new Map();
      if (!areConnectionMapsEqual(nextConnections, prevConnections)) {
        connectionMaps = { previous: prevConnections, next: nextConnections };
        connectionsArray = Array.from(nextConnections.values() || initialConnections);
      }
      return connectionsArray;
    }),
    "connections"
  );
  user_effect(() => {
    if (onConnect) {
      get(connections);
      handleConnectionChange(connectionMaps.next, connectionMaps.previous, onConnect);
    }
    if (onDisconnect) {
      get(connections);
      handleConnectionChange(connectionMaps.previous, connectionMaps.next, onDisconnect);
    }
  });
  return {
    get current() {
      return get(connections);
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/hooks/useNodesData.svelte.js
function useNodesData(nodeIds) {
  const $$d = tag(user_derived(useStore), "[$derived object]"), nodes = tag(user_derived(() => get($$d).nodes), "nodes"), nodeLookup = tag(user_derived(() => get($$d).nodeLookup), "nodeLookup");
  let prevNodesData = [];
  let initialRun = true;
  const nodeData = tag(
    user_derived(() => {
      get(nodes);
      const nextNodesData = [];
      const isArrayOfIds = Array.isArray(nodeIds);
      const _nodeIds = isArrayOfIds ? nodeIds : [nodeIds];
      for (const nodeId of _nodeIds) {
        const node = get(nodeLookup).get(nodeId)?.internals.userNode;
        if (node) {
          nextNodesData.push({ id: node.id, type: node.type, data: node.data });
        }
      }
      if (!shallowNodeData(nextNodesData, prevNodesData) || initialRun) {
        prevNodesData = nextNodesData;
        initialRun = false;
      }
      return isArrayOfIds ? prevNodesData : prevNodesData[0] ?? null;
    }),
    "nodeData"
  );
  return {
    get current() {
      return get(nodeData);
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/hooks/useInternalNode.svelte.js
function useInternalNode(id2) {
  const $$d = tag(user_derived(useStore), "[$derived object]"), nodeLookup = tag(user_derived(() => get($$d).nodeLookup), "nodeLookup"), nodes = tag(user_derived(() => get($$d).nodes), "nodes");
  const node = tag(
    user_derived(() => {
      get(nodes);
      return get(nodeLookup).get(id2);
    }),
    "node"
  );
  return {
    get current() {
      return get(node);
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/hooks/useInitialized.svelte.js
function useNodesInitialized() {
  const $$d = tag(user_derived(useStore), "[$derived object]"), nodesInitialized = tag(user_derived(() => get($$d).nodesInitialized), "nodesInitialized");
  return {
    get current() {
      return get(nodesInitialized);
    }
  };
}
function useViewportInitialized() {
  const $$d_1 = tag(user_derived(useStore), "[$derived object]"), viewportInitialized = tag(user_derived(() => get($$d_1).viewportInitialized), "viewportInitialized");
  return {
    get current() {
      return get(viewportInitialized);
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/hooks/useOnSelectionChange.svelte.js
function useOnSelectionChange(onselectionchange) {
  const store = tag(user_derived(useStore), "store");
  const symbol = Symbol();
  user_effect(() => {
    get(store).selectionChangeHandlers.set(symbol, onselectionchange);
    return () => {
      get(store).selectionChangeHandlers.delete(symbol);
    };
  });
}
export {
  Background_default as Background,
  BackgroundVariant,
  BaseEdge_default as BaseEdge,
  BezierEdge_default as BezierEdge,
  ConnectionLineType,
  ConnectionMode,
  ControlButton_default as ControlButton,
  Controls_default as Controls,
  EdgeLabel_default as EdgeLabel,
  EdgeReconnectAnchor_default as EdgeReconnectAnchor,
  EdgeToolbar_default as EdgeToolbar,
  Handle_default as Handle,
  MarkerType,
  Minimap_default as MiniMap,
  MinimapNode_default as MiniMapNode,
  ResizeControl_default as NodeResizeControl,
  NodeResizer_default as NodeResizer,
  NodeToolbar_default as NodeToolbar,
  PanOnScrollMode,
  Panel_default as Panel,
  Position,
  ResizeControlVariant,
  SelectionMode,
  SmoothStepEdge_default as SmoothStepEdge,
  StepEdge_default as StepEdge,
  StraightEdge_default as StraightEdge,
  SvelteFlow_default as SvelteFlow,
  SvelteFlowProvider_default as SvelteFlowProvider,
  ViewportPortal_default as ViewportPortal,
  addEdge,
  arrowKeyDiffs,
  getBezierEdgeCenter,
  getBezierPath,
  getConnectedEdges,
  getEdgeCenter,
  getIncomers,
  getNodesBounds,
  getOutgoers,
  getSmoothStepPath,
  getStraightPath,
  getViewportForBounds,
  hideOnSSR,
  isEdge,
  isNode,
  portal,
  toPxString,
  useConnection,
  useEdges,
  useInternalNode,
  useNodeConnections,
  useNodes,
  useNodesData,
  useNodesInitialized,
  useOnSelectionChange,
  useStore,
  useSvelteFlow,
  useUpdateNodeInternals,
  useViewport,
  useViewportInitialized
};
//# sourceMappingURL=@xyflow_svelte.js.map
